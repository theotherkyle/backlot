//
// Title: LiveSwitch for JavaScript
// Version: 1.13.0.45074
// Copyright Frozen Mountain Software 2011+
//
declare namespace fm.liveswitch {
    class ArrayExtensions {
        getTypeString(): string;
        static getCount<T>(array: T[]): number;
        static add<T>(array: T[], value: T): void;
        static remove<T>(array: T[], value: T): boolean;
        static removeAt<T>(array: T[], index: number): void;
        static insert<T>(array: T[], index: number, value: T): void;
        static toArray<T>(array: T[]): T[];
        static clear<T>(array: T[]): void;
        static addRange<T>(array: T[], values: T[]): void;
        static getRange<T>(array: T[], index: number, count: number): T[];
        static contains<T>(array: T[], value: T): boolean;
        static newArray<T>(values: T[]): T[];
        static clone<T>(array: T[]): T[];
        static map<T, R>(array: T[], callback: fm.liveswitch.IFunction3<T, number, T[], R>): R[];
    }
}
declare namespace fm.liveswitch {
    /** @hidden */
    abstract class AsyncLoggerBase implements fm.liveswitch.ILog {
        getTypeString(): string;
        /** @hidden */
        private _tag;
        constructor(tag: string);
        protected static processLogEvent(logEvent: fm.liveswitch.LogEvent): void;
        debug(message: string): void;
        debug(message: string, ex: fm.liveswitch.Exception): void;
        debug(scope: string, message: string): void;
        debug(scope: string, message: string, ex: fm.liveswitch.Exception): void;
        protected doLog(level: fm.liveswitch.LogLevel, scope: string, message: string, exception: fm.liveswitch.Exception): void;
        protected abstract doQueueLogEvent(logEvent: fm.liveswitch.LogEvent): void;
        error(message: string): void;
        error(message: string, ex: fm.liveswitch.Exception): void;
        error(scope: string, message: string): void;
        error(scope: string, message: string, ex: fm.liveswitch.Exception): void;
        fatal(message: string): void;
        fatal(message: string, ex: fm.liveswitch.Exception): void;
        fatal(scope: string, message: string): void;
        fatal(scope: string, message: string, ex: fm.liveswitch.Exception): void;
        abstract flush(): void;
        getIsDebugEnabled(): boolean;
        getIsErrorEnabled(): boolean;
        getIsFatalEnabled(): boolean;
        getIsInfoEnabled(): boolean;
        getIsVerboseEnabled(): boolean;
        getIsWarnEnabled(): boolean;
        getTag(): string;
        info(message: string): void;
        info(message: string, ex: fm.liveswitch.Exception): void;
        info(scope: string, message: string): void;
        info(scope: string, message: string, ex: fm.liveswitch.Exception): void;
        isLogEnabled(level: fm.liveswitch.LogLevel): boolean;
        log(logEvent: fm.liveswitch.LogEvent): void;
        log(message: string): void;
        log(scope: string, message: string): void;
        /** @hidden */
        private setTag;
        verbose(message: string): void;
        verbose(message: string, ex: fm.liveswitch.Exception): void;
        verbose(scope: string, message: string): void;
        verbose(scope: string, message: string, ex: fm.liveswitch.Exception): void;
        warn(message: string): void;
        warn(message: string, ex: fm.liveswitch.Exception): void;
        warn(scope: string, message: string): void;
        warn(scope: string, message: string, ex: fm.liveswitch.Exception): void;
    }
}
declare namespace fm.liveswitch {
}
declare namespace fm.liveswitch {
    class AtomicInteger {
        private _value;
        constructor(startValue?: number);
        compareAndSwap(expected: number, newValue: number): number;
        getValue(): number;
        add(value: number): number;
        subtract(value: number): number;
        increment(): number;
        decrement(): number;
    }
}
declare namespace fm.liveswitch {
    class AtomicLong {
        private _value;
        constructor(startValue?: number);
        compareAndSwap(expected: number, newValue: number): number;
        getValue(): number;
        add(value: number): number;
        subtract(value: number): number;
        increment(): number;
        decrement(): number;
    }
}
declare namespace fm.liveswitch {
    class Base64 {
        getTypeString(): string;
        private static _base64Regex;
        static encode(b: Uint8Array): string;
        static encodeBuffer(buffer: fm.liveswitch.DataBuffer): string;
        static decode(s: string): Uint8Array;
        static tryEncode(b: Uint8Array, result: fm.liveswitch.Holder<string>): boolean;
        static tryEncodeBuffer(buffer: fm.liveswitch.DataBuffer, result: fm.liveswitch.Holder<string>): boolean;
        static tryDecode(s: string, result: fm.liveswitch.Holder<Uint8Array>): boolean;
        private static b64ToUint6;
        private static decodeIt;
        private static uint6ToB64;
        private static encodeIt;
    }
}
declare namespace fm.liveswitch {
    class BitAssistant {
        getTypeString(): string;
        static castByte(value: number): number;
        static castInteger(value: number): number;
        static castLong(value: number): number;
        static leftShift(value: number, count: number): number;
        static leftShiftShort(value: number, count: number): number;
        static leftShiftInteger(value: number, count: number): number;
        static leftShiftLong(value: number, count: number): number;
        static rightShift(value: number, count: number): number;
        static rightShiftShort(value: number, count: number): number;
        static rightShiftInteger(value: number, count: number): number;
        static rightShiftLong(value: number, count: number): number;
        static sequencesAreEqual(array1: Uint8Array, array2: Uint8Array): boolean;
        static sequencesAreEqual(array1: Uint8Array, offset1: number, array2: Uint8Array, offset2: number, length: number): boolean;
        static sequencesAreEqualConstantTime(array1: Uint8Array, array2: Uint8Array): boolean;
        static sequencesAreEqualConstantTime(array1: Uint8Array, offset1: number, array2: Uint8Array, offset2: number, length: number): boolean;
        static subArray(array: Uint8Array, offset: number, count?: number): Uint8Array;
        static reverse(array: Uint8Array): void;
        static copy(source: Uint8Array, sourceIndex: number, destination: Uint8Array, destinationIndex: number, length: number): void;
        static set(array: Uint8Array, index: number, length: number, value: number): void;
        static getHexString(array: Uint8Array): string;
        static getHexString(array: Uint8Array, offset: number, length: number): string;
        static getHexBytes(s: string): Uint8Array;
    }
}
declare namespace fm.liveswitch {
    class BooleanExtensions {
        getTypeString(): string;
        static toString(value: boolean, format?: string): string;
    }
}
declare namespace fm.liveswitch {
    class ByteCollection {
        getTypeString(): string;
        private _buffer;
        constructor(buffer?: Uint8Array);
        count(): number;
        add(b: number): void;
        addRange(buffer: Uint8Array): void;
        removeRange(index: number, count: number): void;
        insertRange(index: number, buffer: Uint8Array): void;
        getRange(index: number, count: number): Uint8Array;
        get(index: number): number;
        toArray(): Uint8Array;
    }
}
declare namespace fm.liveswitch {
    /**
    Base class for all logging provider implementations.
    */
    abstract class LogProvider {
        getTypeString(): string;
        /** @hidden */
        private _filter;
        /** @hidden */
        private _level;
        /** @hidden */
        private _processId;
        private fmliveswitchLogProviderInit;
        /**
        Initializes a new instance of the [[fm.liveswitch.logProvider]] class.
        */
        constructor();
        /**
        Converts a log-level to a 5-character string for consistently-spaced character sequences.
        @param level The log level.
        @return The log level as an upper-case string
                    with right-side whitespace padding to ensure
                    a 5-character sequence.
        */
        static getLogLevelString(level: fm.liveswitch.LogLevel): string;
        /**
        Converts a timestamp to an ISO-8601-formatted string for rendering in a log message (YYYY-MM-DDThh:mm:ss.sssZ).
        @param timestamp The timestamp.
        @return The timestamp as a formatted string.
        */
        static getPrefixTimestamp(timestamp: fm.liveswitch.DateTime): string;
        /**
        Returns the name of the current product.
        */
        static getProduct(): string;
        /**
        Logs a message at the specified log level.
        @param logEvent The log event details.
        */
        protected abstract doLog(logEvent: fm.liveswitch.LogEvent): void;
        /**
        Generates a default log line.
        @param logEvent The log event details.
        */
        protected generateLogLine(logEvent: fm.liveswitch.LogEvent): string;
        /**
        Gets a filter on the log provider. Returning `true` will log the event, while returning `false` will skip it.
        */
        getFilter(): fm.liveswitch.IFunction1<fm.liveswitch.LogEvent, boolean>;
        /**
        Gets the log level.
        */
        getLevel(): fm.liveswitch.LogLevel;
        /**
        Converts a log-level to a 5-character string for consistently-spaced character sequences.
        @param level The log level.
        @param includeTimestamp Whether to include a timestamp in the prefix.
        @return The log level as an upper-case string
                    with right-side whitespace padding to ensure
                    a 5-character sequence.
        */
        protected getPrefix(level: fm.liveswitch.LogLevel, includeTimestamp: boolean): string;
        /**
        Gets the current process id.
        */
        protected getProcessId(): number;
        /**
        Log a message.
        @param logEvent The log event details.
        */
        log(logEvent: fm.liveswitch.LogEvent): void;
        /**
        Sets a filter on the log provider. Returning `true` will log the event, while returning `false` will skip it.
        */
        setFilter(value: fm.liveswitch.IFunction1<fm.liveswitch.LogEvent, boolean>): void;
        /**
        Sets the log level.
        */
        setLevel(value: fm.liveswitch.LogLevel): void;
        /** @hidden */
        private setProcessId;
    }
}
declare namespace fm.liveswitch {
    class ConsoleLogProvider extends fm.liveswitch.LogProvider {
        getTypeString(): string;
        constructor(level?: fm.liveswitch.LogLevel);
        writeLine(text: string): void;
        doLog(logItem: fm.liveswitch.LogEvent): void;
    }
}
declare namespace fm.liveswitch {
    class Convert {
        getTypeString(): string;
        static toInt32(s: string, base: number): number;
    }
}
declare namespace fm.liveswitch {
    class CultureInfo {
        static getInvariantCulture(): CultureInfo;
        static getCurrentCulture(): CultureInfo;
        constructor();
    }
}
declare namespace fm.liveswitch {
    class DateTime {
        getTypeString(): string;
        private _date;
        constructor(date: Date);
        constructor(ticks: number);
        constructor(year: number, month: number, day: number, hour: number, minute: number, second: number);
        constructor(year: number, month: number, day: number, hour: number, minute: number, second: number, millisecond: number);
        static getNow(): DateTime;
        static getUtcNow(): DateTime;
        getDate(): Date;
        getTicks(): number;
        toUniversalTime(): DateTime;
        getYear(): number;
        getMonth(): number;
        getDay(): number;
        getHour(): number;
        getMinute(): number;
        getSecond(): number;
        getMillisecond(): number;
        addHours(hours: number): DateTime;
        addMinutes(minutes: number): DateTime;
        addSeconds(seconds: number): DateTime;
        addMilliseconds(milliseconds: number): DateTime;
    }
}
declare namespace fm.liveswitch {
    class DateTimeFormatInfo {
        getTypeString(): string;
        static getInvariantInfo(): DateTimeFormatInfo;
    }
}
declare namespace fm.liveswitch {
    enum DateTimeStyles {
        AssumeUniversal = 1,
        AdjustToUniversal = 2
    }
}
declare namespace fm.liveswitch {
    /**
    A dispatch queue interface.
    */
    interface IDispatchQueue<T> {
        destroy(): void;
        enqueue(item: T): void;
        getQueueCount(): number;
    }
}
declare namespace fm.liveswitch {
    class DispatchQueue<T> implements fm.liveswitch.IDispatchQueue<T> {
        getTypeString(): string;
        private _count;
        private _action;
        constructor(action: fm.liveswitch.IAction1<T>);
        getQueueCount(): number;
        destroy(): void;
        enqueue(item: T): void;
    }
}
declare namespace fm.liveswitch {
    class DomLogProvider extends fm.liveswitch.LogProvider {
        getTypeString(): string;
        private _container;
        constructor(container: HTMLElement, level?: fm.liveswitch.LogLevel);
        writeLine(text: string): void;
        doLog(logItem: fm.liveswitch.LogEvent): void;
    }
}
declare namespace fm.liveswitch {
    class Encoding {
        getTypeString(): string;
        static getAscii(): Encoding;
        static getUtf8(): Encoding;
        getString(bytes: Uint8Array, index?: number, count?: number): string;
        getBytes(str: string): Uint8Array;
        getByteCount(str: string): number;
    }
}
declare class fmliveswitchGlobalError extends Error {
}
declare namespace fm.liveswitch {
    class Exception extends fmliveswitchGlobalError {
        constructor(message?: string);
    }
}
declare namespace fm.liveswitch {
    /**
    Future base properties/methods.
    */
    abstract class FutureBase<T> {
        getTypeString(): string;
        /** @hidden */
        private _exception;
        /** @hidden */
        private _result;
        /** @hidden */
        private _state;
        constructor();
        /**
        Gets the exception if rejected.
        */
        getException(): fm.liveswitch.Exception;
        /**
        Gets the result if resolved.
        */
        getResult(): T;
        /**
        Gets the current state.
        */
        getState(): fm.liveswitch.FutureState;
        /**
        Sets the exception if rejected.
        */
        protected setException(value: fm.liveswitch.Exception): void;
        /**
        Sets the result if resolved.
        */
        protected setResult(value: T): void;
        /**
        Sets the current state.
        */
        protected setState(value: fm.liveswitch.FutureState): void;
    }
}
declare namespace fm.liveswitch {
    abstract class Future<T> extends fm.liveswitch.FutureBase<T> {
        getTypeString(): string;
        abstract fail(rejectAction: fm.liveswitch.IAction1<fm.liveswitch.Exception>): fm.liveswitch.Future<T>;
        abstract then<R>(resolve: fm.liveswitch.IAction1<T> | fm.liveswitch.IFunction1<T, fm.liveswitch.Future<R>>): fm.liveswitch.Future<R>;
        abstract then<R>(resolve: fm.liveswitch.IAction1<T> | fm.liveswitch.IFunction1<T, fm.liveswitch.Future<R>>, reject: fm.liveswitch.IAction1<fm.liveswitch.Exception>): fm.liveswitch.Future<R>;
    }
}
declare namespace fm.liveswitch {
    class Global {
        getTypeString(): string;
        static tryCast<T>(x: any, t: any): T;
        static tryCastArray(x: any): any[];
        static tryCastObject(x: any): Object;
        static tryCastString(x: any): string;
        static tryCastInt(x: any): number;
        static tryCastFloat(x: any): number;
        static toInt(x: number): number;
        static xor(x: boolean, y: boolean): boolean;
        static equals(x1: any, x2: any): boolean;
    }
}
declare namespace fm.liveswitch {
    class Guid {
        getTypeString(): string;
        static empty: Guid;
        private _guidString;
        constructor();
        constructor(guidString: string);
        equals(guid: Guid): boolean;
        toString(): string;
        static newGuid(): Guid;
        static equals(guid1: Guid, guid2: Guid): boolean;
    }
}
declare namespace fm.liveswitch {
    interface Hash<K, V> {
        [key: string]: V;
    }
}
declare namespace fm.liveswitch {
    /**
    A hash context.
    */
    abstract class HashContextBase {
        getTypeString(): string;
        /** @hidden */
        private _type;
        /**
        Initializes a new instance of the [[fm.liveswitch.hashContextBase]] class.
        @param type The type.
        */
        constructor(type: fm.liveswitch.HashType);
        /**
        Computes the hash for a given type.
        @param type The type.
        @param input The input.
        */
        static compute(type: fm.liveswitch.HashType, input: fm.liveswitch.DataBuffer): fm.liveswitch.DataBuffer;
        /**
        Computes the hash for a given type.
        @param type The type.
        @param inputString The input string.
        */
        static compute(type: fm.liveswitch.HashType, inputString: string): fm.liveswitch.DataBuffer;
        /**
        Computes the hash.
        @param input The input.
        */
        compute(input: fm.liveswitch.DataBuffer): fm.liveswitch.DataBuffer;
        /**
        Computes the hash.
        @param inputString The input.
        */
        compute(inputString: string): fm.liveswitch.DataBuffer;
        /**
        Destroys this instance.
        */
        destroy(): void;
        /**
        Computes the hash.
        @param input The input.
        */
        protected abstract doCompute(input: fm.liveswitch.DataBuffer): fm.liveswitch.DataBuffer;
        /**
        Destroys this instance.
        */
        protected abstract doDestroy(): void;
        /**
        Gets the type.
        */
        getType(): fm.liveswitch.HashType;
        /** @hidden */
        private setType;
    }
}
declare namespace fm.liveswitch {
    class HashContext extends fm.liveswitch.HashContextBase {
        getTypeString(): string;
        constructor(type: fm.liveswitch.HashType);
        doCompute(input: fm.liveswitch.DataBuffer): fm.liveswitch.DataBuffer;
        doDestroy(): void;
    }
}
declare namespace fm.liveswitch {
    class HashExtensions {
        getTypeString(): string;
        static getCount<T>(obj: fm.liveswitch.Hash<string, T>): number;
        static getKeys<T>(obj: fm.liveswitch.Hash<string, T>): string[];
        static getValues<T>(obj: fm.liveswitch.Hash<string, T>): T[];
        static tryGetValue<T>(obj: fm.liveswitch.Hash<any, T>, key: any, holder: fm.liveswitch.Holder<T>): boolean;
        static containsKey<T>(obj: fm.liveswitch.Hash<any, T>, key: any): boolean;
        static containsValue<T>(obj: fm.liveswitch.Hash<string, T>, value: T): boolean;
        static add<T>(obj: fm.liveswitch.Hash<string, T>, key: string, value: T): T;
        static remove<T>(obj: fm.liveswitch.Hash<string, T>, key: string): boolean;
        static clear<T>(obj: fm.liveswitch.Hash<string, T>): void;
    }
}
declare namespace fm.liveswitch {
    class HmacSha256 {
        private inner;
        private outer;
        blockSize: number;
        digestLength: number;
        private istate;
        private ostate;
        constructor(key: Uint8Array);
        reset(): this;
        clean(): void;
        update(data: Uint8Array): this;
        finish(out: Uint8Array): this;
        digest(): Uint8Array;
    }
}
declare namespace fm.liveswitch {
    class Holder<T> {
        getTypeString(): string;
        private _value;
        constructor(value: T);
        getValue(): T;
        setValue(value: T): void;
    }
}
declare namespace fm.liveswitch {
    interface HttpWebRequest {
    }
}
declare namespace fm.liveswitch {
    interface HttpWebRequestFailureArgs {
        message: string;
        local: boolean;
    }
}
declare namespace fm.liveswitch {
    interface HttpWebRequestSendOptions {
        sync: boolean;
        url: string;
        frameUrl: string;
        method: string;
        content: string;
        contentBinary: Uint8Array;
        headers: fm.liveswitch.Hash<string, string>;
        timeout: number;
        robustResponse: boolean;
        onRequestCreated?: fm.liveswitch.IFunction1<fm.liveswitch.HttpWebRequest, HttpWebRequestSendOptions>;
        onResponseReceived?: fm.liveswitch.IAction1<fm.liveswitch.HttpWebResponse>;
        onSuccess?: fm.liveswitch.IAction1<fm.liveswitch.HttpWebRequestSuccessArgs>;
        onFailure?: fm.liveswitch.IAction1<fm.liveswitch.HttpWebRequestFailureArgs>;
    }
}
declare namespace fm.liveswitch {
    interface HttpWebRequestSuccessArgs {
        content: string;
        contentBinary: Uint8Array;
        headers: fm.liveswitch.Hash<string, string>;
        statusCode: number;
    }
}
declare namespace fm.liveswitch {
    /**
    Base class that defines methods for transferring content over HTTP.
    */
    abstract class HttpTransfer {
        getTypeString(): string;
        /** @hidden */
        private static fm_liveswitch_HttpTransfer___log;
        /** @hidden */
        private static fm_liveswitch_HttpTransfer___onSendFinish;
        /** @hidden */
        private static fm_liveswitch_HttpTransfer___onSendStart;
        /** @hidden */
        private static fm_liveswitch_HttpTransfer___wildcardCharacters;
        /** @hidden */
        private static fm_liveswitch_HttpTransfer__onSendFinish;
        /** @hidden */
        private static fm_liveswitch_HttpTransfer__onSendStart;
        constructor();
        /**
        Adds a handler that is raised before an HTTP request is sent.
        */
        static addOnSendFinish(value: fm.liveswitch.IAction1<fm.liveswitch.HttpSendFinishArgs>): void;
        /**
        Adds a handler that is raised before an HTTP request is sent.
        */
        static addOnSendStart(value: fm.liveswitch.IAction1<fm.liveswitch.HttpSendStartArgs>): void;
        /**
        Escapes and adds a query parameter as a key/empty-value pair to a URL.
        @param url The URL with the query to which the key/value should be added.
        @param key The key of the query parameter to add.
        @return The original URL with the query parameter added.
        */
        static addQueryToUrl(url: string, key: string): string;
        /**
        Escapes and adds a query parameter as a key/value pair to a URL.
        @param url The URL with the query to which the key/value should be added.
        @param key The key of the query parameter to add.
        @param value The value of the query parameter to add.
        @return The original URL with the query parameter added.
        */
        static addQueryToUrl(url: string, key: string, value: string): string;
        /**
        Gets a random wildcard character.
        @return A random wildcard character.
        */
        static getRandomWildcardCharacter(): string;
        /**
        Gets the wildcard characters used to replace asterisks in ReplaceWildcards.
        */
        static getWildcardCharacters(): string;
        /**
        Removes a handler that is raised before an HTTP request is sent.
        */
        static removeOnSendFinish(value: fm.liveswitch.IAction1<fm.liveswitch.HttpSendFinishArgs>): void;
        /**
        Removes a handler that is raised before an HTTP request is sent.
        */
        static removeOnSendStart(value: fm.liveswitch.IAction1<fm.liveswitch.HttpSendStartArgs>): void;
        /**
        Replaces asterisks in URLs with characters from WildcardCharacters.
        @param url The URL with asterisks.
        */
        static replaceWildcards(url: string): string;
        /**
        Sets the wildcard characters used to replace asterisks in ReplaceWildcards.
        */
        static setWildcardCharacters(value: string): void;
        /** @hidden */
        private doSend;
        /** @hidden */
        private doSendAsync;
        /** @hidden */
        private finishRequest;
        /** @hidden */
        private raiseOnSendFinish;
        /** @hidden */
        private raiseOnSendStart;
        /**
        Sends a request synchronously.
        @param requestArgs The request parameters.
        @return The resulting response.
        */
        send(requestArgs: fm.liveswitch.HttpRequestArgs): fm.liveswitch.HttpResponseArgs;
        /**
        Sends a request asynchronously.
        @param requestArgs The request parameters.
        @param callback The callback to execute with the resulting response.
        */
        sendAsync(requestArgs: fm.liveswitch.HttpRequestArgs, callback: fm.liveswitch.IAction1<fm.liveswitch.HttpResponseArgs>): void;
        /** @hidden */
        private sendAsyncCallback;
        /**
        Sends binary content synchronously using the specified arguments.
        @param requestArgs The request arguments.
        @return The response arguments from the server.
        */
        abstract sendBinary(requestArgs: fm.liveswitch.HttpRequestArgs): fm.liveswitch.HttpResponseArgs;
        /**
        Sends binary content asynchronously using the specified arguments.
        @param requestArgs The request arguments.
        @param callback The callback to execute on success or failure.
        */
        abstract sendBinaryAsync(requestArgs: fm.liveswitch.HttpRequestArgs, callback: fm.liveswitch.IAction1<fm.liveswitch.HttpResponseArgs>): void;
        /**
        Sends text content synchronously using the specified arguments.
        @param requestArgs The request arguments.
        @return The response arguments from the server.
        */
        abstract sendText(requestArgs: fm.liveswitch.HttpRequestArgs): fm.liveswitch.HttpResponseArgs;
        /**
        Sends text content asynchronously using the specified arguments.
        @param requestArgs The request arguments.
        @param callback The callback to execute on success or failure.
        */
        abstract sendTextAsync(requestArgs: fm.liveswitch.HttpRequestArgs, callback: fm.liveswitch.IAction1<fm.liveswitch.HttpResponseArgs>): void;
        /**
        Releases any resources and shuts down.
        */
        abstract shutdown(): void;
        /** @hidden */
        private startRequest;
        /** @hidden */
        private static __fmliveswitchHttpTransferInitialized;
        /** @hidden */
        private static __fmliveswitchHttpTransferInitializing;
        /** @hidden */
        static fmliveswitchHttpTransferInitialize(): void;
    }
}
declare let fmliveswitchGlobalIsError: (obj: any) => boolean;
declare namespace fm.liveswitch {
    class Util {
        getTypeString(): string;
        private static _xdCache;
        private static _chars;
        private static _loadFunctions;
        private static _wildcard;
        private static _readyRun;
        private static _readyBound;
        private static _loaded;
        static isNumber(obj: any): boolean;
        static isString(obj: any): boolean;
        static isBoolean(obj: any): boolean;
        static isNull(obj: any): boolean;
        static isUndefined(obj: any): boolean;
        static isNullOrUndefined(obj: any): boolean;
        static isFunction(obj: any): boolean;
        static isArray(obj: any): boolean;
        static isUint8Array(obj: any): boolean;
        static isDate(obj: any): boolean;
        static isRegExp(obj: any): boolean;
        static isError(obj: any): boolean;
        static isObject(obj: any): boolean;
        static isObjectType(obj: any, typeString: string): boolean;
        static isArrayType(obj: any, typeString: string): boolean;
        static isPlainObject(obj: any): boolean;
        static canAttachProperties<T>(instance: T, obj: any): boolean;
        static attachProperties<T>(instance: T, obj: any): T;
        static isIE(): boolean;
        static isIE6(): boolean;
        static isIE7(): boolean;
        static isIE8(): boolean;
        static isIE9(): boolean;
        static isEdge(): boolean;
        static isChrome(): boolean;
        static isFirefox(): boolean;
        static isSafari9(): boolean;
        static isSafari10(): boolean;
        static isSafari11(): boolean;
        static isSafari12(): boolean;
        static isSafari12_1(): boolean;
        static isSafari(): boolean;
        static isOpera(): boolean;
        static isWindows(): boolean;
        static isAndroid(): boolean;
        static isBlackBerry(): boolean;
        static isiOS(): boolean;
        static isMobile(): boolean;
        static hasActiveX(checkFiltering?: boolean): boolean;
        static hasJava(): boolean;
        static getJavaVersion(): string;
        static isJavaWebStartInstalledActiveX(version: string): boolean;
        static isXD(url1: string, url2?: string): boolean;
        private static getHost;
        private static compareHost;
        private static getCurrentHost;
        private static parseUrl;
        static absolutizeUrl(url?: string): string;
        static wildcard(str: string): string;
        static getWildcard(): string;
        static randomChar(str: string): string;
        static observe(element: EventTarget, event: string, handler: Function): void;
        static unobserve(element: EventTarget, event: string, handler: Function): void;
        static observeAttr(element: EventTarget, handler: Function): void;
        static construct<T>(func: Function, args: IArguments): T;
        static extend(dest: any, src: any): any;
        static addOnLoad(fn: Function): void;
        static ready(): void;
        static bindReady(): void;
        private static __initialized;
        static initialize(): void;
    }
}
declare namespace fm.liveswitch {
    class HttpWebRequestTransfer extends fm.liveswitch.HttpTransfer {
        getTypeString(): string;
        private static _corsFailCache;
        private static _corsSuccessCache;
        private static _pmFailCache;
        private static _pmSuccessCache;
        private static _disableCors;
        private static _disablePostMessage;
        private static _disableJsonp;
        private static _forceJsonp;
        constructor();
        static getPlatformCode: () => string;
        static setDisableCors(disableCors: boolean): void;
        static getDisableCors(): boolean;
        static setDisablePostMessage(disablePostMessage: boolean): void;
        static getDisablePostMessage(): boolean;
        static setDisableJsonp(disableJsonp: boolean): void;
        static getDisableJsonp(): boolean;
        static setForceJsonp(forceJsonp: boolean): void;
        static getForceJsonp(): boolean;
        static canCors(): boolean;
        static canPostMessage(): boolean;
        sendTextAsync(requestArgs: fm.liveswitch.HttpRequestArgs, callback: fm.liveswitch.IAction1<fm.liveswitch.HttpResponseArgs>): void;
        sendText(requestArgs: fm.liveswitch.HttpRequestArgs): fm.liveswitch.HttpResponseArgs;
        sendBinaryAsync(requestArgs: fm.liveswitch.HttpRequestArgs, callback: fm.liveswitch.IAction1<fm.liveswitch.HttpResponseArgs>): void;
        sendBinary(requestArgs: fm.liveswitch.HttpRequestArgs): fm.liveswitch.HttpResponseArgs;
        process(requestArgs: fm.liveswitch.HttpRequestArgs, callback: fm.liveswitch.IAction1<fm.liveswitch.HttpResponseArgs>): fm.liveswitch.HttpResponseArgs;
        sendInternal(fn: fm.liveswitch.IAction1<fm.liveswitch.HttpWebRequestSendOptions>, cors: boolean, pm: boolean, requestArgs: fm.liveswitch.HttpRequestArgs, callback: fm.liveswitch.IAction1<fm.liveswitch.HttpResponseArgs>): fm.liveswitch.HttpResponseArgs;
        shutdown(): void;
    }
}
declare namespace fm.liveswitch {
    interface HttpWebResponse {
    }
}
declare namespace fm.liveswitch {
    interface IAction0 {
        (): void;
    }
}
declare namespace fm.liveswitch {
    interface IAction1<T> {
        (p: T): void;
    }
}
declare namespace fm.liveswitch {
    interface IAction2<T1, T2> {
        (p1: T1, p2: T2): void;
    }
}
declare namespace fm.liveswitch {
    interface IAction3<T1, T2, T3> {
        (p1: T1, p2: T2, p3: T3): void;
    }
}
declare namespace fm.liveswitch {
    interface IAction4<T1, T2, T3, T4> {
        (p1: T1, p2: T2, p3: T3, p4: T4): void;
    }
}
declare namespace fm.liveswitch {
    interface IAction5<T1, T2, T3, T4, T5> {
        (p1: T1, p2: T2, p3: T3, p4: T4, p5: T5): void;
    }
}
declare namespace fm.liveswitch {
    interface IAction6<T1, T2, T3, T4, T5, T6> {
        (p1: T1, p2: T2, p3: T3, p4: T4, p5: T5, p6: T6): void;
    }
}
declare namespace fm.liveswitch {
    interface IFunction0<R> {
        (): R;
    }
}
declare namespace fm.liveswitch {
    interface IFunction1<T, R> {
        (p: T): R;
    }
}
declare namespace fm.liveswitch {
    interface IFunction2<T1, T2, R> {
        (p1: T1, p2: T2): R;
    }
}
declare namespace fm.liveswitch {
    interface IFunction3<T1, T2, T3, R> {
        (p1: T1, p2: T2, p3: T3): R;
    }
}
declare namespace fm.liveswitch {
    interface IFunction4<T1, T2, T3, T4, R> {
        (p1: T1, p2: T2, p3: T3, p4: T4): R;
    }
}
declare namespace fm.liveswitch {
    interface IFunction5<T1, T2, T3, T4, T5, R> {
        (p1: T1, p2: T2, p3: T3, p4: T4, p5: T5): R;
    }
}
declare namespace fm.liveswitch {
    interface IFunction6<T1, T2, T3, T4, T5, T6, R> {
        (p1: T1, p2: T2, p3: T3, p4: T4, p5: T5, p6: T6): R;
    }
}
declare namespace fm.liveswitch {
    class InternalConcurrentDictionary<TKey, TValue> {
        getTypeString(): string;
        private __dict;
        private __hashFunction;
        constructor(hashCallback: fm.liveswitch.IFunction1<TKey, string>);
        getIsEmpty(): boolean;
        getKeys(): TKey[];
        getValues(): TValue[];
        getCount(): number;
        containsKey(key: TKey): boolean;
        getOrAdd(key: TKey, valueFactory: fm.liveswitch.IFunction1<TKey, TValue>): TValue;
        addOrUpdate(key: TKey, addValue: TValue, updateValueFactory: fm.liveswitch.IFunction2<TKey, TValue, TValue>): TValue;
        tryAdd(key: TKey, value: TValue): boolean;
        tryGetValue(key: TKey, holder: fm.liveswitch.Holder<TValue>): boolean;
        tryRemove(key: TKey, value: fm.liveswitch.Holder<TValue>): boolean;
        tryUpdate(key: TKey, newValue: TValue, comparisonValue: TValue): boolean;
        clear(): void;
    }
}
declare namespace fm.liveswitch {
    /**
     <div>
     Provides Json serialize and deserialize methods for all browsers. It will also
     turn strings with form <code>"/Date(xxxxxxxxxx-xxxx)"</code> (Microsoft date serialization format) into actual dates.
     </div>
     */
    class Json {
        getTypeString(): string;
        static useMicrosoftDateFormat: boolean;
        private static _dateRegex;
        private static _reviver;
        private static _buildReviver;
        static deserialize(text: string, reviver?: (key: any, value: any) => any): any;
        static serialize(value: any): string;
        static serialize(value: any, replacer: (key: string, value: any) => any): string;
        static serialize(value: any, replacer: any[]): string;
        static serialize(value: any, replacer: (key: string, value: any) => any, space: string | number): string;
        static serialize(value: any, replacer: any[], space: string | number): string;
    }
}
declare namespace fm.liveswitch {
    class Jsonp {
        getTypeString(): string;
        static maxUrlLength: number;
        private static _scriptFrame;
        private static _scriptFrameLoaded;
        private static _callbackCount;
        private static _cb;
        private static _pastScriptFrames;
        private static _scriptFrameDestroyer;
        static getNextCallback(options: fm.liveswitch.JsonpSendOptions): string;
        private static failureHandler;
        static send(options: fm.liveswitch.JsonpSendOptions): void;
        private static cleanup;
        private static callbackExists;
    }
}
declare namespace fm.liveswitch {
    interface JsonpSendOptions extends fm.liveswitch.HttpWebRequestSendOptions {
        canSegmentJsonArray: boolean;
        callbackParameterName: string;
        contentParameterName: string;
        methodParameterName: string;
        headersParameterName: string;
        statusCodeParameterName: string;
        cacheBusterParameterName: string;
        useFrame: boolean;
    }
}
declare namespace fm.liveswitch {
    /**
    A message authentication code (MAC) context.
    */
    abstract class MacContextBase {
        getTypeString(): string;
        /** @hidden */
        private _type;
        /**
        Initializes a new instance of the [[fm.liveswitch.macContextBase]] class.
        @param type The type.
        */
        constructor(type: fm.liveswitch.MacType);
        /**
        Computes the message authentication code (MAC) for a given type.
        @param type The type.
        @param key The key.
        @param input The input.
        */
        static compute(type: fm.liveswitch.MacType, key: fm.liveswitch.DataBuffer, input: fm.liveswitch.DataBuffer): fm.liveswitch.DataBuffer;
        /**
        Computes the message authentication code (MAC).
        @param input The input.
        */
        compute(input: fm.liveswitch.DataBuffer): fm.liveswitch.DataBuffer;
        /**
        Destroys this instance.
        */
        destroy(): void;
        /**
        Computes the message authentication code (MAC).
        @param input The input.
        */
        protected abstract doCompute(input: fm.liveswitch.DataBuffer): fm.liveswitch.DataBuffer;
        /**
        Destroys this instance.
        */
        protected abstract doDestroy(): void;
        /**
        Gets the type.
        */
        getType(): fm.liveswitch.MacType;
        /** @hidden */
        private setType;
    }
}
declare namespace fm.liveswitch {
    class MacContext extends fm.liveswitch.MacContextBase {
        getTypeString(): string;
        private _key;
        constructor(type: fm.liveswitch.MacType, key: fm.liveswitch.DataBuffer);
        doCompute(input: fm.liveswitch.DataBuffer): fm.liveswitch.DataBuffer;
        doDestroy(): void;
    }
}
declare namespace fm.liveswitch {
    class ManagedStopwatch {
        getTypeString(): string;
        static dispatch(action: fm.liveswitch.IAction0): void;
        private startTime;
        private stopTime;
        static getTimestamp(): number;
        getElapsedTicks(): number;
        getElapsedMilliseconds(): number;
        start(): void;
        stop(): void;
        restart(): void;
    }
}
declare namespace fm.liveswitch {
    class ManagedThread {
        getTypeString(): string;
        static getCurrentThreadId(): number;
        static dispatch(action: fm.liveswitch.IAction0): void;
    }
}
declare namespace fm.liveswitch {
    class MathAssistant {
        getTypeString(): string;
        static getPi(): number;
        static getE(): number;
        static abs(val: number): number;
        static acos(val: number): number;
        static asin(val: number): number;
        static atan(val: number): number;
        static atan2(y: number, x: number): number;
        static ceil(val: number): number;
        static cos(val: number): number;
        static cosh(val: number): number;
        static exp(val: number): number;
        static floor(val: number): number;
        static log(val: number): number;
        static log10(val: number): number;
        static max(val1: number, val2: number): number;
        static min(val1: number, val2: number): number;
        static pow(x: number, y: number): number;
        static round(value: number): number;
        static sin(val: number): number;
        static sinh(val: number): number;
        static sqrt(val: number): number;
        static tan(val: number): number;
        static tanh(val: number): number;
    }
}
declare namespace fm.liveswitch {
    class NameValueCollection {
        getTypeString(): string;
        private _value;
        constructor(value?: fm.liveswitch.Hash<string, string>);
        source(): fm.liveswitch.Hash<string, string>;
        get(name: string): string;
        set(name: string, value: string): void;
        getCount(): number;
        toHash(): fm.liveswitch.Hash<string, string>;
        getKeys(): string[];
        getAllKeys(): string[];
    }
}
declare namespace fm.liveswitch {
    class NumberExtensions {
        getTypeString(): string;
        static toString(value: number, formatOrCultureInfo?: string | fm.liveswitch.CultureInfo): string;
    }
}
declare namespace fm.liveswitch {
    class ObjectExtensions {
        getTypeString(): string;
        static getType(obj: any): fm.liveswitch.Type;
        static getHashCode(obj: any): number;
    }
}
declare namespace fm.liveswitch {
    class ParseAssistant {
        getTypeString(): string;
        static parseByteValue(s: string): number;
        static parseShortValue(s: string): number;
        static parseIntegerValue(s: string): number;
        static parseLongValue(s: string): number;
        static parseFloatValue(s: string): number;
        static parseDoubleValue(s: string): number;
        static parseDecimalValue(s: string): number;
        static parseBooleanValue(s: string): boolean;
        static parseGuidValue(s: string): fm.liveswitch.Guid;
        static tryParseByteValue(s: string, h: fm.liveswitch.Holder<number>): boolean;
        static tryParseShortValue(s: string, h: fm.liveswitch.Holder<number>): boolean;
        static tryParseIntegerValue(s: string, h: fm.liveswitch.Holder<number>): boolean;
        static tryParseLongValue(s: string, h: fm.liveswitch.Holder<number>): boolean;
        static tryParseFloatValue(s: string, h: fm.liveswitch.Holder<number>): boolean;
        static tryParseDoubleValue(s: string, h: fm.liveswitch.Holder<number>): boolean;
        static tryParseDecimalValue(s: string, h: fm.liveswitch.Holder<number>): boolean;
        static tryParseBooleanValue(s: string, h: fm.liveswitch.Holder<boolean>): boolean;
        static tryParseGuidValue(s: string, h: fm.liveswitch.Holder<fm.liveswitch.Guid>): boolean;
    }
}
declare namespace fm.liveswitch {
    /**
    Platform-specific methods.
    */
    interface IPlatform {
        getArchitecture(): fm.liveswitch.Architecture;
        getCoreCount(): number;
        getCryptoLibrary(): fm.liveswitch.CryptoLibrary;
        getDirectorySeparator(): string;
        getIsLittleEndian(): boolean;
        getIsMobile(): boolean;
        getMachineName(): string;
        getOperatingSystem(): fm.liveswitch.OperatingSystem;
        getOperatingSystemVersion(): string;
        getPhysicalMemory(): number;
        getProcessId(): number;
        getSourceLanguage(): fm.liveswitch.SourceLanguage;
        getUseFipsAlgorithms(): boolean;
        setCryptoLibrary(value: fm.liveswitch.CryptoLibrary): void;
        setIsMobile(value: boolean): void;
        setUseFipsAlgorithms(value: boolean): void;
    }
}
declare namespace fm.liveswitch {
    class Platform implements fm.liveswitch.IPlatform {
        private static instance;
        static getInstance(): fm.liveswitch.IPlatform;
        constructor();
        private littleEndianChecked;
        private isLittleEndian;
        private isMobile;
        private useFipsAlgorithms;
        getIsMobile(): boolean;
        setIsMobile(isMobile: boolean): void;
        getIsLittleEndian(): boolean;
        getOperatingSystem(): fm.liveswitch.OperatingSystem;
        getOperatingSystemVersion(): string;
        getArchitecture(): fm.liveswitch.Architecture;
        getSourceLanguage(): fm.liveswitch.SourceLanguage;
        getCoreCount(): number;
        getPhysicalMemory(): number;
        getMachineName(): string;
        getDirectorySeparator(): string;
        getProcessId(): number;
        getUseFipsAlgorithms(): boolean;
        setUseFipsAlgorithms(useFipsAlgorithms: boolean): void;
        getCryptoLibrary(): fm.liveswitch.CryptoLibrary;
        setCryptoLibrary(cryptoLibrary: fm.liveswitch.CryptoLibrary): void;
    }
}
declare namespace fm.liveswitch {
    class Xhr {
        getTypeString(): string;
        private static _count;
        private static _current;
        private static _disableBinary;
        private static _defaultWithCredentials;
        static setDisableBinary(disableBinary: boolean): void;
        static getDisableBinary(): boolean;
        static setDefaultWithCredentials(defaultWithCredentials: boolean): void;
        static getDefaultWithCredentials(): boolean;
        private static failureHandler;
        private static successHandler;
        private static handler;
        static send(options: fm.liveswitch.XhrSendOptions): boolean;
        private static __initialized;
        static initialize(): void;
    }
}
declare namespace fm.liveswitch {
    class PostMessage {
        getTypeString(): string;
        private static _cache;
        private static _optionsCounter;
        private static _optionsCache;
        private static getOrigin;
        private static createFrame;
        static send(options: fm.liveswitch.PostMessageSendOptions): void;
        private static listen;
    }
}
declare namespace fm.liveswitch {
    interface PostMessageSendOptions extends fm.liveswitch.XhrSendOptions {
        id: number;
    }
}
declare namespace fm.liveswitch {
    /**
    Promise base properties/methods.
    */
    abstract class PromiseBase<T> extends fm.liveswitch.Future<T> implements fm.liveswitch.IPromise {
        getTypeString(): string;
        /** @hidden */
        private __id;
        /** @hidden */
        private __pendingPromisesToReject;
        /** @hidden */
        private __pendingPromisesToResolve;
        /** @hidden */
        private __pendingRejects;
        /** @hidden */
        private __pendingResolves;
        /** @hidden */
        private __stateLock;
        /**
        Initializes a new instance of the [[fm.liveswitch.promiseBase]] class.
        */
        constructor();
        /**
        Returns a promise that resolves when all passed in promises resolve.
        @param promises The promises to check.
        */
        static all<R extends Object>(promises: fm.liveswitch.Future<R>[]): fm.liveswitch.Future<R>;
        /**
        Creates a promise and rejects it immediately.
        @param ex The exception.
        */
        static rejectNow<R extends Object>(ex: fm.liveswitch.Exception): fm.liveswitch.Future<R>;
        /**
        Creates a promise and resolves it immediately using a null result value.
        */
        static resolveNow(): fm.liveswitch.Future<Object>;
        /**
        Creates a promise and resolves it immediately using the given result value.
        @param result The result.
        */
        static resolveNow<R extends Object>(result: R): fm.liveswitch.Future<R>;
        /**
        Creates a promise and resolves it using the result from a callback function, or rejects it if an exception is thrown.
        @param callback The callback function.
        */
        static wrapPromise<R extends Object>(callback: fm.liveswitch.IFunction0<fm.liveswitch.Future<R>>): fm.liveswitch.Future<R>;
        /** @hidden */
        private addReject;
        /** @hidden */
        private addResolve;
        /**
        Casts the result and resolves the promise. Will throw an exception if the cast fails.
        @param result The result.
        */
        castAndResolve(result: Object): boolean;
        /**
        Internal DoAll.
        */
        protected doAll<R extends Object>(promises: fm.liveswitch.Future<R>[], counter: fm.liveswitch.AtomicInteger): void;
        /** @hidden */
        private doRejectAsync;
        /** @hidden */
        private doResolveAsync;
        /**
        Gets the identifier of this promise.
        */
        getId(): string;
        /**
        Processes the specified promise.
        @param promise The promise.
        @param resolve The resolve.
        @param reject The reject.
        */
        protected process(promise: fm.liveswitch.IPromise, resolve: fm.liveswitch.IAction1<T>, reject: fm.liveswitch.IAction1<fm.liveswitch.Exception>): void;
        /** @hidden */
        private raiseReject;
        /** @hidden */
        private raiseRejects;
        /** @hidden */
        private raiseResolve;
        /** @hidden */
        private raiseResolves;
        /**
        Rejects the promise.
        @param exception The exception.
        */
        reject(exception: fm.liveswitch.Exception): boolean;
        /**
        Rejects the promise asynchronously.
        @param exception The exception.
        */
        rejectAsync(exception: fm.liveswitch.Exception): fm.liveswitch.Future<Object>;
        /** @hidden */
        private reset;
        /**
        Resolves the promise.
        @param result The result.
        */
        resolve(result: T): boolean;
        /**
        Resolves the promise asynchronously.
        @param result The result.
        */
        resolveAsync(result: T): fm.liveswitch.Future<Object>;
    }
}
declare namespace fm.liveswitch {
    class Promise<T> extends fm.liveswitch.PromiseBase<T> {
        getTypeString(): string;
        then<R>(resolve: fm.liveswitch.IFunction1<T, R | fm.liveswitch.Future<R>>, reject?: fm.liveswitch.IAction1<fm.liveswitch.Exception>): fm.liveswitch.Future<R>;
        fail(reject?: fm.liveswitch.IAction1<fm.liveswitch.Exception>): fm.liveswitch.Future<T>;
        static wrap(callbackAction: fm.liveswitch.IAction0): fm.liveswitch.Future<Object>;
        static wrap<R extends Object>(callbackFunction: fm.liveswitch.IFunction0<R>): fm.liveswitch.Future<R>;
        static wrapAsync(callbackAction: fm.liveswitch.IAction0): fm.liveswitch.Future<Object>;
        static wrapAsync<R extends Object>(callbackFunction: fm.liveswitch.IFunction0<R>): fm.liveswitch.Future<R>;
    }
}
declare namespace fm.liveswitch {
    class Randomizer {
        getTypeString(): string;
        private static _randomCharset;
        next(): number;
        next(maxValue: number): number;
        next(minValue: number, maxValue: number): number;
        nextDouble(): number;
        nextBytes(buffer: Uint8Array): void;
        randomString(size: number): string;
    }
}
declare namespace fm.liveswitch {
    class Regex {
        getTypeString(): string;
        private pattern;
        constructor(pattern: string);
        static isMatch(input: string, pattern: string): boolean;
        isMatch(input: string): boolean;
    }
}
declare namespace fm.liveswitch {
    class Sha256 {
        digestLength: number;
        blockSize: number;
        private state;
        private temp;
        private buffer;
        private bufferLength;
        private bytesHashed;
        finished: boolean;
        constructor();
        reset(): this;
        clean(): void;
        update(data: Uint8Array, dataLength?: number): this;
        finish(out: Uint8Array): this;
        digest(): Uint8Array;
        _saveState(out: Uint32Array): void;
        _restoreState(from: Uint32Array, bytesHashed: number): void;
    }
}
declare namespace fm.liveswitch {
}
declare namespace fm.liveswitch {
    class Stack<T> {
        getTypeString(): string;
        private _list;
        private _depth;
        constructor(depth?: number);
        push(o: T): void;
        pop(): T;
        peek(): T;
        getCount(): number;
    }
}
declare namespace fm.liveswitch {
    class StringBuilder {
        getTypeString(): string;
        private _value;
        constructor(value?: string);
        append(s: string, startIndex?: number, count?: number): StringBuilder;
        toString(): string;
        getLength(): number;
        remove(startIndex: number, length: number): StringBuilder;
    }
}
declare namespace fm.liveswitch {
    enum StringComparison {
        CurrentCulture = 0,
        CurrentCultureIgnoreCase = 1,
        InvariantCulture = 2,
        InvariantCultureIgnoreCase = 3,
        Ordinal = 4,
        OrdinalIgnoreCase = 5
    }
}
declare namespace fm.liveswitch {
    class StringExtensions {
        getTypeString(): string;
        static empty: string;
        static nullCoalesce(value1: string, value2: string): string;
        static toString(s: string): string;
        static trim(s: string): string;
        static trimEnd(s: string, chars: number[]): string;
        static trimStart(s: string, chars: number[]): string;
        static replace(s: string, search: string, replace: string): string;
        static concat(...strings: any[]): string;
        static contains(str: string, s: string): boolean;
        static join(separator: string, ...array: any[]): string;
        static split(s: string, chars: number[]): string[];
        static isNullOrEmpty(s: string): boolean;
        static isEqual(str: string, s: string, stringComparison?: fm.liveswitch.StringComparison): boolean;
        static indexOf(str: string, s: string, stringComparison?: fm.liveswitch.StringComparison): number;
        static lastIndexOf(str: string, s: string, stringComparison?: fm.liveswitch.StringComparison): number;
        static startsWith(str: string, s: string, stringComparison?: fm.liveswitch.StringComparison): boolean;
        static endsWith(str: string, s: string, stringComparison?: fm.liveswitch.StringComparison): boolean;
        static compareTo(s1: string, s2: string): number;
        static format(format: string, ...args: any[]): string;
        static toLower(str: string): string;
        static toUpper(str: string): string;
        static getLength(str: string): number;
        static getChars(str: string): string[];
        static substring(str: string, startIndex: number, length: number): string;
        static getHashCode(str: string): number;
    }
}
declare namespace fm.liveswitch {
    /**
    A thread-safe class for running timeouts on asynchronous methods.
    */
    interface ITimeoutTimer {
        start(timeout: number): void;
        stop(): boolean;
    }
}
declare namespace fm.liveswitch {
    class TimeoutTimer implements fm.liveswitch.ITimeoutTimer {
        getTypeString(): string;
        private _timer;
        private _callback;
        private _state;
        private _currentTimeout;
        constructor(callback: fm.liveswitch.IAction1<any>, state: any);
        start(timeout: number): void;
        stop(): boolean;
    }
}
declare namespace fm.liveswitch {
    class TimeSpan {
        private _hours;
        private _minutes;
        private _seconds;
        private _milliseconds;
        constructor(ticks: number);
        constructor(hours: number, minutes: number, seconds: number);
        getTotalSeconds(): number;
        getTotalMilliseconds(): number;
    }
}
declare namespace fm.liveswitch {
    class Type {
        getTypeString(): string;
        private _typeString;
        constructor(typeString: string);
        getFullName(): string;
        getBaseType(): Type;
    }
}
declare namespace fm.liveswitch {
    class Uri {
        getTypeString(): string;
        private _uriString;
        constructor(uriString: string);
        toString(): string;
        static escapeDataString(s: string): string;
    }
}
declare namespace fm.liveswitch {
    /**
    WebSocket base properties/methods.
    */
    class WebSocketBase {
        getTypeString(): string;
        /** @hidden */
        private static fm_liveswitch_WebSocketBase___log;
        constructor();
        /**
        Raises the close complete callback.
        @param closeArgs The close arguments.
        @param statusCode The status code.
        @param reason The reason.
        */
        protected raiseCloseComplete(closeArgs: fm.liveswitch.WebSocketCloseArgs, statusCode: fm.liveswitch.WebSocketStatusCode, reason: string): void;
        /**
        Raises the open failure callback.
        @param openArgs The open arguments.
        @param statusCode The status code.
        @param exception The exception.
        */
        protected raiseOpenFailure(openArgs: fm.liveswitch.WebSocketOpenArgs, statusCode: fm.liveswitch.WebSocketStatusCode, exception: fm.liveswitch.Exception): void;
        /**
        Raises the open success callback.
        @param openArgs The open arguments.
        */
        protected raiseOpenSuccess(openArgs: fm.liveswitch.WebSocketOpenArgs): void;
        /**
        Raises the receive callback.
        @param openArgs The open arguments.
        @param textMessage The text message.
        @param binaryMessage The binary message.
        */
        protected raiseReceive(openArgs: fm.liveswitch.WebSocketOpenArgs, textMessage: string, binaryMessage: Uint8Array): void;
        /**
        Raises the stream failure callback.
        @param openArgs The open arguments.
        @param statusCode The status code.
        @param exception The exception.
        */
        protected raiseStreamFailure(openArgs: fm.liveswitch.WebSocketOpenArgs, statusCode: fm.liveswitch.WebSocketStatusCode, exception: fm.liveswitch.Exception): void;
        /** @hidden */
        private static __fmliveswitchWebSocketBaseInitialized;
        /** @hidden */
        private static __fmliveswitchWebSocketBaseInitializing;
        /** @hidden */
        static fmliveswitchWebSocketBaseInitialize(): void;
    }
}
declare namespace fm.liveswitch {
    class WebSocket extends fm.liveswitch.WebSocketBase implements fm.liveswitch.IWebSocket {
        getTypeString(): string;
        private static _disableBinary;
        private _requestUrl;
        private _webSocket;
        private _protocol;
        private _onRequestCreated;
        private _onResponseReceived;
        private _opening;
        private _closing;
        private _aborting;
        private _openArgs;
        private _sendArgs;
        private _timer;
        private _raisedStreamFailure;
        private _raisedOpenFailure;
        static getExists(): boolean;
        static setDisableBinary(disableBinary: boolean): void;
        static getDisableBinary(): boolean;
        getSecure(): boolean;
        constructor(requestUrl: string, protocol?: string);
        getBufferedAmount(): number;
        getIsOpen(): boolean;
        open(args: fm.liveswitch.WebSocketOpenArgs): void;
        private onOpen;
        private onError;
        private onClose;
        private processOnClose;
        private onMessage;
        send(args: fm.liveswitch.WebSocketSendArgs): void;
        close(): void;
        close(args: fm.liveswitch.WebSocketCloseArgs): void;
        private raiseOnRequestCreated;
        private raiseOnResponseReceived;
    }
}
declare namespace fm.liveswitch {
    interface XhrSendOptions extends fm.liveswitch.HttpWebRequestSendOptions {
        abortOnUnload?: boolean;
        cacheBusterParameterName?: string;
    }
}
declare namespace fm.liveswitch {
    /**
    Base definition for classes that allow serialization to/from JSON.
    */
    abstract class Serializable {
        getTypeString(): string;
        /** @hidden */
        private __serialized;
        /** @hidden */
        private _isDirty;
        /** @hidden */
        private _isSerialized;
        private fmliveswitchSerializableInit;
        /**
        Initializes a new instance of the [[fm.liveswitch.serializable]] class.
        */
        constructor();
        /** @hidden */
        getIsDirty(): boolean;
        /** @hidden */
        getIsSerialized(): boolean;
        /** @hidden */
        getSerialized(): string;
        /** @hidden */
        setIsDirty(value: boolean): void;
        /** @hidden */
        setIsSerialized(value: boolean): void;
        /** @hidden */
        setSerialized(value: string): void;
    }
}
declare namespace fm.liveswitch {
    /**
    Supplies class instances with a key-value mapping to support dynamic property storage.
    */
    abstract class Dynamic extends fm.liveswitch.Serializable {
        getTypeString(): string;
        /** @hidden */
        private __dynamicProperties;
        /** @hidden */
        private __dynamicPropertiesLock;
        constructor();
        /**
        Gets the dynamic properties on this instance.
        */
        getDynamicProperties(): fm.liveswitch.Hash<string, Object>;
        /**
        Gets a property value from the local cache.
        @param key The property key. This key is used internally only, but should be namespaced to avoid conflict with third-party extensions.
        @return The stored value, if found; otherwise null.
        */
        getDynamicValue(key: string): Object;
        /** @hidden */
        setDynamicProperties(value: fm.liveswitch.Hash<string, Object>): void;
        /**
        Sets a property value in the local cache.
        @param key The property key. This key is used internally only, but should be namespaced to avoid conflict with third-party extensions.
        @param value The property value. This can be any object that needs to be stored for future use.
        */
        setDynamicValue(key: string, value: Object): void;
        /** @hidden */
        private tryInitDynamicProperties;
        /**
        Unsets a property value in the local cache.
        @param key The property key. This key is used internally only, but should be namespaced to avoid conflict with third-party extensions.
        @return `true` if the value was removed; otherwise, `false`.
        */
        unsetDynamicValue(key: string): boolean;
    }
}
declare namespace fm.liveswitch {
    abstract class Stream extends fm.liveswitch.Dynamic implements fm.liveswitch.IExternalStream {
        getTypeString(): string;
        getState(): fm.liveswitch.StreamState;
        addOnStateChange(value: fm.liveswitch.IAction0): void;
        removeOnStateChange(value: fm.liveswitch.IAction0): void;
        changeDirection(newDirection: fm.liveswitch.StreamDirection): fm.liveswitch.Error;
        getDirection(): fm.liveswitch.StreamDirection;
        getLocalReceive(): boolean;
        setLocalReceive(receiveEnabled: boolean): void;
        getLocalSend(): boolean;
        setLocalSend(sendEnabled: boolean): void;
        getRemoteReceive(): boolean;
        getRemoteSend(): boolean;
        getRemoteDirection(): fm.liveswitch.StreamDirection;
        getId(): string;
        getExternalId(): string;
        getLabel(): string;
        getLocalDirection(): fm.liveswitch.StreamDirection;
        getMediaDescriptionId(): string;
        getTag(): string;
        getType(): fm.liveswitch.StreamType;
        setExternalId(value: string): void;
        setLocalDirection(value: fm.liveswitch.StreamDirection): void;
        setTag(value: string): void;
        addOnDirectionChange(value: fm.liveswitch.IAction0): void;
        removeOnDirectionChange(value: fm.liveswitch.IAction0): void;
        getTransportInfo(): fm.liveswitch.TransportInfo;
    }
}
declare namespace fm.liveswitch {
    abstract class MediaStream<TTrack> extends fm.liveswitch.Stream implements fm.liveswitch.IMediaStream, fm.liveswitch.IExternalMediaStream {
        getTypeString(): string;
        getLocalTrack(): TTrack;
        getRemoteTrack(): TTrack;
        getLocalBandwidth(): number;
        getLocalMuted(): boolean;
        setLocalMuted(value: boolean): void;
        getRemoteMuted(): boolean;
        setRemoteMuted(value: boolean): void;
        getMuted(): boolean;
        getInputMuted(): boolean;
        getOutputMuted(): boolean;
        getRemoteBandwidth(): number;
        setLocalBandwidth(value: number): void;
        setMuted(value: boolean): void;
        setInputMuted(value: boolean): void;
        setOutputMuted(value: boolean): void;
        getPreferredCodecs(): string[];
        setPreferredCodecs(names: string[]): void;
        getCodecDisabled(name: string): boolean;
        setCodecDisabled(name: string, disabled: boolean): void;
        getRemoteEncoding(): fm.liveswitch.EncodingInfo;
        setRemoteEncoding(value: fm.liveswitch.EncodingInfo): void;
        getSimulcastMode(): fm.liveswitch.SimulcastMode;
        setSimulcastMode(value: fm.liveswitch.SimulcastMode): void;
        getInfo(): fm.liveswitch.MediaStreamInfo;
        constructor(localTrack: TTrack, remoteTrack: TTrack);
        getControlTransportInfo(): fm.liveswitch.TransportInfo;
        getLocalCanonicalName(): string;
        getRemoteCanonicalName(): string;
        addOnLocalEncodingDisabled(value: fm.liveswitch.IAction1<fm.liveswitch.EncodingInfo>): void;
        addOnLocalEncodingEnabled(value: fm.liveswitch.IAction1<fm.liveswitch.EncodingInfo>): void;
        removeOnLocalEncodingDisabled(value: fm.liveswitch.IAction1<fm.liveswitch.EncodingInfo>): void;
        removeOnLocalEncodingEnabled(value: fm.liveswitch.IAction1<fm.liveswitch.EncodingInfo>): void;
        addOnDiscardBitrateRequest(value: fm.liveswitch.IAction1<fm.liveswitch.BitrateRequest>): void;
        removeOnDiscardBitrateRequest(value: fm.liveswitch.IAction1<fm.liveswitch.BitrateRequest>): void;
        raiseBitrateRequest(bitrateRequest: fm.liveswitch.BitrateRequest): boolean;
        addOnDiscardBitrateNotification(value: fm.liveswitch.IAction1<fm.liveswitch.BitrateNotification>): void;
        removeOnDiscardBitrateNotification(value: fm.liveswitch.IAction1<fm.liveswitch.BitrateNotification>): void;
        raiseBitrateNotification(bitrateNotification: fm.liveswitch.BitrateNotification): boolean;
        getMaxSendBitrate(): number;
        setMaxSendBitrate(value: number): void;
        getMaxReceiveBitrate(): number;
        setMaxReceiveBitrate(value: number): void;
    }
}
declare namespace fm.liveswitch {
    class AudioStream extends fm.liveswitch.MediaStream<fm.liveswitch.AudioTrack> implements fm.liveswitch.IAudioStream, fm.liveswitch.IExternalAudioStream {
        getTypeString(): string;
        getLocalMedia(): fm.liveswitch.LocalMedia;
        getRemoteMedia(): fm.liveswitch.RemoteMedia;
        constructor(localTrack: fm.liveswitch.AudioTrack);
        constructor(localTrack: fm.liveswitch.AudioTrack, remoteTrack: fm.liveswitch.AudioTrack);
        constructor(localMedia: fm.liveswitch.LocalMedia);
        constructor(localMedia: fm.liveswitch.LocalMedia, remoteMedia: fm.liveswitch.RemoteMedia);
        constructor(remoteMedia: fm.liveswitch.RemoteMedia);
        addOnReceiveDtmfTone(value: fm.liveswitch.IAction1<fm.liveswitch.dtmf.Tone>): void;
        addOnReceiveDtmfToneChange(value: fm.liveswitch.IAction1<fm.liveswitch.dtmf.Tone>): void;
        addOnSendDtmfTone(value: fm.liveswitch.IAction1<fm.liveswitch.dtmf.Tone>): void;
        addOnSendDtmfToneChange(value: fm.liveswitch.IAction1<fm.liveswitch.dtmf.Tone>): void;
        insertDtmfTone(dtmfTone: fm.liveswitch.dtmf.Tone): boolean;
        insertDtmfTones(dtmfTones: fm.liveswitch.dtmf.Tone[]): boolean;
        removeOnReceiveDtmfTone(value: fm.liveswitch.IAction1<fm.liveswitch.dtmf.Tone>): void;
        removeOnReceiveDtmfToneChange(value: fm.liveswitch.IAction1<fm.liveswitch.dtmf.Tone>): void;
        removeOnSendDtmfTone(value: fm.liveswitch.IAction1<fm.liveswitch.dtmf.Tone>): void;
        removeOnSendDtmfToneChange(value: fm.liveswitch.IAction1<fm.liveswitch.dtmf.Tone>): void;
        getOpusDisabled(): boolean;
        getG722Disabled(): boolean;
        getPcmuDisabled(): boolean;
        getPcmaDisabled(): boolean;
        setOpusDisabled(value: boolean): void;
        setG722Disabled(value: boolean): void;
        setPcmuDisabled(value: boolean): void;
        setPcmaDisabled(value: boolean): void;
        addOnDiscardOutboundDtmfTones(value: fm.liveswitch.IAction1<fm.liveswitch.dtmf.Tone[]>): void;
        removeOnDiscardOutboundDtmfTones(value: fm.liveswitch.IAction1<fm.liveswitch.dtmf.Tone[]>): void;
    }
}
declare namespace fm.liveswitch {
    abstract class MediaTrack extends fm.liveswitch.Dynamic implements fm.liveswitch.IMediaTrack, fm.liveswitch.IExternalMediaTrack {
        getTypeString(): string;
        getMedia(): fm.liveswitch.Media;
        constructor(media: fm.liveswitch.Media);
        addOnStarted(value: fm.liveswitch.IAction0): void;
        addOnStopped(value: fm.liveswitch.IAction0): void;
        addOnDestroyed(value: fm.liveswitch.IAction0): void;
        removeOnStarted(value: fm.liveswitch.IAction0): void;
        removeOnStopped(value: fm.liveswitch.IAction0): void;
        removeOnDestroyed(value: fm.liveswitch.IAction0): void;
        changeSinkOutput(sinkOutput: fm.liveswitch.SinkOutput): fm.liveswitch.Future<Object>;
        changeSourceInput(sourceInput: fm.liveswitch.SourceInput): fm.liveswitch.Future<Object>;
        destroy(): boolean;
        getMuted(): boolean;
        getSinkOutput(): fm.liveswitch.SinkOutput;
        getSinkOutputs(): fm.liveswitch.Future<fm.liveswitch.SinkOutput[]>;
        getSourceInput(): fm.liveswitch.SourceInput;
        getSourceInputs(): fm.liveswitch.Future<fm.liveswitch.SourceInput[]>;
        setMuted(value: boolean): void;
        setSinkOutput(value: fm.liveswitch.SinkOutput): void;
        setSourceInput(value: fm.liveswitch.SourceInput): void;
    }
}
declare namespace fm.liveswitch {
    class AudioTrack extends fm.liveswitch.MediaTrack implements fm.liveswitch.IAudioTrack, fm.liveswitch.IExternalAudioTrack {
        getTypeString(): string;
        constructor(media: fm.liveswitch.Media, internalMedia?: fm.liveswitch.IInternalMedia);
        addOnLevel(value: fm.liveswitch.IAction1<number>): void;
        getGain(): number;
        getVolume(): number;
        removeOnLevel(value: fm.liveswitch.IAction1<number>): void;
        setGain(value: number): void;
        setVolume(value: number): void;
    }
}
declare namespace fm.liveswitch {
    class Connection extends fm.liveswitch.Dynamic implements fm.liveswitch.IConnection<fm.liveswitch.Connection, fm.liveswitch.Stream, fm.liveswitch.AudioStream, fm.liveswitch.VideoStream, fm.liveswitch.DataStream>, fm.liveswitch.IExternalConnection {
        getTypeString(): string;
        private _onExternalIdChangeValues;
        constructor(stream: fm.liveswitch.Stream);
        constructor(streams: fm.liveswitch.Stream[]);
        addIceServer(iceServer: fm.liveswitch.IceServer): void;
        addIceServers(iceServers: fm.liveswitch.IceServer[]): void;
        addOnGatheringStateChange(value: fm.liveswitch.IAction1<fm.liveswitch.Connection>): void;
        addOnIceConnectionStateChange(value: fm.liveswitch.IAction1<fm.liveswitch.Connection>): void;
        addOnLocalCandidate(value: fm.liveswitch.IAction2<fm.liveswitch.Connection, fm.liveswitch.Candidate>): void;
        addOnLocalDescription(value: fm.liveswitch.IAction2<fm.liveswitch.Connection, fm.liveswitch.SessionDescription>): void;
        addOnRemoteCandidate(value: fm.liveswitch.IAction2<fm.liveswitch.Connection, fm.liveswitch.Candidate>): void;
        addOnRemoteDescription(value: fm.liveswitch.IAction2<fm.liveswitch.Connection, fm.liveswitch.SessionDescription>): void;
        addOnSignallingStateChange(value: fm.liveswitch.IAction1<fm.liveswitch.Connection>): void;
        addOnStateChange(value: fm.liveswitch.IAction1<fm.liveswitch.Connection>): void;
        addRemoteCandidate(remoteCandidate: fm.liveswitch.Candidate): fm.liveswitch.Future<fm.liveswitch.Candidate>;
        close(): boolean;
        createAnswer(): fm.liveswitch.Future<fm.liveswitch.SessionDescription>;
        createOffer(): fm.liveswitch.Future<fm.liveswitch.SessionDescription>;
        getDeadStreamTimeout(): number;
        getError(): fm.liveswitch.Error;
        getExternalId(): string;
        getBundlePolicy(): fm.liveswitch.BundlePolicy;
        getIceGatherPolicy(): fm.liveswitch.IceGatherPolicy;
        getIceServer(): fm.liveswitch.IceServer;
        getGatheringState(): fm.liveswitch.IceGatheringState;
        getIceConnectionState(): fm.liveswitch.IceConnectionState;
        getIceServers(): fm.liveswitch.IceServer[];
        getId(): string;
        getCanonicalName(): string;
        getLocalDescription(): fm.liveswitch.SessionDescription;
        getRemoteDescription(): fm.liveswitch.SessionDescription;
        getSignallingState(): fm.liveswitch.SignallingState;
        getState(): fm.liveswitch.ConnectionState;
        getStats(): fm.liveswitch.Future<fm.liveswitch.ConnectionStats>;
        getStreams(): fm.liveswitch.Stream[];
        getTieBreaker(): string;
        getLegacyTimeout(): boolean;
        getTimeout(): number;
        getTrickleIcePolicy(): fm.liveswitch.TrickleIcePolicy;
        getHasAudio(): boolean;
        getHasVideo(): boolean;
        getHasData(): boolean;
        getAudioStream(): fm.liveswitch.AudioStream;
        getAudioStreams(): fm.liveswitch.AudioStream[];
        getVideoStream(): fm.liveswitch.VideoStream;
        getVideoStreams(): fm.liveswitch.VideoStream[];
        getDataStream(): fm.liveswitch.DataStream;
        getDataStreams(): fm.liveswitch.DataStream[];
        removeIceServer(iceServer: fm.liveswitch.IceServer): void;
        removeIceServers(iceServers: fm.liveswitch.IceServer[]): void;
        removeOnGatheringStateChange(value: fm.liveswitch.IAction1<fm.liveswitch.Connection>): void;
        removeOnIceConnectionStateChange(value: fm.liveswitch.IAction1<fm.liveswitch.Connection>): void;
        removeOnLocalCandidate(value: fm.liveswitch.IAction2<fm.liveswitch.Connection, fm.liveswitch.Candidate>): void;
        removeOnLocalDescription(value: fm.liveswitch.IAction2<fm.liveswitch.Connection, fm.liveswitch.SessionDescription>): void;
        removeOnRemoteCandidate(value: fm.liveswitch.IAction2<fm.liveswitch.Connection, fm.liveswitch.Candidate>): void;
        removeOnRemoteDescription(value: fm.liveswitch.IAction2<fm.liveswitch.Connection, fm.liveswitch.SessionDescription>): void;
        removeOnSignallingStateChange(value: fm.liveswitch.IAction1<fm.liveswitch.Connection>): void;
        removeOnStateChange(value: fm.liveswitch.IAction1<fm.liveswitch.Connection>): void;
        setDeadStreamTimeout(value: number): void;
        setExternalId(value: string): void;
        setError(value: fm.liveswitch.Error): void;
        addOnExternalIdChange(value: fm.liveswitch.IAction2<string, string>): void;
        removeOnExternalIdChange(value: fm.liveswitch.IAction2<string, string>): void;
        setBundlePolicy(value: fm.liveswitch.BundlePolicy): void;
        setIceGatherPolicy(value: fm.liveswitch.IceGatherPolicy): void;
        setIceServer(value: fm.liveswitch.IceServer): void;
        setIceServers(value: fm.liveswitch.IceServer[]): void;
        setLocalDescription(localDescription: fm.liveswitch.SessionDescription): fm.liveswitch.Future<fm.liveswitch.SessionDescription>;
        setLegacyTimeout(legacyTimeout: boolean): void;
        setRemoteDescription(remoteDescription: fm.liveswitch.SessionDescription): fm.liveswitch.Future<fm.liveswitch.SessionDescription>;
        setTimeout(value: number): void;
        setTrickleIcePolicy(value: fm.liveswitch.TrickleIcePolicy): void;
        setTieBreaker(value: string): void;
        getRemoteMedia(): fm.liveswitch.RemoteMedia;
        private externalsToInternals;
        private externalToInternal;
        private internalsToExternals;
        private internalToExternal;
    }
}
declare namespace fm.liveswitch {
    class DataChannel extends fm.liveswitch.Dynamic implements fm.liveswitch.IDataChannel<fm.liveswitch.DataChannel>, fm.liveswitch.IExternalDataChannel {
        getTypeString(): string;
        getInfo(): fm.liveswitch.DataChannelInfo;
        constructor(label: string, ordered?: boolean, subprotocol?: string);
        setOnReceive(value: fm.liveswitch.IAction1<fm.liveswitch.DataChannelReceiveArgs>): void;
        getSubprotocol(): string;
        getOnReceive(): fm.liveswitch.IAction1<fm.liveswitch.DataChannelReceiveArgs>;
        sendDataString(dataString: string): fm.liveswitch.Future<Object>;
        sendDataBytes(dataBytes: fm.liveswitch.DataBuffer): fm.liveswitch.Future<Object>;
        getState(): fm.liveswitch.DataChannelState;
        getLabel(): string;
        getId(): string;
        getOrdered(): boolean;
        addOnStateChange(value: fm.liveswitch.IAction1<fm.liveswitch.DataChannel>): void;
        removeOnStateChange(value: fm.liveswitch.IAction1<fm.liveswitch.DataChannel>): void;
    }
}
declare namespace fm.liveswitch {
    class DataStream extends fm.liveswitch.Stream implements fm.liveswitch.IDataStream<fm.liveswitch.DataChannel>, fm.liveswitch.IExternalDataStream {
        getTypeString(): string;
        getInfo(): fm.liveswitch.DataStreamInfo;
        constructor(channel: fm.liveswitch.DataChannel);
        constructor(channels: fm.liveswitch.DataChannel[]);
        setGetRemoteConnectionInfo(value: fm.liveswitch.IFunction1<string, any>): void;
        getChannels(): fm.liveswitch.DataChannel[];
        private externalToInternal;
        private externalsToInternals;
        private internalToExternal;
        private internalsToExternals;
    }
}
declare namespace fm.liveswitch {
    class DomAudioSink extends fm.liveswitch.Dynamic implements fm.liveswitch.IExternalDomAudioSink {
        getTypeString(): string;
        getAudio(): HTMLAudioElement;
        constructor(track: fm.liveswitch.AudioTrack);
    }
}
declare namespace fm.liveswitch {
    /**
    A layout preset.
    */
    class LayoutPreset extends fm.liveswitch.Dynamic {
        getTypeString(): string;
        /** @hidden */
        private __blockHeight;
        /** @hidden */
        private __blockHeightPercent;
        /** @hidden */
        private __blockMarginX;
        /** @hidden */
        private __blockMarginXPercent;
        /** @hidden */
        private __blockMarginY;
        /** @hidden */
        private __blockMarginYPercent;
        /** @hidden */
        private __blockWidth;
        /** @hidden */
        private __blockWidthPercent;
        /** @hidden */
        private __floatHeight;
        /** @hidden */
        private __floatHeightPercent;
        /** @hidden */
        private __floatMarginX;
        /** @hidden */
        private __floatMarginXPercent;
        /** @hidden */
        private __floatMarginY;
        /** @hidden */
        private __floatMarginYPercent;
        /** @hidden */
        private __floatWidth;
        /** @hidden */
        private __floatWidthPercent;
        /** @hidden */
        private _alignment;
        /** @hidden */
        private _direction;
        /** @hidden */
        private _inlineMargin;
        /** @hidden */
        private _mode;
        private fmliveswitchLayoutPresetInit;
        /**
        Initializes a new instance of the [[fm.liveswitch.layoutPreset]] class.
        */
        constructor();
        /** @hidden */
        private static calculateInlineOverflowFrame;
        /** @hidden */
        private static calculateTable;
        /** @hidden */
        private static divideByTwo;
        /**
        Gets a Facetime-style layout preset.
        */
        static getFacetime(): fm.liveswitch.LayoutPreset;
        /**
        Gets a Google Hangouts-style layout preset. Note that this will present differently on mobile devices.
        */
        static getGoogleHangouts(): fm.liveswitch.LayoutPreset;
        /** @hidden */
        private static getSingleLayout;
        /**
        Gets a Skype-style layout preset. Note that this will present differently on mobile devices.
        */
        static getSkype(): fm.liveswitch.LayoutPreset;
        /** @hidden */
        private static getXMax;
        /** @hidden */
        private static getXMid;
        /** @hidden */
        private static getXMin;
        /** @hidden */
        private static getYMax;
        /** @hidden */
        private static getYMid;
        /** @hidden */
        private static getYMin;
        /** @hidden */
        private static mergeLayoutFrames;
        /** @hidden */
        private static spliceLayoutFrame;
        /** @hidden */
        private static takeLayoutFrames;
        /** @hidden */
        static transformFrame(frame: fm.liveswitch.LayoutFrame, origin: fm.liveswitch.LayoutOrigin, layoutWidth: number, layoutHeight: number): void;
        /**
        Applies a preset.
        @param preset The preset to apply.
        */
        applyPreset(preset: fm.liveswitch.LayoutPreset): void;
        /** @hidden */
        private calculateBlockFrame;
        /** @hidden */
        private calculateFillFrame;
        /** @hidden */
        private calculateFloatFrame;
        /** @hidden */
        private calculateFloatFrames;
        /** @hidden */
        private calculateInlineFrame;
        /** @hidden */
        private calculateInlineFrames;
        /** @hidden */
        private calculateInlineOverflowFrames;
        /**
        Gets a video frame layout.
        @param layoutWidth The total width of the layout.
        @param layoutHeight The total height of the layout.
        @param local Whether a local frame is needed.
        @param remoteCount The number of remote frames.
        @param origin The layout origin.
        @param localVideoSize The local video size.
        @param remoteVideoSizes The remote video sizes.
        @return The video frame layout.
        */
        calculateLayout(layoutWidth: number, layoutHeight: number, local: boolean, remoteCount: number, origin: fm.liveswitch.LayoutOrigin, localVideoSize: fm.liveswitch.Size, remoteVideoSizes: fm.liveswitch.Size[]): fm.liveswitch.Layout;
        /**
        Gets a video frame layout.
        @param layoutWidth The total width of the layout.
        @param layoutHeight The total height of the layout.
        @param remoteCount The number of remote frames.
        @param origin The layout origin.
        @return The video frame layout.
        */
        calculateLayout(layoutWidth: number, layoutHeight: number, remoteCount: number, origin: fm.liveswitch.LayoutOrigin): fm.liveswitch.Layout;
        /**
        Copies this preset's properties to another preset.
        @param preset The target preset.
        */
        copyToPreset(preset: fm.liveswitch.LayoutPreset): void;
        /**
        Gets the alignment of the layout. Defaults to [[fm.liveswitch.layoutAlignment.BottomRight]].
        */
        getAlignment(): fm.liveswitch.LayoutAlignment;
        /**
        Gets the height of block elements in pixels. Overrides [[fm.liveswitch.layoutPreset.blockHeightPercent]].
        */
        getBlockHeight(): number;
        /**
        Gets the height of block elements as a percent of the container height between 0.0 and 1.0. Overrides [[fm.liveswitch.layoutPreset.blockHeight]].
        */
        getBlockHeightPercent(): number;
        /** @hidden */
        private getBlockLayout;
        /**
        Gets the X-margin between block elements and the layout edge in pixels. Overrides [[fm.liveswitch.layoutPreset.blockMarginXPercent]].
        */
        getBlockMarginX(): number;
        /**
        Gets the X-margin between block elements and the layout edge as a percent of the container width between 0.0 and 1.0. Overrides [[fm.liveswitch.layoutPreset.blockMarginX]].
        */
        getBlockMarginXPercent(): number;
        /**
        Gets the Y-margin between block elements and the layout edge in pixels. Overrides [[fm.liveswitch.layoutPreset.blockMarginYPercent]].
        */
        getBlockMarginY(): number;
        /**
        Gets the Y-margin between block elements and the layout edge as a percent of the container height between 0.0 and 1.0. Overrides [[fm.liveswitch.layoutPreset.blockMarginY]].
        */
        getBlockMarginYPercent(): number;
        /**
        Gets the width of block elements in pixels. Overrides [[fm.liveswitch.layoutPreset.blockWidthPercent]].
        */
        getBlockWidth(): number;
        /**
        Gets the width of block elements as a percent of the container width between 0.0 and 1.0. Overrides [[fm.liveswitch.layoutPreset.blockWidth]].
        */
        getBlockWidthPercent(): number;
        /** @hidden */
        private getBottomRowIndexes;
        /** @hidden */
        private getCenterColumnIndexes;
        /** @hidden */
        private getCenterRowIndexes;
        /**
        Gets the direction of the layout flow. Defaults to [[fm.liveswitch.layoutDirection.Horizontal]].
        */
        getDirection(): fm.liveswitch.LayoutDirection;
        /**
        Gets the height of floating elements in pixels. Overrides [[fm.liveswitch.layoutPreset.floatHeightPercent]].
        */
        getFloatHeight(): number;
        /**
        Gets the height of floating elements as a percent of the container height between 0.0 and 1.0. Overrides [[fm.liveswitch.layoutPreset.floatHeight]].
        */
        getFloatHeightPercent(): number;
        /** @hidden */
        private getFloatLocalLayout;
        /**
        Gets the X-margin between floating elements and the layout edge in pixels. Overrides [[fm.liveswitch.layoutPreset.floatMarginXPercent]].
        */
        getFloatMarginX(): number;
        /**
        Gets the X-margin between floating elements and the layout edge as a percent of the container width between 0.0 and 1.0. Overrides [[fm.liveswitch.layoutPreset.floatMarginX]].
        */
        getFloatMarginXPercent(): number;
        /**
        Gets the Y-margin between floating elements and the layout edge in pixels. Overrides [[fm.liveswitch.layoutPreset.floatMarginYPercent]].
        */
        getFloatMarginY(): number;
        /**
        Gets the Y-margin between floating elements and the layout edge as a percent of the container height between 0.0 and 1.0. Overrides [[fm.liveswitch.layoutPreset.floatMarginY]].
        */
        getFloatMarginYPercent(): number;
        /** @hidden */
        private getFloatRemoteLayout;
        /**
        Gets the width of floating elements in pixels. Overrides [[fm.liveswitch.layoutPreset.floatWidthPercent]].
        */
        getFloatWidth(): number;
        /**
        Gets the width of floating elements as a percent of the container width between 0.0 and 1.0. Overrides [[fm.liveswitch.layoutPreset.floatWidth]].
        */
        getFloatWidthPercent(): number;
        /** @hidden */
        private getInlineLayout;
        /**
        Gets the size of the margin in pixels to use between inline elements.
        */
        getInlineMargin(): number;
        /** @hidden */
        private getInlineOverflowLayout;
        /** @hidden */
        private getLeftColumnIndexes;
        /**
        Gets the mode used by the layout engine. Defaults to [[fm.liveswitch.layoutMode.FloatLocal]].
        */
        getMode(): fm.liveswitch.LayoutMode;
        /** @hidden */
        private getRightColumnIndexes;
        /** @hidden */
        private getTopRowIndexes;
        /**
        Sets the alignment of the layout. Defaults to [[fm.liveswitch.layoutAlignment.BottomRight]].
        */
        setAlignment(value: fm.liveswitch.LayoutAlignment): void;
        /**
        Sets the height of block elements in pixels. Overrides [[fm.liveswitch.layoutPreset.blockHeightPercent]].
        */
        setBlockHeight(value: number): void;
        /**
        Sets the height of block elements as a percent of the container height between 0.0 and 1.0. Overrides [[fm.liveswitch.layoutPreset.blockHeight]].
        */
        setBlockHeightPercent(value: number): void;
        /**
        Sets the X-margin between block elements and the layout edge in pixels. Overrides [[fm.liveswitch.layoutPreset.blockMarginXPercent]].
        */
        setBlockMarginX(value: number): void;
        /**
        Sets the X-margin between block elements and the layout edge as a percent of the container width between 0.0 and 1.0. Overrides [[fm.liveswitch.layoutPreset.blockMarginX]].
        */
        setBlockMarginXPercent(value: number): void;
        /**
        Sets the Y-margin between block elements and the layout edge in pixels. Overrides [[fm.liveswitch.layoutPreset.blockMarginYPercent]].
        */
        setBlockMarginY(value: number): void;
        /**
        Sets the Y-margin between block elements and the layout edge as a percent of the container height between 0.0 and 1.0. Overrides [[fm.liveswitch.layoutPreset.blockMarginY]].
        */
        setBlockMarginYPercent(value: number): void;
        /**
        Sets the width of block elements in pixels. Overrides [[fm.liveswitch.layoutPreset.blockWidthPercent]].
        */
        setBlockWidth(value: number): void;
        /**
        Sets the width of block elements as a percent of the container width between 0.0 and 1.0. Overrides [[fm.liveswitch.layoutPreset.blockWidth]].
        */
        setBlockWidthPercent(value: number): void;
        /**
        Sets the direction of the layout flow. Defaults to [[fm.liveswitch.layoutDirection.Horizontal]].
        */
        setDirection(value: fm.liveswitch.LayoutDirection): void;
        /**
        Sets the height of floating elements in pixels. Overrides [[fm.liveswitch.layoutPreset.floatHeightPercent]].
        */
        setFloatHeight(value: number): void;
        /**
        Sets the height of floating elements as a percent of the container height between 0.0 and 1.0. Overrides [[fm.liveswitch.layoutPreset.floatHeight]].
        */
        setFloatHeightPercent(value: number): void;
        /**
        Sets the X-margin between floating elements and the layout edge in pixels. Overrides [[fm.liveswitch.layoutPreset.floatMarginXPercent]].
        */
        setFloatMarginX(value: number): void;
        /**
        Sets the X-margin between floating elements and the layout edge as a percent of the container width between 0.0 and 1.0. Overrides [[fm.liveswitch.layoutPreset.floatMarginX]].
        */
        setFloatMarginXPercent(value: number): void;
        /**
        Sets the Y-margin between floating elements and the layout edge in pixels. Overrides [[fm.liveswitch.layoutPreset.floatMarginYPercent]].
        */
        setFloatMarginY(value: number): void;
        /**
        Sets the Y-margin between floating elements and the layout edge as a percent of the container height between 0.0 and 1.0. Overrides [[fm.liveswitch.layoutPreset.floatMarginY]].
        */
        setFloatMarginYPercent(value: number): void;
        /**
        Sets the width of floating elements in pixels. Overrides [[fm.liveswitch.layoutPreset.floatWidthPercent]].
        */
        setFloatWidth(value: number): void;
        /**
        Sets the width of floating elements as a percent of the container width between 0.0 and 1.0. Overrides [[fm.liveswitch.layoutPreset.floatWidth]].
        */
        setFloatWidthPercent(value: number): void;
        /**
        Sets the size of the margin in pixels to use between inline elements.
        */
        setInlineMargin(value: number): void;
        /**
        Sets the mode used by the layout engine. Defaults to [[fm.liveswitch.layoutMode.FloatLocal]].
        */
        setMode(value: fm.liveswitch.LayoutMode): void;
    }
}
declare namespace fm.liveswitch {
    /**
    A class that supplies simple video frame layout management.
    */
    abstract class LayoutManager<T> extends fm.liveswitch.LayoutPreset {
        getTypeString(): string;
        /** @hidden */
        private __onLayout;
        /** @hidden */
        private _inBatch;
        /** @hidden */
        private _layoutOrigin;
        /** @hidden */
        private _localView;
        /** @hidden */
        private _onLayout;
        /** @hidden */
        private _remoteViewsLock;
        /** @hidden */
        private _remoteViewsTable;
        private fmliveswitchLayoutManagerInit;
        /**
        Initializes a new instance of the [[fm.liveswitch.layoutManager]] class.
        */
        constructor();
        /**
        Initializes a new instance of the [[fm.liveswitch.layoutManager]] class.
        */
        constructor(preset: fm.liveswitch.LayoutPreset);
        /**
        Adds a handler that is raised when a layout is calculated.
        */
        addOnLayout(value: fm.liveswitch.IAction1<fm.liveswitch.Layout>): void;
        /**
        Adds remote media to the layout.
        @param remoteMedia The remote media.
        @return `true` if successful; otherwise, `false`.
            
        */
        addRemoteMedia(remoteMedia: fm.liveswitch.IViewableMedia<T>): boolean;
        /**
        Adds a remote view to the layout.
        @param idValue The remote view ID.
        @param view The remote view.
        @return `true` if successful; otherwise, `false`. Check the logs for additional information.
        */
        addRemoteView(idValue: string, view: T): boolean;
        /**
        Adds remote views to the layout.
        @param ids The remote view IDs.
        @param views The remote views.
        @return `true` if successful; otherwise, `false`. Check the logs for additional information.
        */
        addRemoteViews(ids: string[], views: T[]): boolean;
        /** @hidden */
        private addRemoteViewsUI;
        /** @hidden */
        private addRemoteViewUI;
        /**
        Adds a view to the container.
        @param view The view to add.
        */
        protected abstract addView(view: T): void;
        /**
        Dispatches an action to the main thread.
        @param action The action to invoke.
        @param arg1 The first argument.
        @param arg2 The second argument.
        */
        protected abstract dispatchToMainThread(action: fm.liveswitch.IAction2<Object, Object>, arg1: Object, arg2: Object): void;
        /**
        Gets the local view.
        @return The local view.
        */
        protected doGetLocalView(): T;
        /**
        Gets the remote views for a given remote view ID.
        @param idValue The remote view ID.
        @return The remote views.
        */
        protected doGetRemoteViews(idValue: string): Array<T>;
        /**
        Gets the remote view IDs.
        @return The remote view IDs.
        */
        protected doGetRemoteViewsIds(): string[];
        /** @hidden */
        private doSwapRemoteView;
        /** @hidden */
        private doSwapRemoteViews;
        /**
        Gets a video frame layout.
        @param layoutWidth The total width of the layout.
        @param layoutHeight The total height of the layout.
        @param local Whether a local frame is needed.
        @param remoteCount The number of remote frames.
        @return The video frame layout.
        */
        protected getLayout(layoutWidth: number, layoutHeight: number, local: boolean, remoteCount: number): fm.liveswitch.Layout;
        /**
        Gets a video frame layout.
        @param layoutWidth The total width of the layout.
        @param layoutHeight The total height of the layout.
        @param local Whether a local frame is needed.
        @param remoteCount The number of remote frames.
        @param remoteViewIds The remote view IDs.
        @return The video frame layout.
        */
        protected getLayout(layoutWidth: number, layoutHeight: number, local: boolean, remoteCount: number, remoteViewIds: string[]): fm.liveswitch.Layout;
        /**
        Gets a video frame layout.
        @param layoutWidth The total width of the layout.
        @param layoutHeight The total height of the layout.
        @param local Whether a local frame is needed.
        @param remoteCount The number of remote frames.
        @param remoteViewIds The remote view IDs.
        @param localVideoSize The local video size.
        @param remoteVideoSizes The remote video sizes.
        @return The video frame layout.
        */
        protected getLayout(layoutWidth: number, layoutHeight: number, local: boolean, remoteCount: number, remoteViewIds: string[], localVideoSize: fm.liveswitch.Size, remoteVideoSizes: fm.liveswitch.Size[]): fm.liveswitch.Layout;
        /**
        Gets a video frame layout.
        @param layoutWidth The total width of the layout.
        @param layoutHeight The total height of the layout.
        @param remoteCount The number of remote frames.
        @return The video frame layout.
        */
        protected getLayout(layoutWidth: number, layoutHeight: number, remoteCount: number): fm.liveswitch.Layout;
        /**
        Gets a video frame layout.
        @param layoutWidth The total width of the layout.
        @param layoutHeight The total height of the layout.
        @param remoteCount The number of remote frames.
        @param remoteViewIds The remote view IDs.
        @return The video frame layout.
        */
        protected getLayout(layoutWidth: number, layoutHeight: number, remoteCount: number, remoteViewIds: string[]): fm.liveswitch.Layout;
        /**
        Gets the layout origin. Defaults to TopLeft.
        */
        getLayoutOrigin(): fm.liveswitch.LayoutOrigin;
        /**
        Gets the local view from the layout.
        @return The local view.
        */
        getLocalView(): T;
        /** @hidden */
        private getNewestRemoteView;
        /** @hidden */
        private getOldestRemoteView;
        /**
        Gets a remote view from the layout.
        @param idValue The remote view ID.
        @return The remote view.
        */
        getRemoteView(idValue: string): T;
        /**
        Gets the IDs of the remote views in the layout.
        @return The remote view IDs.
        */
        getRemoteViewIds(): string[];
        /**
        Gets all remote views from the layout.
        @return The remote views.
        */
        getRemoteViews(): Array<T>;
        /**
        Gets remote views from the layout.
        @param ids The remote view IDs.
        @return The remote views.
        */
        getRemoteViews(ids: string[]): Array<T>;
        /** @hidden */
        private getRemoteViewsInternal;
        /**
        Positions the local and remote views within the layout.
        */
        abstract layout(): void;
        /**
        Positions the local and remote views within the layout after dispatching to the main thread.
        */
        layoutOnMainThread(): void;
        /** @hidden */
        private layoutOnMainThreadUI;
        /**
        Removes a handler that is raised when a layout is calculated.
        */
        removeOnLayout(value: fm.liveswitch.IAction1<fm.liveswitch.Layout>): void;
        /**
        Removes remote media from the layout.
        @param remoteMedia The remote media.
        @return `true` if successful; otherwise, `false`.
            
        */
        removeRemoteMedia(remoteMedia: fm.liveswitch.IViewableMedia<T>): boolean;
        /**
        Removes a remote view from the layout.
        @param idValue The remote view ID.
        @return `true` if successful; otherwise, `false`. Check the logs for additional information.
        */
        removeRemoteView(idValue: string): boolean;
        /**
        Removes all remote views from the layout.
        */
        removeRemoteViews(): void;
        /**
        Removes remote views from the layout.
        @param ids The remote view IDs.
        @return `true` if successful; otherwise, `false`. Check the logs for additional information.
        */
        removeRemoteViews(ids: string[]): boolean;
        /** @hidden */
        private removeRemoteViewsUI;
        /** @hidden */
        private removeRemoteViewUI;
        /**
        Removes a view from the container.
        @param view The view to remove.
        */
        protected abstract removeView(view: T): void;
        /**
        Removes all remote views from the layout, then removes the local view from the layout.
        */
        reset(): void;
        /**
        Sets the layout origin. Defaults to TopLeft.
        */
        protected setLayoutOrigin(value: fm.liveswitch.LayoutOrigin): void;
        /**
        Adds the local media to the layout.
        @param localMedia The local media.
        @return `true` if successful; otherwise, `false`.
        */
        setLocalMedia(localMedia: fm.liveswitch.IViewableMedia<T>): boolean;
        /**
        Adds the local view to the layout.
        @param view The local view.
        @return `true` if successful; otherwise, `false`. Check the logs for additional information.
        */
        setLocalView(view: T): boolean;
        /** @hidden */
        private setLocalViewUI;
        /**
        Swaps remote media in the layout.
        @param remoteMediaToRemove The remote media to remove.
        @param remoteMediaToAdd The remote media to add.
        */
        swapRemoteMedia(remoteMediaToRemove: fm.liveswitch.IViewableMedia<T>, remoteMediaToAdd: fm.liveswitch.IViewableMedia<T>): boolean;
        /**
        Swaps a remote view in the layout.
        @param idToRemove The remote view ID to remove.
        @param idToAdd The remote view ID to add.
        @param viewToAdd The remote view to add.
        */
        swapRemoteView(idToRemove: string, idToAdd: string, viewToAdd: T): boolean;
        /**
        Swaps remote views in the layout.
        @param idsToRemove The remote view IDs to remove.
        @param idsToAdd The remote view IDs to add.
        @param viewsToAdd The remote views to add.
        @return `true` if successful; otherwise, `false`. Check the logs for additional information.
        */
        swapRemoteViews(idsToRemove: string[], idsToAdd: string[], viewsToAdd: T[]): boolean;
        /**
        Removes the local view from the layout.
        @return `true` if successful; otherwise, `false`. Check the logs for additional information.
        */
        unsetLocalView(): boolean;
        /** @hidden */
        private unsetLocalViewUI;
    }
}
declare namespace fm.liveswitch {
    class DomLayoutManager extends fm.liveswitch.LayoutManager<HTMLElement> {
        getTypeString(): string;
        getContainer(): HTMLElement;
        constructor(container: HTMLElement, preset?: fm.liveswitch.LayoutPreset);
        private initializeInnerContainer;
        private destroyInnerContainer;
        destroy(): void;
        protected addView(view: HTMLElement): void;
        protected removeView(view: HTMLElement): void;
        protected dispatchToMainThread(action: fm.liveswitch.IAction2<any, any>, arg1: any, arg2: any): void;
        protected doGetLocalView(): HTMLElement;
        protected doGetRemoteViewsIds(): string[];
        protected doGetRemoteViews(idValue: string): HTMLElement[];
        private getViewsByClassName;
        private getParentViews;
        private getParentView;
        private collectionToArray;
        layout(): void;
        private getVideoSize;
        private getWebRtcVideoSize;
        private getPluginVideoSize;
        private addOnVideoSizeChange;
        private addOnWebRtcVideoSizeChange;
        private addOnPluginVideoSizeChange;
        private getVerticalScrollbarWidth;
        private getHorizontalScrollbarHeight;
    }
}
declare namespace fm.liveswitch {
    class DomVideoSink extends fm.liveswitch.Dynamic implements fm.liveswitch.IExternalDomVideoSink {
        getTypeString(): string;
        getVideo(): HTMLVideoElement;
        getView(): HTMLElement;
        getViewScale(): fm.liveswitch.LayoutScale;
        setViewScale(viewScale: fm.liveswitch.LayoutScale): void;
        getViewMirror(): boolean;
        setViewMirror(viewMirror: boolean): void;
        constructor(track: fm.liveswitch.VideoTrack);
    }
}
declare namespace fm.liveswitch {
    class Factory {
        getTypeString(): string;
        static createConnection(streams: fm.liveswitch.Stream[]): fm.liveswitch.Connection;
        static createAudioStream(localMedia: fm.liveswitch.LocalMedia): fm.liveswitch.AudioStream;
        static createVideoStream(localMedia: fm.liveswitch.LocalMedia): fm.liveswitch.VideoStream;
        static createDataChannel(label: string): fm.liveswitch.DataChannel;
        static createDataStream(channel: fm.liveswitch.DataChannel): fm.liveswitch.DataStream;
        static createDomVideoSink(track: fm.liveswitch.VideoTrack): fm.liveswitch.DomVideoSink;
        static createLocalMedia(audio: any, video: any, screen?: boolean): fm.liveswitch.LocalMedia;
    }
}
declare namespace fm.liveswitch {
    interface IExternal<TInternal> {
    }
}
declare namespace fm.liveswitch {
    interface IExternalAudioStream extends fm.liveswitch.IAudioStream, fm.liveswitch.IExternal<fm.liveswitch.IInternalAudioStream> {
    }
}
declare namespace fm.liveswitch {
    interface IExternalAudioTrack extends fm.liveswitch.IAudioTrack, fm.liveswitch.IExternal<fm.liveswitch.IInternalAudioTrack> {
    }
}
declare namespace fm.liveswitch {
    interface IExternalConnection extends fm.liveswitch.IConnection<fm.liveswitch.IExternalConnection, fm.liveswitch.IExternalStream, fm.liveswitch.IExternalAudioStream, fm.liveswitch.IExternalVideoStream, fm.liveswitch.IExternalDataStream>, fm.liveswitch.IExternal<fm.liveswitch.IInternalConnection> {
    }
}
declare namespace fm.liveswitch {
    interface IExternalDataChannel extends fm.liveswitch.IDataChannel<fm.liveswitch.IExternalDataChannel>, fm.liveswitch.IExternal<fm.liveswitch.IInternalDataChannel> {
    }
}
declare namespace fm.liveswitch {
    interface IExternalDataStream extends fm.liveswitch.IDataStream<fm.liveswitch.IExternalDataChannel>, fm.liveswitch.IExternal<fm.liveswitch.IInternalDataStream> {
    }
}
declare namespace fm.liveswitch {
    interface IExternalDomAudioSink extends fm.liveswitch.IExternal<fm.liveswitch.IInternalDomAudioSink> {
        getAudio(): HTMLAudioElement;
    }
}
declare namespace fm.liveswitch {
    interface IExternalDomVideoSink extends fm.liveswitch.IViewSink<HTMLElement>, fm.liveswitch.IExternal<fm.liveswitch.IInternalDomVideoSink> {
        getVideo(): HTMLVideoElement;
    }
}
declare namespace fm.liveswitch {
    interface IExternalLocalMedia extends fm.liveswitch.ILocalMedia<fm.liveswitch.IExternalLocalMedia, fm.liveswitch.IExternalAudioTrack, fm.liveswitch.IExternalVideoTrack>, fm.liveswitch.IViewSinkableMedia<HTMLElement, fm.liveswitch.IExternalDomVideoSink>, fm.liveswitch.IExternal<fm.liveswitch.IInternalLocalMedia>, fm.liveswitch.IExternalMedia {
    }
}
declare namespace fm.liveswitch {
    interface IExternalMedia extends fm.liveswitch.IMedia<fm.liveswitch.IExternalAudioTrack, fm.liveswitch.IExternalVideoTrack>, fm.liveswitch.IViewSinkableMedia<HTMLElement, fm.liveswitch.IExternalDomVideoSink> {
        getAudioSink(): fm.liveswitch.IExternalDomAudioSink;
        getVideoSink(): fm.liveswitch.IExternalDomVideoSink;
    }
}
declare namespace fm.liveswitch {
    interface IExternalMediaStream extends fm.liveswitch.IMediaStream, fm.liveswitch.IExternal<fm.liveswitch.IInternalMediaStream> {
    }
}
declare namespace fm.liveswitch {
    interface IExternalMediaTrack extends fm.liveswitch.IMediaTrack, fm.liveswitch.IExternal<fm.liveswitch.IInternalMediaTrack> {
    }
}
declare namespace fm.liveswitch {
    interface IExternalRemoteMedia extends fm.liveswitch.IRemoteMedia<fm.liveswitch.IExternalAudioTrack, fm.liveswitch.IExternalVideoTrack>, fm.liveswitch.IViewSinkableMedia<HTMLElement, fm.liveswitch.IExternalDomVideoSink>, fm.liveswitch.IExternal<fm.liveswitch.IInternalRemoteMedia>, fm.liveswitch.IExternalMedia {
    }
}
declare namespace fm.liveswitch {
    interface IExternalStream extends fm.liveswitch.IStream, fm.liveswitch.IExternal<fm.liveswitch.IInternalStream> {
    }
}
declare namespace fm.liveswitch {
    interface IExternalVideoStream extends fm.liveswitch.IVideoStream, fm.liveswitch.IExternal<fm.liveswitch.IInternalVideoStream> {
    }
}
declare namespace fm.liveswitch {
    interface IExternalVideoTrack extends fm.liveswitch.IVideoTrack, fm.liveswitch.IExternal<fm.liveswitch.IInternalVideoTrack> {
    }
}
declare namespace fm.liveswitch {
    interface IInternal<TExternal> {
    }
}
declare namespace fm.liveswitch {
    interface IInternalAudioStream extends fm.liveswitch.IAudioStream, fm.liveswitch.IInternal<fm.liveswitch.IExternalAudioStream> {
    }
}
declare namespace fm.liveswitch {
    interface IInternalAudioTrack extends fm.liveswitch.IAudioTrack, fm.liveswitch.IInternal<fm.liveswitch.IExternalAudioTrack> {
    }
}
declare namespace fm.liveswitch {
    interface IInternalConnection extends fm.liveswitch.IConnection<fm.liveswitch.IInternalConnection, fm.liveswitch.IInternalStream, fm.liveswitch.IInternalAudioStream, fm.liveswitch.IInternalVideoStream, fm.liveswitch.IInternalDataStream>, fm.liveswitch.IInternal<fm.liveswitch.IExternalConnection> {
    }
}
declare namespace fm.liveswitch {
    interface IInternalDataChannel extends fm.liveswitch.IDataChannel<fm.liveswitch.IInternalDataChannel>, fm.liveswitch.IInternal<fm.liveswitch.IExternalDataChannel> {
    }
}
declare namespace fm.liveswitch {
    interface IInternalDataStream extends fm.liveswitch.IDataStream<fm.liveswitch.IInternalDataChannel>, fm.liveswitch.IInternal<fm.liveswitch.IExternalDataStream> {
    }
}
declare namespace fm.liveswitch {
    interface IInternalDomAudioSink extends fm.liveswitch.IInternal<fm.liveswitch.IExternalDomAudioSink> {
        getAudio(): HTMLAudioElement;
    }
}
declare namespace fm.liveswitch {
    interface IInternalDomVideoSink extends fm.liveswitch.IViewSink<HTMLElement>, fm.liveswitch.IInternal<fm.liveswitch.IExternalDomVideoSink> {
        getVideo(): HTMLVideoElement;
    }
}
declare namespace fm.liveswitch {
    interface IInternalLocalMedia extends fm.liveswitch.ILocalMedia<fm.liveswitch.IInternalLocalMedia, fm.liveswitch.IInternalAudioTrack, fm.liveswitch.IInternalVideoTrack>, fm.liveswitch.IViewSinkableMedia<HTMLElement, fm.liveswitch.IInternalDomVideoSink>, fm.liveswitch.IInternal<fm.liveswitch.IExternalLocalMedia>, fm.liveswitch.IInternalMedia {
    }
}
declare namespace fm.liveswitch {
    interface IInternalMedia extends fm.liveswitch.IMedia<fm.liveswitch.IInternalAudioTrack, fm.liveswitch.IInternalVideoTrack>, fm.liveswitch.IViewSinkableMedia<HTMLElement, fm.liveswitch.IInternalDomVideoSink> {
        getAudioSink(): fm.liveswitch.IInternalDomAudioSink;
        getVideoSink(): fm.liveswitch.IInternalDomVideoSink;
    }
}
declare namespace fm.liveswitch {
    interface IInternalMediaStream extends fm.liveswitch.IMediaStream, fm.liveswitch.IInternal<fm.liveswitch.IExternalMediaStream> {
    }
}
declare namespace fm.liveswitch {
    interface IInternalMediaTrack extends fm.liveswitch.IMediaTrack, fm.liveswitch.IInternal<fm.liveswitch.IExternalMediaTrack> {
    }
}
declare namespace fm.liveswitch {
    interface IInternalRemoteMedia extends fm.liveswitch.IRemoteMedia<fm.liveswitch.IInternalAudioTrack, fm.liveswitch.IInternalVideoTrack>, fm.liveswitch.IViewSinkableMedia<HTMLElement, fm.liveswitch.IInternalDomVideoSink>, fm.liveswitch.IInternal<fm.liveswitch.IExternalRemoteMedia>, fm.liveswitch.IInternalMedia {
    }
}
declare namespace fm.liveswitch {
    interface IInternalStream extends fm.liveswitch.IStream, fm.liveswitch.IInternal<fm.liveswitch.IExternalStream> {
    }
}
declare namespace fm.liveswitch {
    interface IInternalVideoStream extends fm.liveswitch.IVideoStream, fm.liveswitch.IInternal<fm.liveswitch.IExternalVideoStream> {
    }
}
declare namespace fm.liveswitch {
    interface IInternalVideoTrack extends fm.liveswitch.IVideoTrack, fm.liveswitch.IInternal<fm.liveswitch.IExternalVideoTrack> {
    }
}
declare namespace fm.liveswitch {
    interface IPluginDomVideoView extends HTMLObjectElement {
        GetIsLoaded(): boolean;
        GetHandle(): number;
        GetWidth(): number;
        GetHeight(): number;
        SetOnVideoResize(callback: Object): void;
        GetVideoWidth(): number;
        GetVideoHeight(): number;
        GetViewMirror(): boolean;
        SetViewMirror(viewMirrow: boolean): void;
        GetViewScale(): number;
        SetViewScale(viewScale: number): void;
    }
}
declare namespace fm.liveswitch {
    abstract class Media extends fm.liveswitch.Dynamic implements fm.liveswitch.IMedia<fm.liveswitch.AudioTrack, fm.liveswitch.VideoTrack>, fm.liveswitch.IExternalMedia {
        getTypeString(): string;
        addOnAudioDestroyed(value: fm.liveswitch.IAction0): void;
        addOnVideoDestroyed(value: fm.liveswitch.IAction0): void;
        removeOnAudioDestroyed(value: fm.liveswitch.IAction0): void;
        removeOnVideoDestroyed(value: fm.liveswitch.IAction0): void;
        addOnAudioLevel(value: fm.liveswitch.IAction1<number>): void;
        addOnVideoSize(value: fm.liveswitch.IAction1<fm.liveswitch.Size>): void;
        getAudioGain(): number;
        getAudioMuted(): boolean;
        getAudioTrack(): fm.liveswitch.AudioTrack;
        getAudioTracks(): fm.liveswitch.AudioTrack[];
        getAudioVolume(): number;
        getId(): string;
        getVideoMuted(): boolean;
        getVideoSize(): fm.liveswitch.Size;
        getVideoTrack(): fm.liveswitch.VideoTrack;
        getVideoTracks(): fm.liveswitch.VideoTrack[];
        grabVideoFrame(): fm.liveswitch.Future<fm.liveswitch.VideoBuffer>;
        removeOnAudioLevel(value: fm.liveswitch.IAction1<number>): void;
        removeOnVideoSize(value: fm.liveswitch.IAction1<fm.liveswitch.Size>): void;
        setAudioGain(value: number): void;
        setAudioMuted(value: boolean): void;
        setAudioVolume(value: number): void;
        setId(value: string): void;
        setVideoMuted(value: boolean): void;
        destroy(): void;
        getAudioSink(): fm.liveswitch.DomAudioSink;
        getVideoSink(): fm.liveswitch.DomVideoSink;
        getView(): HTMLElement;
        getViewSink(): fm.liveswitch.DomVideoSink;
        private externalsToInternals;
        private externalToInternal;
        private internalsToExternals;
        private internalToExternal;
    }
}
declare namespace fm.liveswitch {
    class LocalMedia extends fm.liveswitch.Media implements fm.liveswitch.ILocalMedia<fm.liveswitch.LocalMedia, fm.liveswitch.AudioTrack, fm.liveswitch.VideoTrack>, fm.liveswitch.IExternalLocalMedia {
        getTypeString(): string;
        private _internal;
        addOnAudioStarted(value: fm.liveswitch.IAction0): void;
        addOnAudioStopped(value: fm.liveswitch.IAction0): void;
        addOnVideoStarted(value: fm.liveswitch.IAction0): void;
        addOnVideoStopped(value: fm.liveswitch.IAction0): void;
        removeOnAudioStarted(value: fm.liveswitch.IAction0): void;
        removeOnAudioStopped(value: fm.liveswitch.IAction0): void;
        removeOnVideoStarted(value: fm.liveswitch.IAction0): void;
        removeOnVideoStopped(value: fm.liveswitch.IAction0): void;
        getAudioEncoding(): fm.liveswitch.AudioEncodingConfig;
        getAudioEncodings(): fm.liveswitch.AudioEncodingConfig[];
        setAudioEncodings(value: fm.liveswitch.AudioEncodingConfig[]): void;
        getVideoEncoding(): fm.liveswitch.VideoEncodingConfig;
        getVideoEncodings(): fm.liveswitch.VideoEncodingConfig[];
        setVideoEncodings(value: fm.liveswitch.VideoEncodingConfig[]): void;
        /**
         * Deprecated: Use fm.liveswitch.Plugin.getChromeExtensionId()
         */
        static getChromeExtensionId(): string;
        /**
         * Deprecated: Use fm.liveswitch.Plugin.setChromeExtensionId()
         */
        static setChromeExtensionId(chromeExtensionId: string): void;
        /**
         * Deprecated: Use fm.liveswitch.Plugin.getChromeExtensionUrl()
         */
        static getChromeExtensionUrl(): string;
        /**
         * Deprecated: Use fm.liveswitch.Plugin.getChromeExtensionInstalled()
         */
        static getChromeExtensionInstalled(): boolean;
        /**
         * Deprecated: Use fm.liveswitch.Plugin.getChromeExtensionRequiresUserGesture()
         */
        static getChromeExtensionRequiresUserGesture(): boolean;
        /**
         * Deprecated: Use fm.liveswitch.Plugin.setChromeExtensionRequiresUserGesture()
         */
        static setChromeExtensionRequiresUserGesture(chromeExtensionRequiresUserGesture: boolean): void;
        static canScreenShare(): boolean;
        constructor(audio: any, video: any, screen?: boolean);
        changeAudioSourceInput(audioSourceInput: fm.liveswitch.SourceInput): fm.liveswitch.Future<Object>;
        changeVideoSourceInput(videoSourceInput: fm.liveswitch.SourceInput): fm.liveswitch.Future<Object>;
        getAudioSourceInput(): fm.liveswitch.SourceInput;
        getAudioSourceInputs(): fm.liveswitch.Future<fm.liveswitch.SourceInput[]>;
        getVideoSourceInput(): fm.liveswitch.SourceInput;
        getVideoSourceInputs(): fm.liveswitch.Future<fm.liveswitch.SourceInput[]>;
        setAudioSourceInput(value: fm.liveswitch.SourceInput): void;
        setVideoSourceInput(value: fm.liveswitch.SourceInput): void;
        start(): fm.liveswitch.Future<fm.liveswitch.LocalMedia>;
        stop(): fm.liveswitch.Future<fm.liveswitch.LocalMedia>;
        changeAudioInput(audioInput: fm.liveswitch.SourceInput): fm.liveswitch.Future<Object>;
        changeVideoInput(videoInput: fm.liveswitch.SourceInput): fm.liveswitch.Future<Object>;
        getAudioInput(): fm.liveswitch.SourceInput;
        getAudioInputs(): fm.liveswitch.Future<fm.liveswitch.SourceInput[]>;
        getVideoInput(): fm.liveswitch.SourceInput;
        getVideoInputs(): fm.liveswitch.Future<fm.liveswitch.SourceInput[]>;
        setAudioInput(audioInput: fm.liveswitch.SourceInput): void;
        setVideoInput(videoInput: fm.liveswitch.SourceInput): void;
        getState(): fm.liveswitch.LocalMediaState;
        getAudioSimulcastDisabled(): boolean;
        setAudioSimulcastDisabled(value: boolean): void;
        getAudioSimulcastEncodingCount(): number;
        setAudioSimulcastEncodingCount(value: number): void;
        getAudioSimulcastPreferredBitrate(): number;
        setAudioSimulcastPreferredBitrate(value: number): void;
        getVideoSimulcastDisabled(): boolean;
        setVideoSimulcastDisabled(value: boolean): void;
        getVideoSimulcastEncodingCount(): number;
        setVideoSimulcastEncodingCount(value: number): void;
        getVideoSimulcastPreferredBitrate(): number;
        setVideoSimulcastPreferredBitrate(value: number): void;
        getVideoSimulcastBitsPerPixel(): number;
        setVideoSimulcastBitsPerPixel(value: number): void;
        getVideoSimulcastDegradationPreference(): fm.liveswitch.VideoDegradationPreference;
        setVideoSimulcastDegradationPreference(value: fm.liveswitch.VideoDegradationPreference): void;
    }
}
declare namespace fm.liveswitch {
    class LocalNetwork {
        getTypeString(): string;
        static getAddressType(ipAddress: string): fm.liveswitch.AddressType;
    }
}
declare namespace fm.liveswitch {
    /** @hidden */
    abstract class MediaDescriptionManagerBase {
        getTypeString(): string;
        /** @hidden */
        private _mediaStreamIdentifier;
        constructor();
        static syncroniseMediaIdentification(sdpMediaDescription: fm.liveswitch.sdp.MediaDescription, index: number): string;
        getMediaStreamIdentifier(): string;
        processSdpMediaDescription(mediaRequirements: fm.liveswitch.MediaDescriptionRequirementsBase, sdpMessage: fm.liveswitch.sdp.Message, index: number, isLocalDescription: boolean, isRenegotiation: boolean, isOffer: boolean): fm.liveswitch.Error;
        setMediaStreamIdentifier(value: string): void;
    }
}
declare namespace fm.liveswitch {
    /**
    @hidden
    */
    class MediaDescriptionManager extends fm.liveswitch.MediaDescriptionManagerBase {
        getTypeString(): string;
        private _MediaStreamMediaDescriptionManagerUtility;
        constructor();
        localMuted: boolean;
        remoteMuted: boolean;
        processSdpMediaDescription(mediaRequirements: fm.liveswitch.MediaDescriptionRequirementsBase, sdpMessage: fm.liveswitch.sdp.Message, index: number, isLocalDescription: boolean, isRenegotiation: boolean, isOffer: boolean): fm.liveswitch.Error;
    }
}
declare namespace fm.liveswitch {
    /** @hidden */
    abstract class MediaDescriptionRequirementsBase {
        getTypeString(): string;
        /** @hidden */
        private _mediaStreamIdentifier;
        constructor();
        getMediaStreamIdentifier(): string;
        setMediaStreamIdentifier(value: string): void;
    }
}
declare namespace fm.liveswitch {
}
declare namespace fm.liveswitch {
    class PluginConstants {
        static getLoaderClassId(): string;
        static getDomVideoSinkClassId(): string;
    }
}
declare namespace fm.liveswitch {
    class Plugin {
        static install(pluginConfig: fm.liveswitch.PluginConfig): fm.liveswitch.Future<Object>;
        static getPluginConfig(): fm.liveswitch.PluginConfig;
        static hasRtcPeerConnection(): boolean;
        static hasRtcDataChannel(): boolean;
        static hasGetUserMedia(): boolean;
        static hasGetDisplayMedia(): boolean;
        static hasRtcIceGatherer(): boolean;
        static hasRtcIceTransport(): boolean;
        static hasRtcDtlsTransport(): boolean;
        static hasRtcRtpSender(): boolean;
        static hasRtcRtpReceiver(): boolean;
        static hasWebRtc(localMedia?: boolean, dataChannels?: boolean): boolean;
        static hasOrtc(localMedia?: boolean, dataChannels?: boolean): boolean;
        static hasNative(localMedia?: boolean, dataChannels?: boolean): boolean;
        static hasActiveX(): boolean;
        static isReady(localMedia?: boolean, dataChannels?: boolean): boolean;
        static isSupported(localMedia?: boolean, dataChannels?: boolean): boolean;
        static useActiveX(localMedia?: boolean, dataChannels?: boolean): boolean;
        static useNative(localMedia?: boolean, dataChannels?: boolean): boolean;
        private static checkForActiveX;
        static getChromeExtensionId(): string;
        static setChromeExtensionId(chromeExtensionId: string): void;
        static getChromeExtensionUrl(): string;
        static getChromeExtensionInstalled(): boolean;
        static getChromeExtensionRequiresUserGesture(): boolean;
        static setChromeExtensionRequiresUserGesture(chromeExtensionRequiresUserGesture: boolean): void;
        static getChromeExtensionRequired(): boolean;
    }
}
declare namespace fm.liveswitch {
    abstract class PluginStream extends fm.liveswitch.Dynamic implements fm.liveswitch.IStream, fm.liveswitch.IInternalStream {
        getTypeString(): string;
        abstract getState(): fm.liveswitch.StreamState;
        abstract addOnStateChange(value: fm.liveswitch.IAction0): void;
        abstract removeOnStateChange(value: fm.liveswitch.IAction0): void;
        abstract getLocalReceive(): boolean;
        abstract setLocalReceive(localReceiveEnabled: boolean): void;
        abstract getLocalSend(): boolean;
        abstract setLocalSend(localSendEnabled: boolean): void;
        abstract getRemoteSend(): boolean;
        abstract getRemoteReceive(): boolean;
        abstract getRemoteDirection(): fm.liveswitch.StreamDirection;
        abstract getHandle(): number;
        abstract addOnDirectionChange(value: fm.liveswitch.IAction0): void;
        abstract removeOnDirectionChange(value: fm.liveswitch.IAction0): void;
        abstract changeDirection(newDirection: fm.liveswitch.StreamDirection): fm.liveswitch.Error;
        abstract getDirection(): fm.liveswitch.StreamDirection;
        abstract getId(): string;
        abstract getExternalId(): string;
        abstract setExternalId(value: string): void;
        abstract getLabel(): string;
        abstract getLocalDirection(): fm.liveswitch.StreamDirection;
        abstract getMediaDescriptionId(): string;
        abstract getTag(): string;
        abstract getType(): fm.liveswitch.StreamType;
        abstract setLocalDirection(value: fm.liveswitch.StreamDirection): void;
        abstract setTag(value: string): void;
        abstract getTransportInfo(): fm.liveswitch.TransportInfo;
    }
}
declare namespace fm.liveswitch {
    abstract class PluginMediaStream<TTrack extends fm.liveswitch.PluginMediaTrack> extends fm.liveswitch.PluginStream implements fm.liveswitch.IMediaStream, fm.liveswitch.IInternalMediaStream {
        getTypeString(): string;
        getLocalTrack(): TTrack;
        getRemoteTrack(): TTrack;
        abstract getLocalBandwidth(): number;
        abstract setLocalBandwidth(value: number): void;
        abstract getInputMuted(): boolean;
        abstract getOutputMuted(): boolean;
        abstract getRemoteBandwidth(): number;
        abstract setInputMuted(muted: boolean): void;
        abstract setOutputMuted(muted: boolean): void;
        abstract getPreferredCodecs(): string[];
        abstract setPreferredCodecs(names: string[]): void;
        abstract getCodecDisabled(name: string): boolean;
        abstract setCodecDisabled(name: string, disabled: boolean): void;
        abstract getRemoteEncoding(): fm.liveswitch.EncodingInfo;
        abstract setRemoteEncoding(value: fm.liveswitch.EncodingInfo): void;
        abstract getSimulcastMode(): fm.liveswitch.SimulcastMode;
        abstract setSimulcastMode(value: fm.liveswitch.SimulcastMode): void;
        abstract getLocalCanonicalName(): string;
        abstract getRemoteCanonicalName(): string;
        abstract getInfo(): fm.liveswitch.MediaStreamInfo;
        abstract getControlTransportInfo(): fm.liveswitch.TransportInfo;
        abstract addOnLocalEncodingDisabled(value: fm.liveswitch.IAction1<fm.liveswitch.EncodingInfo>): void;
        abstract addOnLocalEncodingEnabled(value: fm.liveswitch.IAction1<fm.liveswitch.EncodingInfo>): void;
        abstract removeOnLocalEncodingDisabled(value: fm.liveswitch.IAction1<fm.liveswitch.EncodingInfo>): void;
        abstract removeOnLocalEncodingEnabled(value: fm.liveswitch.IAction1<fm.liveswitch.EncodingInfo>): void;
        abstract addOnDiscardBitrateRequest(value: fm.liveswitch.IAction1<fm.liveswitch.BitrateRequest>): void;
        abstract removeOnDiscardBitrateRequest(value: fm.liveswitch.IAction1<fm.liveswitch.BitrateRequest>): void;
        abstract raiseBitrateRequest(bitrateRequest: fm.liveswitch.BitrateRequest): boolean;
        abstract addOnDiscardBitrateNotification(value: fm.liveswitch.IAction1<fm.liveswitch.BitrateNotification>): void;
        abstract removeOnDiscardBitrateNotification(value: fm.liveswitch.IAction1<fm.liveswitch.BitrateNotification>): void;
        abstract raiseBitrateNotification(bitrateNotification: fm.liveswitch.BitrateNotification): boolean;
        abstract getMaxSendBitrate(): number;
        abstract setMaxSendBitrate(value: number): void;
        abstract getMaxReceiveBitrate(): number;
        abstract setMaxReceiveBitrate(value: number): void;
        abstract getRemoteMuted(): boolean;
        abstract setRemoteMuted(value: boolean): void;
        abstract getLocalMuted(): boolean;
        abstract setLocalMuted(value: boolean): void;
        constructor(localTrack: TTrack, remoteTrack: TTrack);
    }
}
declare namespace fm.liveswitch {
    /**
    An interface for COM usage.
    */
    interface IPluginAudioStream {
        ChangeDirection(newDirection: number): string;
        GetCodecDisabled(name: string): boolean;
        GetControlTransportInfo(): string;
        GetDirection(): number;
        GetExternalId(): string;
        GetG722Disabled(): boolean;
        GetHandle(): number;
        GetId(): string;
        GetInfo(): string;
        GetInputMuted(): boolean;
        GetLabel(): string;
        GetLocalBandwidth(): number;
        GetLocalCanonicalName(): string;
        GetLocalDirection(): number;
        GetLocalReceive(): boolean;
        GetLocalSend(): boolean;
        GetMaxReceiveBitrate(): number;
        GetMaxSendBitrate(): number;
        GetMediaDescriptionId(): string;
        GetOpusDisabled(): boolean;
        GetOutputMuted(): boolean;
        GetPcmaDisabled(): boolean;
        GetPcmuDisabled(): boolean;
        GetPreferredCodecs(): string[];
        GetRemoteBandwidth(): number;
        GetRemoteCanonicalName(): string;
        GetRemoteDirection(): number;
        GetRemoteEncoding(): string;
        GetRemoteMuted(): boolean;
        GetRemoteReceive(): boolean;
        GetRemoteSend(): boolean;
        GetSimulcastMode(): number;
        GetTag(): string;
        GetTransportInfo(): string;
        Initialize(localMediaHandle: number, remoteMediaHandle: number): void;
        InsertDtmfTone(dtmfToneJson: string): boolean;
        InsertDtmfTones(dtmfTonesJson: string): boolean;
        RaiseBitrateNotification(bitrateNotificationJson: string): boolean;
        RaiseBitrateRequest(bitrateRequestJson: string): boolean;
        SetCodecDisabled(name: string, disabled: boolean): void;
        SetExternalId(externalId: string): void;
        SetG722Disabled(disabled: boolean): void;
        SetInputMuted(muted: boolean): void;
        SetLocalBandwidth(bandwidth: number): void;
        SetLocalDirection(direction: number): void;
        SetLocalReceive(localReceiveEnabled: boolean): void;
        SetLocalSend(localSendEnabled: boolean): void;
        SetMaxReceiveBitrate(bandwidth: number): void;
        SetMaxSendBitrate(bandwidth: number): void;
        SetOnDirectionChange(callback: Object): void;
        SetOnDiscardBitrateNotification(callback: Object): void;
        SetOnDiscardBitrateRequest(callback: Object): void;
        SetOnLocalEncodingDisabled(callback: Object): void;
        SetOnLocalEncodingEnabled(callback: Object): void;
        SetOnReceiveDtmfTone(callback: Object): void;
        SetOnReceiveDtmfToneChange(callback: Object): void;
        SetOnSendDtmfTone(callback: Object): void;
        SetOnSendDtmfToneChange(callback: Object): void;
        SetOnStateChange(callback: Object): void;
        SetOpusDisabled(disabled: boolean): void;
        SetOutputMuted(muted: boolean): void;
        SetPcmaDisabled(disabled: boolean): void;
        SetPcmuDisabled(disabled: boolean): void;
        SetPreferredCodecs(names: string[]): void;
        SetRemoteEncoding(remoteEncodingJson: string): void;
        SetRemoteMuted(value: boolean): void;
        SetSimulcastMode(simulcastMode: number): void;
        SetTag(tag: string): void;
    }
}
declare namespace fm.liveswitch.dtmf {
    /**
    A DTMF (telephone-event) tone.
    */
    class Tone {
        getTypeString(): string;
        /** @hidden */
        private _duration;
        /** @hidden */
        private _end;
        /** @hidden */
        private _sentDuration;
        /** @hidden */
        private _value;
        private fmliveswitchdtmfToneInit;
        constructor();
        /**
        Initializes a new instance of the [[fm.liveswitch.dtmf.tone]] class.
        @param value The value.
        */
        constructor(value: string);
        /**
        Initializes a new instance of the [[fm.liveswitch.dtmf.tone]] class.
        @param value The value.
        @param duration The duration.
        */
        constructor(value: string, duration: number);
        /** @hidden */
        private static eventCodeFromValue;
        /**
        Deserializes from JSON.
        @param toneJson The JSON.
        */
        static fromJson(toneJson: string): fm.liveswitch.dtmf.Tone;
        /**
        Deserializes an array from JSON.
        @param tonesJson The JSON.
        */
        static fromJsonArray(tonesJson: string): fm.liveswitch.dtmf.Tone[];
        /**
        Converts a DTMF tone string into an array of tones. Each tone will have a duration of 100ms and an inter-tone gap of 100ms.
        @param toneString The tone string.
        */
        static fromToneString(toneString: string): fm.liveswitch.dtmf.Tone[];
        /**
        Converts a DTMF tone string into an array of tones. Each tone will have an inter-tone gap of 100ms.
        @param toneString The tone string.
        @param duration The duration, in milliseconds (minimum of 40, maximum of 2,000).
        */
        static fromToneString(toneString: string, duration: number): fm.liveswitch.dtmf.Tone[];
        /**
        Converts a DTMF tone string into an array of tones.
        @param toneString The tone string.
        @param duration The duration, in milliseconds (minimum of 40, maximum of 2,000).
        @param interToneGap The time between tones, in milliseconds (minimum of 40).
        */
        static fromToneString(toneString: string, duration: number, interToneGap: number): fm.liveswitch.dtmf.Tone[];
        /**
        Gets A tone.
        */
        static getA(): fm.liveswitch.dtmf.Tone;
        /**
        Gets the A value ("A").
        */
        static getAValue(): string;
        /**
        Gets the B tone.
        */
        static getB(): fm.liveswitch.dtmf.Tone;
        /**
        Gets the B value ("B").
        */
        static getBValue(): string;
        /**
        Gets the C tone.
        */
        static getC(): fm.liveswitch.dtmf.Tone;
        /**
        Gets the C value ("C").
        */
        static getCValue(): string;
        /**
        Gets the D tone.
        */
        static getD(): fm.liveswitch.dtmf.Tone;
        /**
        Gets the D value ("D").
        */
        static getDValue(): string;
        /**
        Gets the eight tone.
        */
        static getEight(): fm.liveswitch.dtmf.Tone;
        /**
        Gets the eight value ("8").
        */
        static getEightValue(): string;
        /**
        Gets the empty tone.
        */
        static getEmpty(): fm.liveswitch.dtmf.Tone;
        /**
        Gets the empty value ("").
        */
        static getEmptyValue(): string;
        /**
        Gets the five tone.
        */
        static getFive(): fm.liveswitch.dtmf.Tone;
        /**
        Gets the five value ("5").
        */
        static getFiveValue(): string;
        /**
        Gets the four tone.
        */
        static getFour(): fm.liveswitch.dtmf.Tone;
        /**
        Gets the four value ("4").
        */
        static getFourValue(): string;
        /**
        Gets the hash tone.
        */
        static getHash(): fm.liveswitch.dtmf.Tone;
        /**
        Gets the hash value ("#").
        */
        static getHashValue(): string;
        /**
        Gets the nine tone.
        */
        static getNine(): fm.liveswitch.dtmf.Tone;
        /**
        Gets the nine value ("9").
        */
        static getNineValue(): string;
        /**
        Gets the one tone.
        */
        static getOne(): fm.liveswitch.dtmf.Tone;
        /**
        Gets the one value ("1").
        */
        static getOneValue(): string;
        /**
        Gets the pause tone.
        */
        static getPause(): fm.liveswitch.dtmf.Tone;
        /**
        Gets the pause duration in milliseconds (2000).
        */
        static getPauseDuration(): number;
        /**
        Gets the pause value (",").
        */
        static getPauseValue(): string;
        /**
        Gets the seven tone.
        */
        static getSeven(): fm.liveswitch.dtmf.Tone;
        /**
        Gets the seven value ("7").
        */
        static getSevenValue(): string;
        /**
        Gets the six tone.
        */
        static getSix(): fm.liveswitch.dtmf.Tone;
        /**
        Gets the six value ("6").
        */
        static getSixValue(): string;
        /**
        Gets the star tone.
        */
        static getStar(): fm.liveswitch.dtmf.Tone;
        /**
        Gets the star value ("*").
        */
        static getStarValue(): string;
        /**
        Gets the three tone.
        */
        static getThree(): fm.liveswitch.dtmf.Tone;
        /**
        Gets the three value ("3").
        */
        static getThreeValue(): string;
        /**
        Gets the two tone.
        */
        static getTwo(): fm.liveswitch.dtmf.Tone;
        /**
        Gets the two value ("2").
        */
        static getTwoValue(): string;
        /**
        Gets the zero tone.
        */
        static getZero(): fm.liveswitch.dtmf.Tone;
        /**
        Gets the zero value ("0").
        */
        static getZeroValue(): string;
        /**
        Serializes to JSON.
        */
        static toJson(tone: fm.liveswitch.dtmf.Tone): string;
        /**
        Serializes an array to JSON.
        @param tones The array.
        */
        static toJsonArray(tones: fm.liveswitch.dtmf.Tone[]): string;
        /**
        Converts an array of DTMF tones into a tone string. This discards duration and inter-tone gap data.
        @param tones The tones.
        */
        static toToneString(tones: fm.liveswitch.dtmf.Tone[]): string;
        /** @hidden */
        private static valueFromEventCode;
        /**
        Clones this instance.
        */
        clone(): fm.liveswitch.dtmf.Tone;
        /**
        Clones this instance.
        @param duration The new duration.
        */
        clone(duration: number): fm.liveswitch.dtmf.Tone;
        /**
        Gets the duration in milliseconds.
        */
        getDuration(): number;
        /**
        Gets whether this is the final tone raised for the current value.
        */
        getEnd(): boolean;
        /** @hidden */
        getSentDuration(): number;
        /**
        Gets the value.
        */
        getValue(): string;
        /** @hidden */
        setDuration(value: number): void;
        /** @hidden */
        private setEnd;
        /** @hidden */
        setSentDuration(value: number): void;
        /** @hidden */
        private setValue;
        /**
        Serializes to JSON.
        */
        toJson(): string;
        /**
        Serializes to a string.
        */
        toString(): string;
    }
}
declare namespace fm.liveswitch {
    class PluginAudioStream extends fm.liveswitch.PluginMediaStream<fm.liveswitch.PluginAudioTrack> implements fm.liveswitch.IAudioStream, fm.liveswitch.IInternalAudioStream {
        getTypeString(): string;
        private _state;
        constructor(external: fm.liveswitch.IExternalAudioStream, localTrack: fm.liveswitch.PluginAudioTrack, remoteTrack: fm.liveswitch.PluginAudioTrack);
        getState(): fm.liveswitch.StreamState;
        addOnStateChange(value: fm.liveswitch.IAction0): void;
        removeOnStateChange(value: fm.liveswitch.IAction0): void;
        getInfo(): fm.liveswitch.MediaStreamInfo;
        getLocalReceive(): boolean;
        getLocalSend(): boolean;
        getRemoteReceive(): boolean;
        getRemoteSend(): boolean;
        setLocalReceive(value: boolean): void;
        setLocalSend(value: boolean): void;
        getRemoteDirection(): fm.liveswitch.StreamDirection;
        getHandle(): number;
        changeDirection(newDirection: fm.liveswitch.StreamDirection): fm.liveswitch.Error;
        getDirection(): fm.liveswitch.StreamDirection;
        getId(): string;
        getExternalId(): string;
        setExternalId(value: string): void;
        getLabel(): string;
        getLocalBandwidth(): number;
        getLocalDirection(): fm.liveswitch.StreamDirection;
        getLocalMuted(): boolean;
        setLocalMuted(value: boolean): void;
        getRemoteMuted(): boolean;
        setRemoteMuted(value: boolean): void;
        getInputMuted(): boolean;
        getLocalCanonicalName(): string;
        getOutputMuted(): boolean;
        getMediaDescriptionId(): string;
        getRemoteCanonicalName(): string;
        getRemoteBandwidth(): number;
        getTag(): string;
        getType(): fm.liveswitch.StreamType;
        setLocalDirection(value: fm.liveswitch.StreamDirection): void;
        setLocalBandwidth(value: number): void;
        setInputMuted(value: boolean): void;
        setOutputMuted(value: boolean): void;
        setTag(value: string): void;
        addOnDirectionChange(value: fm.liveswitch.IAction0): void;
        removeOnDirectionChange(value: fm.liveswitch.IAction0): void;
        addOnReceiveDtmfTone(value: fm.liveswitch.IAction1<fm.liveswitch.dtmf.Tone>): void;
        addOnReceiveDtmfToneChange(value: fm.liveswitch.IAction1<fm.liveswitch.dtmf.Tone>): void;
        addOnSendDtmfTone(value: fm.liveswitch.IAction1<fm.liveswitch.dtmf.Tone>): void;
        addOnSendDtmfToneChange(value: fm.liveswitch.IAction1<fm.liveswitch.dtmf.Tone>): void;
        insertDtmfTone(dtmfTone: fm.liveswitch.dtmf.Tone): boolean;
        insertDtmfTones(dtmfTones: fm.liveswitch.dtmf.Tone[]): boolean;
        removeOnReceiveDtmfTone(value: fm.liveswitch.IAction1<fm.liveswitch.dtmf.Tone>): void;
        removeOnReceiveDtmfToneChange(value: fm.liveswitch.IAction1<fm.liveswitch.dtmf.Tone>): void;
        removeOnSendDtmfTone(value: fm.liveswitch.IAction1<fm.liveswitch.dtmf.Tone>): void;
        removeOnSendDtmfToneChange(value: fm.liveswitch.IAction1<fm.liveswitch.dtmf.Tone>): void;
        getPreferredCodecs(): string[];
        setPreferredCodecs(names: string[]): void;
        getCodecDisabled(name: string): boolean;
        setCodecDisabled(name: string, disabled: boolean): void;
        getOpusDisabled(): boolean;
        getG722Disabled(): boolean;
        getPcmuDisabled(): boolean;
        getPcmaDisabled(): boolean;
        setOpusDisabled(value: boolean): void;
        setG722Disabled(value: boolean): void;
        setPcmuDisabled(value: boolean): void;
        setPcmaDisabled(value: boolean): void;
        getRemoteEncoding(): fm.liveswitch.EncodingInfo;
        setRemoteEncoding(value: fm.liveswitch.EncodingInfo): void;
        getSimulcastMode(): fm.liveswitch.SimulcastMode;
        setSimulcastMode(value: fm.liveswitch.SimulcastMode): void;
        getTransportInfo(): fm.liveswitch.TransportInfo;
        getControlTransportInfo(): fm.liveswitch.TransportInfo;
        addOnLocalEncodingDisabled(value: fm.liveswitch.IAction1<fm.liveswitch.EncodingInfo>): void;
        addOnLocalEncodingEnabled(value: fm.liveswitch.IAction1<fm.liveswitch.EncodingInfo>): void;
        removeOnLocalEncodingDisabled(value: fm.liveswitch.IAction1<fm.liveswitch.EncodingInfo>): void;
        removeOnLocalEncodingEnabled(value: fm.liveswitch.IAction1<fm.liveswitch.EncodingInfo>): void;
        addOnDiscardBitrateRequest(value: fm.liveswitch.IAction1<fm.liveswitch.BitrateRequest>): void;
        removeOnDiscardBitrateRequest(value: fm.liveswitch.IAction1<fm.liveswitch.BitrateRequest>): void;
        raiseBitrateRequest(bitrateRequest: fm.liveswitch.BitrateRequest): boolean;
        addOnDiscardBitrateNotification(value: fm.liveswitch.IAction1<fm.liveswitch.BitrateNotification>): void;
        removeOnDiscardBitrateNotification(value: fm.liveswitch.IAction1<fm.liveswitch.BitrateNotification>): void;
        raiseBitrateNotification(bitrateNotification: fm.liveswitch.BitrateNotification): boolean;
        getMaxSendBitrate(): number;
        setMaxSendBitrate(value: number): void;
        getMaxReceiveBitrate(): number;
        setMaxReceiveBitrate(value: number): void;
    }
}
declare namespace fm.liveswitch {
    abstract class PluginMediaTrack extends fm.liveswitch.Dynamic implements fm.liveswitch.IMediaTrack, fm.liveswitch.IInternalMediaTrack {
        getTypeString(): string;
        getMedia(): fm.liveswitch.PluginMedia;
        constructor(media: fm.liveswitch.PluginMedia);
        abstract changeSinkOutput(sinkOutput: fm.liveswitch.SinkOutput): fm.liveswitch.Future<Object>;
        abstract changeSourceInput(sourceInput: fm.liveswitch.SourceInput): fm.liveswitch.Future<Object>;
        destroy(): boolean;
        abstract addOnStarted(value: fm.liveswitch.IAction0): void;
        abstract addOnStopped(value: fm.liveswitch.IAction0): void;
        abstract addOnDestroyed(value: fm.liveswitch.IAction0): void;
        abstract removeOnStarted(value: fm.liveswitch.IAction0): void;
        abstract removeOnStopped(value: fm.liveswitch.IAction0): void;
        abstract removeOnDestroyed(value: fm.liveswitch.IAction0): void;
        abstract getMuted(): boolean;
        abstract getSinkOutput(): fm.liveswitch.SinkOutput;
        abstract getSinkOutputs(): fm.liveswitch.Future<fm.liveswitch.SinkOutput[]>;
        abstract getSourceInput(): fm.liveswitch.SourceInput;
        abstract getSourceInputs(): fm.liveswitch.Future<fm.liveswitch.SourceInput[]>;
        abstract setMuted(value: boolean): void;
        abstract setSinkOutput(value: fm.liveswitch.SinkOutput): void;
        abstract setSourceInput(value: fm.liveswitch.SourceInput): void;
    }
}
declare namespace fm.liveswitch {
    class PluginAudioTrack extends fm.liveswitch.PluginMediaTrack implements fm.liveswitch.IAudioTrack, fm.liveswitch.IInternalAudioTrack {
        getTypeString(): string;
        constructor(external: fm.liveswitch.IExternalAudioTrack, media: fm.liveswitch.PluginMedia);
        private isLocal;
        addOnStarted(value: fm.liveswitch.IAction0): void;
        addOnStopped(value: fm.liveswitch.IAction0): void;
        addOnDestroyed(value: fm.liveswitch.IAction0): void;
        removeOnStarted(value: fm.liveswitch.IAction0): void;
        removeOnStopped(value: fm.liveswitch.IAction0): void;
        removeOnDestroyed(value: fm.liveswitch.IAction0): void;
        changeSinkOutput(sinkOutput: fm.liveswitch.SinkOutput): fm.liveswitch.Future<Object>;
        getSinkOutput(): fm.liveswitch.SinkOutput;
        getSinkOutputs(): fm.liveswitch.Future<fm.liveswitch.SinkOutput[]>;
        setSinkOutput(value: fm.liveswitch.SinkOutput): void;
        changeSourceInput(sourceInput: fm.liveswitch.SourceInput): fm.liveswitch.Future<Object>;
        getSourceInput(): fm.liveswitch.SourceInput;
        getSourceInputs(): fm.liveswitch.Future<fm.liveswitch.SourceInput[]>;
        setSourceInput(value: fm.liveswitch.SourceInput): void;
        addOnLevel(value: fm.liveswitch.IAction1<number>): void;
        getGain(): number;
        getMuted(): boolean;
        getVolume(): number;
        removeOnLevel(value: fm.liveswitch.IAction1<number>): void;
        setGain(value: number): void;
        setMuted(value: boolean): void;
        setVolume(value: number): void;
    }
}
declare namespace fm.liveswitch {
    class PluginConfig {
        private _activeXPath;
        private _activeXTimeout;
        private _preferActiveX;
        getActiveXPath(): string;
        setActiveXPath(activeXPath: string): void;
        getActiveXTimeout(): number;
        setActiveXTimeout(activeXTimeout: number): void;
        getPreferActiveX(): boolean;
        setPreferActiveX(preferActiveX: boolean): void;
    }
}
declare namespace fm.liveswitch {
    /**
    An interface for COM usage.
    */
    interface IPluginConnection {
        AddIceServer(iceServer: string): void;
        AddIceServers(iceServers: string): void;
        AddRemoteCandidate(remoteCandidate: string, promise: Object): void;
        Close(): boolean;
        CreateAnswer(promise: Object): void;
        CreateOffer(promise: Object): void;
        GetBundlePolicy(): number;
        GetCanonicalName(): string;
        GetDeadStreamTimeout(): number;
        GetError(): string;
        GetExternalId(): string;
        GetHandle(): number;
        GetIceGatherPolicy(): number;
        GetIceServer(): string;
        GetIceServers(): string;
        GetId(): string;
        GetLegacyTimeout(): boolean;
        GetLocalDescription(): string;
        GetRemoteDescription(): string;
        GetStats(promise: Object): void;
        GetTieBreaker(): string;
        GetTimeout(): number;
        GetTrickleIcePolicy(): number;
        Initialize(streamPtrs: Object): void;
        RemoveIceServer(iceServer: string): void;
        RemoveIceServers(iceServers: string): void;
        SetBundlePolicy(bundlePolicy: number): void;
        SetDeadStreamTimeout(deadStreamTimeout: number): void;
        SetError(errorJson: string): void;
        SetExternalId(externalId: string): void;
        SetIceGatherPolicy(iceGatherPolicy: number): void;
        SetIceServer(iceServer: string): void;
        SetIceServers(iceServers: string): void;
        SetLegacyTimeout(value: boolean): void;
        SetLocalDescription(localDescription: string, promise: Object): void;
        SetOnExternalIdChange(callback: Object): void;
        SetOnGatheringStateChange(callback: Object): void;
        SetOnIceConnectionStateChange(callback: Object): void;
        SetOnLocalCandidate(callback: Object): void;
        SetOnLocalDescription(callback: Object): void;
        SetOnRemoteCandidate(callback: Object): void;
        SetOnRemoteDescription(callback: Object): void;
        SetOnSignallingStateChange(callback: Object): void;
        SetOnStateChange(callback: Object): void;
        SetRemoteDescription(remoteDescription: string, promise: Object): void;
        SetTieBreaker(tieBreaker: string): void;
        SetTimeout(timeout: number): void;
        SetTrickleIcePolicy(trickleIcePolicy: number): void;
    }
}
declare namespace fm.liveswitch {
    class PluginConnection extends fm.liveswitch.Dynamic implements fm.liveswitch.IConnection<fm.liveswitch.PluginConnection, fm.liveswitch.PluginStream, fm.liveswitch.PluginAudioStream, fm.liveswitch.PluginVideoStream, fm.liveswitch.PluginDataStream>, fm.liveswitch.IInternalConnection {
        getTypeString(): string;
        private _gatheringState;
        private _iceConnectionState;
        private _signallingState;
        private _state;
        constructor(external: fm.liveswitch.IExternalConnection, streams: fm.liveswitch.PluginStream[]);
        addIceServer(iceServer: fm.liveswitch.IceServer): void;
        addIceServers(iceServers: fm.liveswitch.IceServer[]): void;
        addOnLocalCandidate(value: fm.liveswitch.IAction2<fm.liveswitch.PluginConnection, fm.liveswitch.Candidate>): void;
        addOnExternalIdChange(value: fm.liveswitch.IAction2<string, string>): void;
        addOnIceConnectionStateChange(value: fm.liveswitch.IAction1<fm.liveswitch.PluginConnection>): void;
        addOnGatheringStateChange(value: fm.liveswitch.IAction1<fm.liveswitch.PluginConnection>): void;
        addOnLocalDescription(value: fm.liveswitch.IAction2<fm.liveswitch.PluginConnection, fm.liveswitch.SessionDescription>): void;
        addOnRemoteCandidate(value: fm.liveswitch.IAction2<fm.liveswitch.PluginConnection, fm.liveswitch.Candidate>): void;
        addOnRemoteDescription(value: fm.liveswitch.IAction2<fm.liveswitch.PluginConnection, fm.liveswitch.SessionDescription>): void;
        addOnSignallingStateChange(value: fm.liveswitch.IAction1<fm.liveswitch.PluginConnection>): void;
        addOnStateChange(value: fm.liveswitch.IAction1<fm.liveswitch.PluginConnection>): void;
        addRemoteCandidate(remoteCandidate: fm.liveswitch.Candidate): fm.liveswitch.Future<fm.liveswitch.Candidate>;
        close(): boolean;
        createAnswer(): fm.liveswitch.Future<fm.liveswitch.SessionDescription>;
        createOffer(): fm.liveswitch.Future<fm.liveswitch.SessionDescription>;
        getHasAudio(): boolean;
        getHasVideo(): boolean;
        getHasData(): boolean;
        getAudioStream(): fm.liveswitch.PluginAudioStream;
        getAudioStreams(): fm.liveswitch.PluginAudioStream[];
        getVideoStream(): fm.liveswitch.PluginVideoStream;
        getVideoStreams(): fm.liveswitch.PluginVideoStream[];
        getDataStream(): fm.liveswitch.PluginDataStream;
        getDataStreams(): fm.liveswitch.PluginDataStream[];
        getDeadStreamTimeout(): number;
        getExternalId(): string;
        getError(): fm.liveswitch.Error;
        getIceGatherPolicy(): fm.liveswitch.IceGatherPolicy;
        getBundlePolicy(): fm.liveswitch.BundlePolicy;
        getIceServer(): fm.liveswitch.IceServer;
        getIceServers(): fm.liveswitch.IceServer[];
        getId(): string;
        getCanonicalName(): string;
        getLocalDescription(): fm.liveswitch.SessionDescription;
        getRemoteDescription(): fm.liveswitch.SessionDescription;
        getSignallingState(): fm.liveswitch.SignallingState;
        getState(): fm.liveswitch.ConnectionState;
        getStats(): fm.liveswitch.Future<fm.liveswitch.ConnectionStats>;
        getStreams(): fm.liveswitch.PluginStream[];
        getTieBreaker(): string;
        getTimeout(): number;
        getLegacyTimeout(): boolean;
        getTrickleIcePolicy(): fm.liveswitch.TrickleIcePolicy;
        getIceConnectionState(): fm.liveswitch.IceConnectionState;
        getGatheringState(): fm.liveswitch.IceGatheringState;
        removeIceServer(iceServer: fm.liveswitch.IceServer): void;
        removeIceServers(iceServers: fm.liveswitch.IceServer[]): void;
        removeOnLocalCandidate(value: fm.liveswitch.IAction2<fm.liveswitch.PluginConnection, fm.liveswitch.Candidate>): void;
        removeOnIceConnectionStateChange(value: fm.liveswitch.IAction1<fm.liveswitch.PluginConnection>): void;
        removeOnExternalIdChange(value: fm.liveswitch.IAction2<string, string>): void;
        removeOnGatheringStateChange(value: fm.liveswitch.IAction1<fm.liveswitch.PluginConnection>): void;
        removeOnLocalDescription(value: fm.liveswitch.IAction2<fm.liveswitch.PluginConnection, fm.liveswitch.SessionDescription>): void;
        removeOnRemoteCandidate(value: fm.liveswitch.IAction2<fm.liveswitch.PluginConnection, fm.liveswitch.Candidate>): void;
        removeOnRemoteDescription(value: fm.liveswitch.IAction2<fm.liveswitch.PluginConnection, fm.liveswitch.SessionDescription>): void;
        removeOnSignallingStateChange(value: fm.liveswitch.IAction1<fm.liveswitch.PluginConnection>): void;
        removeOnStateChange(value: fm.liveswitch.IAction1<fm.liveswitch.PluginConnection>): void;
        setDeadStreamTimeout(value: number): void;
        setExternalId(value: string): void;
        setError(value: fm.liveswitch.Error): void;
        setIceGatherPolicy(value: fm.liveswitch.IceGatherPolicy): void;
        setBundlePolicy(value: fm.liveswitch.BundlePolicy): void;
        setIceServer(value: fm.liveswitch.IceServer): void;
        setIceServers(value: fm.liveswitch.IceServer[]): void;
        setLegacyTimeout(value: boolean): void;
        setTieBreaker(value: string): void;
        setLocalDescription(localDescription: fm.liveswitch.SessionDescription): fm.liveswitch.Future<fm.liveswitch.SessionDescription>;
        setRemoteDescription(remoteDescription: fm.liveswitch.SessionDescription): fm.liveswitch.Future<fm.liveswitch.SessionDescription>;
        setTimeout(value: number): void;
        setTrickleIcePolicy(value: fm.liveswitch.TrickleIcePolicy): void;
    }
}
declare namespace fm.liveswitch {
    /**
    An interface for COM usage.
    */
    interface IPluginDataChannel {
        GetHandle(): number;
        GetId(): string;
        GetInfo(): string;
        GetLabel(): string;
        GetOrdered(): boolean;
        GetSubprotocol(): string;
        Initialize(label: string, ordered: boolean, subprotocol: string): void;
        PrepareAndSendBytes(data: string, promise: Object): void;
        PrepareAndSendString(dataString: string, promise: Object): void;
        SetOnReceive(callback: Object): void;
        SetOnStateChange(callback: Object): void;
    }
}
declare namespace fm.liveswitch {
    class PluginDataChannel extends fm.liveswitch.Dynamic implements fm.liveswitch.IDataChannel<fm.liveswitch.PluginDataChannel>, fm.liveswitch.IInternalDataChannel {
        getTypeString(): string;
        getHandle(): number;
        private _state;
        constructor(external: fm.liveswitch.IExternalDataChannel, label: string, ordered?: boolean, subprotocol?: string);
        private _getRemoteConnectionInfo;
        setGetRemoteConnectionInfo(value: fm.liveswitch.IFunction1<string, any>): void;
        getInfo(): fm.liveswitch.DataChannelInfo;
        addOnStateChange(value: fm.liveswitch.IAction1<fm.liveswitch.PluginDataChannel>): void;
        getLabel(): string;
        getOnReceive(): fm.liveswitch.IAction1<fm.liveswitch.DataChannelReceiveArgs>;
        getOrdered(): boolean;
        getId(): string;
        getState(): fm.liveswitch.DataChannelState;
        getSubprotocol(): string;
        removeOnStateChange(value: fm.liveswitch.IAction1<fm.liveswitch.PluginDataChannel>): void;
        sendDataBytes(dataBytes: fm.liveswitch.DataBuffer): fm.liveswitch.Future<Object>;
        sendDataString(dataString: string): fm.liveswitch.Future<Object>;
        setOnReceive(value: fm.liveswitch.IAction1<fm.liveswitch.DataChannelReceiveArgs>): void;
    }
}
declare namespace fm.liveswitch {
    /**
    An interface for COM usage.
    */
    interface IPluginDataStream {
        ChangeDirection(newDirection: number): string;
        GetDirection(): number;
        GetExternalId(): string;
        GetHandle(): number;
        GetId(): string;
        GetInfo(): string;
        GetLabel(): string;
        GetLocalDirection(): number;
        GetLocalReceive(): boolean;
        GetLocalSend(): boolean;
        GetMediaDescriptionId(): string;
        GetRemoteDirection(): number;
        GetRemoteReceive(): boolean;
        GetRemoteSend(): boolean;
        GetTag(): string;
        GetTransportInfo(): string;
        Initialize(channelHandles: Object): void;
        SetExternalId(externalId: string): void;
        SetLocalDirection(direction: number): void;
        SetLocalReceive(localReceiveEnabled: boolean): void;
        SetLocalSend(localSendEnabled: boolean): void;
        SetOnDirectionChange(callback: Object): void;
        SetOnStateChange(callback: Object): void;
        SetTag(tag: string): void;
    }
}
declare namespace fm.liveswitch {
    class PluginDataStream extends fm.liveswitch.PluginStream implements fm.liveswitch.IDataStream<fm.liveswitch.PluginDataChannel>, fm.liveswitch.IInternalDataStream {
        getTypeString(): string;
        private _state;
        constructor(external: fm.liveswitch.IExternalDataStream, channels: fm.liveswitch.PluginDataChannel[]);
        getState(): fm.liveswitch.StreamState;
        addOnStateChange(value: fm.liveswitch.IAction0): void;
        removeOnStateChange(value: fm.liveswitch.IAction0): void;
        getInfo(): fm.liveswitch.DataStreamInfo;
        getLocalReceive(): boolean;
        getLocalSend(): boolean;
        getRemoteReceive(): boolean;
        getRemoteSend(): boolean;
        setLocalReceive(value: boolean): void;
        setLocalSend(value: boolean): void;
        getRemoteDirection(): fm.liveswitch.StreamDirection;
        getHandle(): number;
        changeDirection(newDirection: fm.liveswitch.StreamDirection): fm.liveswitch.Error;
        getDirection(): fm.liveswitch.StreamDirection;
        getId(): string;
        getExternalId(): string;
        setExternalId(value: string): void;
        getLabel(): string;
        getLocalDirection(): fm.liveswitch.StreamDirection;
        getMediaDescriptionId(): string;
        getTag(): string;
        getType(): fm.liveswitch.StreamType;
        setLocalDirection(value: fm.liveswitch.StreamDirection): void;
        setTag(value: string): void;
        addOnDirectionChange(callback: Object): void;
        removeOnDirectionChange(callback: Object): void;
        getChannels(): fm.liveswitch.PluginDataChannel[];
        getTransportInfo(): fm.liveswitch.TransportInfo;
    }
}
declare namespace fm.liveswitch {
    class PluginDomAudioSink extends fm.liveswitch.Dynamic implements fm.liveswitch.IInternalDomAudioSink {
        getTypeString(): string;
        getTrack(): fm.liveswitch.PluginAudioTrack;
        getLocal(): boolean;
        getAudio(): HTMLAudioElement;
        constructor(external: fm.liveswitch.DomAudioSink, track: fm.liveswitch.PluginAudioTrack);
        setTrack(track: fm.liveswitch.PluginAudioTrack): boolean;
    }
}
declare namespace fm.liveswitch {
    class PluginDomVideoSink extends fm.liveswitch.Dynamic implements fm.liveswitch.IInternalDomVideoSink {
        getTypeString(): string;
        getTrack(): fm.liveswitch.PluginVideoTrack;
        getLocal(): boolean;
        getVideo(): HTMLVideoElement;
        getView(): HTMLElement;
        getViewScale(): fm.liveswitch.LayoutScale;
        setViewScale(viewScale: fm.liveswitch.LayoutScale): void;
        getVideoWidth(): number;
        getVideoHeight(): number;
        getViewMirror(): boolean;
        setViewMirror(viewMirror: boolean): void;
        constructor(external: fm.liveswitch.IExternalDomVideoSink, track: fm.liveswitch.PluginVideoTrack);
        setTrack(track: fm.liveswitch.PluginVideoTrack): boolean;
        private checkifLoaded;
    }
}
declare namespace fm.liveswitch {
    abstract class PluginMedia extends fm.liveswitch.Dynamic implements fm.liveswitch.IMedia<fm.liveswitch.PluginAudioTrack, fm.liveswitch.PluginVideoTrack>, fm.liveswitch.IInternalMedia {
        getTypeString(): string;
        getHandle(): number;
        abstract addOnAudioDestroyed(value: fm.liveswitch.IAction0): void;
        abstract addOnVideoDestroyed(value: fm.liveswitch.IAction0): void;
        abstract removeOnAudioDestroyed(value: fm.liveswitch.IAction0): void;
        abstract removeOnVideoDestroyed(value: fm.liveswitch.IAction0): void;
        destroy(): void;
        addOnAudioLevel(value: fm.liveswitch.IAction1<number>): void;
        addOnVideoSize(value: fm.liveswitch.IAction1<fm.liveswitch.Size>): void;
        getAudioGain(): number;
        getAudioMuted(): boolean;
        getAudioTrack(): fm.liveswitch.PluginAudioTrack;
        getAudioTracks(): fm.liveswitch.PluginAudioTrack[];
        getAudioVolume(): number;
        getId(): string;
        getVideoMuted(): boolean;
        getVideoSize(): fm.liveswitch.Size;
        getVideoTrack(): fm.liveswitch.PluginVideoTrack;
        getVideoTracks(): fm.liveswitch.PluginVideoTrack[];
        grabVideoFrame(): fm.liveswitch.Future<fm.liveswitch.VideoBuffer>;
        removeOnAudioLevel(value: fm.liveswitch.IAction1<number>): void;
        removeOnVideoSize(value: fm.liveswitch.IAction1<fm.liveswitch.Size>): void;
        setAudioGain(value: number): void;
        setAudioMuted(value: boolean): void;
        setAudioVolume(value: number): void;
        setId(value: string): void;
        setVideoMuted(value: boolean): void;
        getAudioSink(): fm.liveswitch.PluginDomAudioSink;
        getVideoSink(): fm.liveswitch.PluginDomVideoSink;
        getView(): HTMLElement;
        getViewSink(): fm.liveswitch.PluginDomVideoSink;
        getAudio(): any;
        setAudio(audio: any): void;
        getVideo(): any;
        setVideo(video: any): void;
        protected _videoSink: fm.liveswitch.PluginDomVideoSink;
        constructor(external: fm.liveswitch.IExternalMedia);
    }
}
declare namespace fm.liveswitch {
    /**
    An interface for COM usage.
    */
    interface IPluginLocalMedia {
        AttachView(viewHandle: number): void;
        ChangeAudioSourceInput(promise: Object, audioSourceInput: string): void;
        ChangeVideoSourceInput(promise: Object, videoSourceInput: string): void;
        Destroy(): void;
        GetAudioEncoding(): string;
        GetAudioEncodings(): string;
        GetAudioGain(): number;
        GetAudioMuted(): boolean;
        GetAudioSimulcastDisabled(): boolean;
        GetAudioSimulcastEncodingCount(): number;
        GetAudioSimulcastPreferredBitrate(): number;
        GetAudioSourceInput(): string;
        GetAudioSourceInputs(promise: Object): void;
        GetAudioVolume(): number;
        GetHandle(): number;
        GetId(): string;
        GetState(): number;
        GetVideoEncoding(): string;
        GetVideoEncodings(): string;
        GetVideoMuted(): boolean;
        GetVideoSimulcastBitsPerPixel(): number;
        GetVideoSimulcastDegradationPreference(): number;
        GetVideoSimulcastDisabled(): boolean;
        GetVideoSimulcastEncodingCount(): number;
        GetVideoSimulcastPreferredBitrate(): number;
        GetVideoSize(): string;
        GetVideoSourceInput(): string;
        GetVideoSourceInputs(promise: Object): void;
        GrabVideoFrame(promise: Object): void;
        Initialize(disableAudio: boolean, disableVideo: boolean, isScreenShare: boolean): void;
        SetAudioEncodings(valueJson: string): void;
        SetAudioGain(gain: number): void;
        SetAudioMuted(muted: boolean): void;
        SetAudioSimulcastDisabled(value: boolean): void;
        SetAudioSimulcastEncodingCount(value: number): void;
        SetAudioSimulcastPreferredBitrate(value: number): void;
        SetAudioSourceInput(value: string): void;
        SetAudioVolume(volume: number): void;
        SetId(idValue: string): void;
        SetOnAudioDestroyed(callback: Object): void;
        SetOnAudioLevel(callback: Object): void;
        SetOnAudioStarted(callback: Object): void;
        SetOnAudioStopped(callback: Object): void;
        SetOnVideoDestroyed(callback: Object): void;
        SetOnVideoSize(callback: Object): void;
        SetOnVideoStarted(callback: Object): void;
        SetOnVideoStopped(callback: Object): void;
        SetVideoEncodings(valueJson: string): void;
        SetVideoMuted(muted: boolean): void;
        SetVideoSimulcastBitsPerPixel(value: number): void;
        SetVideoSimulcastDegradationPreference(value: number): void;
        SetVideoSimulcastDisabled(value: boolean): void;
        SetVideoSimulcastEncodingCount(value: number): void;
        SetVideoSimulcastPreferredBitrate(value: number): void;
        SetVideoSourceInput(value: string): void;
        Start(promise: Object): void;
        Stop(promise: Object): void;
    }
}
declare namespace fm.liveswitch {
    class PluginLocalMedia extends fm.liveswitch.PluginMedia implements fm.liveswitch.ILocalMedia<fm.liveswitch.PluginLocalMedia, fm.liveswitch.PluginAudioTrack, fm.liveswitch.PluginVideoTrack>, fm.liveswitch.IInternalLocalMedia {
        getTypeString(): string;
        getScreen(): boolean;
        setScreen(screen: boolean): void;
        getState(): fm.liveswitch.LocalMediaState;
        constructor(external: fm.liveswitch.IExternalLocalMedia, audio: any, video: any, screen?: boolean);
        start(): fm.liveswitch.Future<fm.liveswitch.PluginLocalMedia>;
        stop(): fm.liveswitch.Future<fm.liveswitch.PluginLocalMedia>;
        getHandle(): number;
        addOnAudioStarted(value: fm.liveswitch.IAction0): void;
        addOnVideoStarted(value: fm.liveswitch.IAction0): void;
        addOnAudioStopped(value: fm.liveswitch.IAction0): void;
        addOnVideoStopped(value: fm.liveswitch.IAction0): void;
        addOnAudioDestroyed(value: fm.liveswitch.IAction0): void;
        addOnVideoDestroyed(value: fm.liveswitch.IAction0): void;
        removeOnAudioStarted(value: fm.liveswitch.IAction0): void;
        removeOnVideoStarted(value: fm.liveswitch.IAction0): void;
        removeOnAudioStopped(value: fm.liveswitch.IAction0): void;
        removeOnVideoStopped(value: fm.liveswitch.IAction0): void;
        removeOnAudioDestroyed(value: fm.liveswitch.IAction0): void;
        removeOnVideoDestroyed(value: fm.liveswitch.IAction0): void;
        getAudioEncoding(): fm.liveswitch.AudioEncodingConfig;
        getAudioEncodings(): fm.liveswitch.AudioEncodingConfig[];
        setAudioEncodings(value: fm.liveswitch.AudioEncodingConfig[]): void;
        getVideoEncoding(): fm.liveswitch.VideoEncodingConfig;
        getVideoEncodings(): fm.liveswitch.VideoEncodingConfig[];
        setVideoEncodings(value: fm.liveswitch.VideoEncodingConfig[]): void;
        changeAudioSourceInput(audioSourceInput: fm.liveswitch.SourceInput): fm.liveswitch.Future<Object>;
        changeVideoSourceInput(videoSourceInput: fm.liveswitch.SourceInput): fm.liveswitch.Future<Object>;
        getAudioSourceInput(): fm.liveswitch.SourceInput;
        getAudioSourceInputs(): fm.liveswitch.Future<fm.liveswitch.SourceInput[]>;
        getVideoSourceInput(): fm.liveswitch.SourceInput;
        getVideoSourceInputs(): fm.liveswitch.Future<fm.liveswitch.SourceInput[]>;
        setAudioSourceInput(value: fm.liveswitch.SourceInput): void;
        setVideoSourceInput(value: fm.liveswitch.SourceInput): void;
        destroy(): void;
        getAudioGain(): number;
        getAudioMuted(): boolean;
        getId(): string;
        getVideoMuted(): boolean;
        setAudioGain(value: number): void;
        setAudioMuted(value: boolean): void;
        setVideoMuted(value: boolean): void;
        getAudioSimulcastDisabled(): boolean;
        setAudioSimulcastDisabled(value: boolean): void;
        getAudioSimulcastEncodingCount(): number;
        setAudioSimulcastEncodingCount(value: number): void;
        getAudioSimulcastPreferredBitrate(): number;
        setAudioSimulcastPreferredBitrate(value: number): void;
        getVideoSimulcastDisabled(): boolean;
        setVideoSimulcastDisabled(value: boolean): void;
        getVideoSimulcastEncodingCount(): number;
        setVideoSimulcastEncodingCount(value: number): void;
        getVideoSimulcastPreferredBitrate(): number;
        setVideoSimulcastPreferredBitrate(value: number): void;
        getVideoSimulcastBitsPerPixel(): number;
        setVideoSimulcastBitsPerPixel(value: number): void;
        getVideoSimulcastDegradationPreference(): fm.liveswitch.VideoDegradationPreference;
        setVideoSimulcastDegradationPreference(value: fm.liveswitch.VideoDegradationPreference): void;
        private checkifLoaded;
    }
}
declare namespace fm.liveswitch {
    /**
    An interface for COM usage.
    */
    interface IPluginRemoteMedia {
        AttachView(viewHandle: number): void;
        ChangeAudioSinkOutput(promise: Object, audioSinkOutput: string): void;
        ChangeVideoSinkOutput(promise: Object, videoSinkOutput: string): void;
        Destroy(): void;
        GetAudioGain(): number;
        GetAudioMuted(): boolean;
        GetAudioSinkOutput(): string;
        GetAudioSinkOutputs(promise: Object): void;
        GetAudioVolume(): number;
        GetHandle(): number;
        GetId(): string;
        GetVideoMuted(): boolean;
        GetVideoSinkOutput(): string;
        GetVideoSinkOutputs(promise: Object): void;
        GetVideoSize(): string;
        GrabVideoFrame(promise: Object): void;
        Initialize(disableAudio: boolean, disableVideo: boolean): void;
        SetAudioGain(gain: number): void;
        SetAudioMuted(muted: boolean): void;
        SetAudioSinkOutput(value: string): void;
        SetAudioVolume(volume: number): void;
        SetId(idValue: string): void;
        SetOnAudioDestroyed(callback: Object): void;
        SetOnAudioLevel(callback: Object): void;
        SetOnVideoDestroyed(callback: Object): void;
        SetOnVideoSize(callback: Object): void;
        SetVideoMuted(muted: boolean): void;
        SetVideoSinkOutput(value: string): void;
    }
}
declare namespace fm.liveswitch {
    class PluginRemoteMedia extends fm.liveswitch.PluginMedia implements fm.liveswitch.IRemoteMedia<fm.liveswitch.PluginAudioTrack, fm.liveswitch.PluginVideoTrack>, fm.liveswitch.IInternalRemoteMedia {
        getTypeString(): string;
        constructor(external: fm.liveswitch.IExternalRemoteMedia, audio: boolean, video: boolean);
        private checkifLoaded;
        getHandle(): number;
        addOnAudioDestroyed(value: fm.liveswitch.IAction0): void;
        addOnVideoDestroyed(value: fm.liveswitch.IAction0): void;
        removeOnAudioDestroyed(value: fm.liveswitch.IAction0): void;
        removeOnVideoDestroyed(value: fm.liveswitch.IAction0): void;
        changeAudioSinkOutput(audioSinkOutput: fm.liveswitch.SinkOutput): fm.liveswitch.Future<Object>;
        changeVideoSinkOutput(videoSinkOutput: fm.liveswitch.SinkOutput): fm.liveswitch.Future<Object>;
        getAudioSinkOutput(): fm.liveswitch.SinkOutput;
        getAudioSinkOutputs(): fm.liveswitch.Future<fm.liveswitch.SinkOutput[]>;
        getVideoSinkOutput(): fm.liveswitch.SinkOutput;
        getVideoSinkOutputs(): fm.liveswitch.Future<fm.liveswitch.SinkOutput[]>;
        setAudioSinkOutput(value: fm.liveswitch.SinkOutput): void;
        setVideoSinkOutput(value: fm.liveswitch.SinkOutput): void;
        destroy(): void;
        getAudioGain(): number;
        getAudioMuted(): boolean;
        getId(): string;
        getVideoMuted(): boolean;
        setAudioGain(value: number): void;
        setAudioMuted(value: boolean): void;
        setVideoMuted(value: boolean): void;
    }
}
declare namespace fm.liveswitch {
    /**
    An interface for COM usage.
    */
    interface IPluginVideoStream {
        ChangeDirection(newDirection: number): string;
        GetCodecDisabled(name: string): boolean;
        GetControlTransportInfo(): string;
        GetDirection(): number;
        GetExternalId(): string;
        GetH264Disabled(): boolean;
        GetH265Disabled(): boolean;
        GetHandle(): number;
        GetId(): string;
        GetInfo(): string;
        GetInputMuted(): boolean;
        GetLabel(): string;
        GetLocalBandwidth(): number;
        GetLocalCanonicalName(): string;
        GetLocalDirection(): number;
        GetLocalReceive(): boolean;
        GetLocalSend(): boolean;
        GetMaxReceiveBitrate(): number;
        GetMaxSendBitrate(): number;
        GetMediaDescriptionId(): string;
        GetOutputMuted(): boolean;
        GetPreferredCodecs(): string[];
        GetRemoteBandwidth(): number;
        GetRemoteCanonicalName(): string;
        GetRemoteDirection(): number;
        GetRemoteEncoding(): string;
        GetRemoteMuted(): boolean;
        GetRemoteReceive(): boolean;
        GetRemoteSend(): boolean;
        GetSimulcastMode(): number;
        GetTag(): string;
        GetTransportInfo(): string;
        GetVp8Disabled(): boolean;
        GetVp9Disabled(): boolean;
        Initialize(localMediaHandle: number, remoteMediaHandle: number): void;
        RaiseBitrateNotification(bitrateNotificationJson: string): boolean;
        RaiseBitrateRequest(bitrateRequestJson: string): boolean;
        RaiseKeyFrameRequest(synchronizationSources: number[]): void;
        SetCodecDisabled(name: string, disabled: boolean): void;
        SetExternalId(externalId: string): void;
        SetH264Disabled(disabled: boolean): void;
        SetH265Disabled(disabled: boolean): void;
        SetInputMuted(muted: boolean): void;
        SetLocalBandwidth(bandwidth: number): void;
        SetLocalDirection(direction: number): void;
        SetLocalReceive(localReceiveEnabled: boolean): void;
        SetLocalSend(localSendEnabled: boolean): void;
        SetMaxReceiveBitrate(bandwidth: number): void;
        SetMaxSendBitrate(bandwidth: number): void;
        SetOnDirectionChange(callback: Object): void;
        SetOnDiscardBitrateNotification(callback: Object): void;
        SetOnDiscardBitrateRequest(callback: Object): void;
        SetOnDiscardKeyFrameRequest(callback: Object): void;
        SetOnLocalEncodingDisabled(callback: Object): void;
        SetOnLocalEncodingEnabled(callback: Object): void;
        SetOnStateChange(callback: Object): void;
        SetOutputMuted(muted: boolean): void;
        SetPreferredCodecs(names: string[]): void;
        SetRemoteEncoding(remoteEncodingJson: string): void;
        SetRemoteMuted(value: boolean): void;
        SetSimulcastMode(simulcastMode: number): void;
        SetTag(tag: string): void;
        SetVp8Disabled(disabled: boolean): void;
        SetVp9Disabled(disabled: boolean): void;
    }
}
declare namespace fm.liveswitch {
    class PluginVideoStream extends fm.liveswitch.PluginMediaStream<fm.liveswitch.PluginVideoTrack> implements fm.liveswitch.IVideoStream, fm.liveswitch.IInternalVideoStream {
        getTypeString(): string;
        private _state;
        constructor(external: fm.liveswitch.IExternalVideoStream, localTrack: fm.liveswitch.PluginVideoTrack, remoteTrack: fm.liveswitch.PluginVideoTrack);
        getState(): fm.liveswitch.StreamState;
        addOnStateChange(value: fm.liveswitch.IAction0): void;
        removeOnStateChange(value: fm.liveswitch.IAction0): void;
        getInfo(): fm.liveswitch.MediaStreamInfo;
        getLocalReceive(): boolean;
        getLocalSend(): boolean;
        getRemoteReceive(): boolean;
        getRemoteSend(): boolean;
        setLocalReceive(value: boolean): void;
        setLocalSend(value: boolean): void;
        getRemoteDirection(): fm.liveswitch.StreamDirection;
        getHandle(): number;
        changeDirection(newDirection: fm.liveswitch.StreamDirection): fm.liveswitch.Error;
        getDirection(): fm.liveswitch.StreamDirection;
        getLocalCanonicalName(): string;
        getRemoteCanonicalName(): string;
        getId(): string;
        getExternalId(): string;
        setExternalId(value: string): void;
        getLabel(): string;
        getLocalBandwidth(): number;
        getLocalDirection(): fm.liveswitch.StreamDirection;
        getLocalMuted(): boolean;
        setLocalMuted(value: boolean): void;
        getRemoteMuted(): boolean;
        setRemoteMuted(value: boolean): void;
        getInputMuted(): boolean;
        getMediaDescriptionId(): string;
        getOutputMuted(): boolean;
        getRemoteBandwidth(): number;
        getTag(): string;
        getType(): fm.liveswitch.StreamType;
        setLocalDirection(value: fm.liveswitch.StreamDirection): void;
        setLocalBandwidth(value: number): void;
        setInputMuted(value: boolean): void;
        setOutputMuted(value: boolean): void;
        setTag(value: string): void;
        addOnDirectionChange(callback: Object): void;
        removeOnDirectionChange(callback: Object): void;
        getPreferredCodecs(): string[];
        setPreferredCodecs(names: string[]): void;
        getCodecDisabled(name: string): boolean;
        setCodecDisabled(name: string, disabled: boolean): void;
        getVp8Disabled(): boolean;
        getVp9Disabled(): boolean;
        getH264Disabled(): boolean;
        getH265Disabled(): boolean;
        setVp8Disabled(value: boolean): void;
        setVp9Disabled(value: boolean): void;
        setH264Disabled(value: boolean): void;
        setH265Disabled(value: boolean): void;
        getRemoteEncoding(): fm.liveswitch.EncodingInfo;
        setRemoteEncoding(value: fm.liveswitch.EncodingInfo): void;
        getSimulcastMode(): fm.liveswitch.SimulcastMode;
        setSimulcastMode(value: fm.liveswitch.SimulcastMode): void;
        getTransportInfo(): fm.liveswitch.TransportInfo;
        getControlTransportInfo(): fm.liveswitch.TransportInfo;
        addOnLocalEncodingDisabled(value: fm.liveswitch.IAction1<fm.liveswitch.EncodingInfo>): void;
        addOnLocalEncodingEnabled(value: fm.liveswitch.IAction1<fm.liveswitch.EncodingInfo>): void;
        removeOnLocalEncodingDisabled(value: fm.liveswitch.IAction1<fm.liveswitch.EncodingInfo>): void;
        removeOnLocalEncodingEnabled(value: fm.liveswitch.IAction1<fm.liveswitch.EncodingInfo>): void;
        addOnDiscardKeyFrameRequest(value: fm.liveswitch.IAction1<number[]>): void;
        removeOnDiscardKeyFrameRequest(value: fm.liveswitch.IAction1<number[]>): void;
        raiseKeyFrameRequest(synchronizationSources: number[]): void;
        addOnDiscardBitrateRequest(value: fm.liveswitch.IAction1<fm.liveswitch.BitrateRequest>): void;
        removeOnDiscardBitrateRequest(value: fm.liveswitch.IAction1<fm.liveswitch.BitrateRequest>): void;
        raiseBitrateRequest(bitrateRequest: fm.liveswitch.BitrateRequest): boolean;
        addOnDiscardBitrateNotification(value: fm.liveswitch.IAction1<fm.liveswitch.BitrateNotification>): void;
        removeOnDiscardBitrateNotification(value: fm.liveswitch.IAction1<fm.liveswitch.BitrateNotification>): void;
        raiseBitrateNotification(bitrateNotification: fm.liveswitch.BitrateNotification): boolean;
        getMaxSendBitrate(): number;
        setMaxSendBitrate(value: number): void;
        getMaxReceiveBitrate(): number;
        setMaxReceiveBitrate(value: number): void;
    }
}
declare namespace fm.liveswitch {
    class PluginVideoTrack extends fm.liveswitch.PluginMediaTrack implements fm.liveswitch.IVideoTrack, fm.liveswitch.IInternalVideoTrack {
        getTypeString(): string;
        constructor(external: fm.liveswitch.IExternalVideoTrack, media: fm.liveswitch.PluginMedia);
        private isLocal;
        addOnStarted(value: fm.liveswitch.IAction0): void;
        addOnStopped(value: fm.liveswitch.IAction0): void;
        addOnDestroyed(value: fm.liveswitch.IAction0): void;
        removeOnStarted(value: fm.liveswitch.IAction0): void;
        removeOnStopped(value: fm.liveswitch.IAction0): void;
        removeOnDestroyed(value: fm.liveswitch.IAction0): void;
        changeSinkOutput(sinkOutput: fm.liveswitch.SinkOutput): fm.liveswitch.Future<Object>;
        getSinkOutput(): fm.liveswitch.SinkOutput;
        getSinkOutputs(): fm.liveswitch.Future<fm.liveswitch.SinkOutput[]>;
        setSinkOutput(value: fm.liveswitch.SinkOutput): void;
        changeSourceInput(sourceInput: fm.liveswitch.SourceInput): fm.liveswitch.Future<Object>;
        getSourceInput(): fm.liveswitch.SourceInput;
        getSourceInputs(): fm.liveswitch.Future<fm.liveswitch.SourceInput[]>;
        setSourceInput(value: fm.liveswitch.SourceInput): void;
        addOnSize(value: fm.liveswitch.IAction1<fm.liveswitch.Size>): void;
        getMuted(): boolean;
        getSize(): fm.liveswitch.Size;
        grabFrame(): fm.liveswitch.Future<fm.liveswitch.VideoBuffer>;
        setMuted(value: boolean): void;
        removeOnSize(value: fm.liveswitch.IAction1<fm.liveswitch.Size>): void;
    }
}
declare namespace fm.liveswitch {
    class RemoteMedia extends fm.liveswitch.Media implements fm.liveswitch.IRemoteMedia<fm.liveswitch.AudioTrack, fm.liveswitch.VideoTrack>, fm.liveswitch.IExternalRemoteMedia {
        getTypeString(): string;
        constructor(audio?: boolean, video?: boolean);
        changeAudioSinkOutput(audioSinkOutput: fm.liveswitch.SinkOutput): fm.liveswitch.Future<Object>;
        changeVideoSinkOutput(videoSinkOutput: fm.liveswitch.SinkOutput): fm.liveswitch.Future<Object>;
        getAudioSinkOutput(): fm.liveswitch.SinkOutput;
        getAudioSinkOutputs(): fm.liveswitch.Future<fm.liveswitch.SinkOutput[]>;
        getVideoSinkOutput(): fm.liveswitch.SinkOutput;
        getVideoSinkOutputs(): fm.liveswitch.Future<fm.liveswitch.SinkOutput[]>;
        setAudioSinkOutput(value: fm.liveswitch.SinkOutput): void;
        setVideoSinkOutput(value: fm.liveswitch.SinkOutput): void;
    }
}
declare namespace fm.liveswitch {
    /** @hidden */
    abstract class SessionDescriptionManagerBase<TStream extends fm.liveswitch.WebRtcStreamBase, TAudioStream extends fm.liveswitch.IAudioStream, TVideoStream extends fm.liveswitch.IVideoStream, TDataStream extends fm.liveswitch.IDataStream<TDataChannel>, TDataChannel extends fm.liveswitch.IDataChannel<TDataChannel>> {
        getTypeString(): string;
        protected __audioStreamIndex: Array<TStream>;
        protected __dataStreamIndex: Array<TStream>;
        protected __streamIndex: Array<TStream>;
        protected __streamMatcher: fm.liveswitch.SessionDescriptionStreamMatcher<TStream>;
        protected __videoStreamIndex: Array<TStream>;
        constructor();
        /** @hidden */
        static updateTrickleIcePolicy(message: fm.liveswitch.sdp.Message, policy: fm.liveswitch.TrickleIcePolicy): void;
        /** @hidden */
        addMediaDescriptions(msg: fm.liveswitch.sdp.Message, descriptions: fm.liveswitch.sdp.MediaDescription[]): void;
        addStream(stream: TStream): void;
        /** @hidden */
        private addToIndex;
        protected abstract getAudioStreams(): TStream[];
        protected abstract getDataStreams(): TStream[];
        /** @hidden */
        getOffererStreamIndexFor(answererStreamIndex: number): number;
        protected abstract getStreams(): fm.liveswitch.Hash<string, TStream>;
        protected abstract getVideoStreams(): TStream[];
        /** @hidden */
        matchAndProcessDescriptionPerType(streams: Array<TStream>, description: fm.liveswitch.SessionDescription, isLocalDescription: boolean, streamMatcher: fm.liveswitch.SessionDescriptionStreamMatcher<TStream>, processSdpMediaDescriptionForStreamHandler: fm.liveswitch.IFunction5<TStream, fm.liveswitch.sdp.MediaDescription, number, boolean, boolean, fm.liveswitch.Error>, processSdpMediaDescriptionInternal: boolean): fm.liveswitch.Error;
        /** @hidden */
        parseSessionDescriptionForStreamChangesAndUpdateMids(newRemoteDescription: fm.liveswitch.SessionDescription, existingAudioStreams: TStream[], existingVideoStreams: TStream[], existingDataStreams: TStream[]): fm.liveswitch.Pair<fm.liveswitch.StreamDescription[], Object[]>;
        /** @hidden */
        populateStreamTypeIndexes(descriptions: fm.liveswitch.sdp.MediaDescription[], streams: Array<TStream>, streamMatcher: fm.liveswitch.SessionDescriptionStreamMatcher<TStream>): fm.liveswitch.Error;
        processDescription(description: fm.liveswitch.SessionDescription, isLocalDescription: boolean): fm.liveswitch.Error;
        /** @hidden */
        private processMSection;
        protected abstract processSdpMediaDescriptionForStream(stream: TStream, sdpMediaDescription: fm.liveswitch.sdp.MediaDescription, sdpMediaIndex: number, isLocalDescription: boolean, isRenegotiation: boolean): fm.liveswitch.Error;
        /** @hidden */
        private removeFromIndex;
        removeStream(stream: TStream): boolean;
        /** @hidden */
        private resetStreamMatcher;
        protected updateLocalAudioDescription(mediaDescription: fm.liveswitch.sdp.MediaDescription, audioStream: TAudioStream): void;
        updateLocalDescription(localDescription: fm.liveswitch.SessionDescription): void;
        protected updateLocalVideoDescription(mediaDescription: fm.liveswitch.sdp.MediaDescription, videoStream: TVideoStream): void;
        /** @hidden */
        private validateBaseDescription;
    }
}
declare namespace fm.liveswitch {
    /**
    @hidden
    */
    class SessionDescriptionManager extends fm.liveswitch.SessionDescriptionManagerBase<fm.liveswitch.WebRtcStream, fm.liveswitch.WebRtcAudioStream, fm.liveswitch.WebRtcVideoStream, fm.liveswitch.WebRtcDataStream, fm.liveswitch.WebRtcDataChannel> {
        getTypeString(): string;
        /** @hidden */
        private _streams;
        constructor();
        getStreams(): fm.liveswitch.Hash<string, fm.liveswitch.WebRtcStream>;
        getAudioStreams(): fm.liveswitch.WebRtcAudioStream[];
        getVideoStreams(): fm.liveswitch.WebRtcVideoStream[];
        getDataStreams(): fm.liveswitch.WebRtcDataStream[];
        protected processSdpMediaDescriptionForStream(stream: fm.liveswitch.WebRtcStream, sdpMediaDescription: fm.liveswitch.sdp.MediaDescription, sdpMediaIndex: number, isLocalDescription: boolean, isRenegotiation: boolean): fm.liveswitch.Error;
    }
}
declare namespace fm.liveswitch {
    class VideoStream extends fm.liveswitch.MediaStream<fm.liveswitch.VideoTrack> implements fm.liveswitch.IVideoStream, fm.liveswitch.IExternalVideoStream {
        getTypeString(): string;
        getLocalMedia(): fm.liveswitch.LocalMedia;
        getRemoteMedia(): fm.liveswitch.RemoteMedia;
        constructor(localTrack: fm.liveswitch.VideoTrack);
        constructor(localTrack: fm.liveswitch.VideoTrack, remoteTrack: fm.liveswitch.VideoTrack);
        constructor(localMedia: fm.liveswitch.LocalMedia);
        constructor(localMedia: fm.liveswitch.LocalMedia, remoteMedia: fm.liveswitch.RemoteMedia);
        constructor(remoteMedia: fm.liveswitch.RemoteMedia);
        getVp8Disabled(): boolean;
        getVp9Disabled(): boolean;
        getH264Disabled(): boolean;
        getH265Disabled(): boolean;
        setVp8Disabled(value: boolean): void;
        setVp9Disabled(value: boolean): void;
        setH264Disabled(value: boolean): void;
        setH265Disabled(value: boolean): void;
        addOnDiscardKeyFrameRequest(value: fm.liveswitch.IAction1<number[]>): void;
        removeOnDiscardKeyFrameRequest(value: fm.liveswitch.IAction1<number[]>): void;
        raiseKeyFrameRequest(synchronizationSources: number[]): void;
    }
}
declare namespace fm.liveswitch {
    class VideoTrack extends fm.liveswitch.MediaTrack implements fm.liveswitch.IVideoTrack, fm.liveswitch.IExternalVideoTrack {
        getTypeString(): string;
        constructor(media: fm.liveswitch.Media, internalMedia?: fm.liveswitch.IInternalMedia);
        addOnSize(value: fm.liveswitch.IAction1<fm.liveswitch.Size>): void;
        getSize(): fm.liveswitch.Size;
        grabFrame(): fm.liveswitch.Future<fm.liveswitch.VideoBuffer>;
        removeOnSize(value: fm.liveswitch.IAction1<fm.liveswitch.Size>): void;
    }
}
declare namespace fm.liveswitch {
    /**
    Stream base properties/methods.
    */
    abstract class WebRtcStreamBase extends fm.liveswitch.Dynamic implements fm.liveswitch.IStream {
        getTypeString(): string;
        /** @hidden */
        private __id;
        /** @hidden */
        private __mediaStreamIdentification;
        /** @hidden */
        private __onDirectionChange;
        /** @hidden */
        private __onStateChange;
        /** @hidden */
        private __stateLock;
        /** @hidden */
        private __stateMachine;
        /** @hidden */
        private _connectedTimestamp;
        /** @hidden */
        private _connectionId;
        /** @hidden */
        private _externalId;
        /** @hidden */
        private _onDirectionChange;
        /** @hidden */
        private _onStateChange;
        /** @hidden */
        private _tag;
        /** @hidden */
        private _type;
        private fmliveswitchWebRtcStreamBaseInit;
        /**
        Initializes a new instance of the [[fm.liveswitch.streamBase]] class.
        @param type The type.
        */
        constructor(type: fm.liveswitch.StreamType);
        /**
        Adds a handler that is raised when the stream direction change has occurred.
        */
        addOnDirectionChange(value: fm.liveswitch.IAction0): void;
        /**
        Adds a handler that is raised when the stream state changes.
        */
        addOnStateChange(value: fm.liveswitch.IAction0): void;
        /**
        Changes this stream's direction.
        */
        abstract changeDirection(newDirection: fm.liveswitch.StreamDirection): fm.liveswitch.Error;
        /**
        Gets the ManagedStopwatch.GetTimestamp() value representing the ticks that passed when this stream's connection state changed to connected.
        */
        protected getConnectedTimestamp(): number;
        /**
        Gets the connection identifier.
        */
        getConnectionId(): string;
        /**
        Gets the current direction.
        */
        abstract getDirection(): fm.liveswitch.StreamDirection;
        /** @hidden */
        abstract getDirectionCapabilities(): fm.liveswitch.StreamDirection;
        /**
        Gets the external identifier.
        */
        getExternalId(): string;
        /**
        Gets the identifier.
        */
        getId(): string;
        /**
        Gets a value indicating whether the stream is currently closed or failed.
        */
        getIsTerminated(): boolean;
        /**
        Gets a value indicating whether the stream is currently closing or failing.
        */
        getIsTerminating(): boolean;
        /**
        Gets a value indicating whether the stream is currently closing, failing, closed, or failed.
        */
        getIsTerminatingOrTerminated(): boolean;
        /**
        Gets a label that identifies this class.
        */
        abstract getLabel(): string;
        /**
        Gets current direction indicated by the local description.
        */
        abstract getLocalDirection(): fm.liveswitch.StreamDirection;
        /**
        Gets a value indicating whether receiving media is supported by the local peer on this stream.
        */
        getLocalReceive(): boolean;
        /**
        Gets a value indicating whether sending media is supported by the local peer on this stream.
        */
        getLocalSend(): boolean;
        /**
        Gets the media description identifier.
        */
        getMediaDescriptionId(): string;
        /** @hidden */
        abstract getMediaDescriptionManager(): fm.liveswitch.MediaDescriptionManagerBase;
        /** @hidden */
        getMediaStreamIdentification(): string;
        /**
        Gets current direction indicated by the remote description.
        */
        abstract getRemoteDirection(): fm.liveswitch.StreamDirection;
        /**
        Gets a value indicating whether receiving media is supported by the local peer on this stream. Returns false if the remote stream direction has not been received.
        */
        getRemoteReceive(): boolean;
        /**
        Gets a value indicating whether sending media is supported by the remote peer on this stream. Returns false if the remote stream direction has not been received.
        */
        getRemoteSend(): boolean;
        /**
        Gets the state of the stream.
        */
        getState(): fm.liveswitch.StreamState;
        /** @hidden */
        getStateLock(): Object;
        /**
        Gets optional data to associate with this instance.
        */
        getTag(): string;
        /**
        Gets the stream transport info.
        */
        abstract getTransportInfo(): fm.liveswitch.TransportInfo;
        /**
        Gets the type.
        */
        getType(): fm.liveswitch.StreamType;
        /** @hidden */
        private logInvalidStateTransition;
        /** @hidden */
        abstract processSdpMediaDescription(sdpMessage: fm.liveswitch.sdp.Message, sdpMediaDescription: fm.liveswitch.sdp.MediaDescription, index: number, isLocalDescription: boolean, isOffer: boolean, isRenegotiation: boolean): fm.liveswitch.Error;
        /**
        Processes a state change.
        */
        protected processStateChange(): void;
        /**
        Processes a state lock change.
        */
        protected processStateLockChange(): void;
        /** @hidden */
        processUpdateToMediaStreamIdentification(oldValue: string): void;
        /** @hidden */
        raiseDirectionChange(): void;
        /** @hidden */
        private raiseStateChange;
        /**
        Removes a handler that is raised when the stream direction change has occurred.
        */
        removeOnDirectionChange(value: fm.liveswitch.IAction0): void;
        /**
        Removes a handler that is raised when the stream state changes.
        */
        removeOnStateChange(value: fm.liveswitch.IAction0): void;
        /** @hidden */
        private setConnectedTimestamp;
        /** @hidden */
        setConnectionId(value: string): void;
        /**
        Sets the external identifier.
        */
        setExternalId(value: string): void;
        /**
        Sets current direction indicated by the local description.
        */
        abstract setLocalDirection(value: fm.liveswitch.StreamDirection): void;
        /**
        Sets a value indicating whether receiving media is supported by the local peer on this stream.
        */
        setLocalReceive(value: boolean): void;
        /**
        Sets a value indicating whether sending media is supported by the local peer on this stream.
        */
        setLocalSend(value: boolean): void;
        /** @hidden */
        setMediaStreamIdentification(value: string): void;
        /** @hidden */
        abstract setRemoteDirection(value: fm.liveswitch.StreamDirection): void;
        /** @hidden */
        setState(state: fm.liveswitch.StreamState): boolean;
        /** @hidden */
        setStateLock(value: Object): void;
        /**
        Sets optional data to associate with this instance.
        */
        setTag(value: string): void;
        /** @hidden */
        private setType;
        /**
        Returns a string that represents this instance.
        */
        toString(): string;
    }
}
declare namespace fm.liveswitch {
    abstract class WebRtcStream extends fm.liveswitch.WebRtcStreamBase implements fm.liveswitch.IInternalStream {
        getTypeString(): string;
        /** @hidden */
        private _connection;
        getConnection(): fm.liveswitch.WebRtcConnection;
        setConnection(remoteTrack: fm.liveswitch.WebRtcConnection): void;
        /** @hidden */
        abstract _getExternal(): fm.liveswitch.IExternalStream;
        private _transportInfo;
        /** @hidden */
        getMediaDescriptionManager(): fm.liveswitch.MediaDescriptionManager;
        /** @hidden */
        setMediaDescriptionManager(manager: fm.liveswitch.MediaDescriptionManager): void;
        private _mediaDescriptionManager;
        setTransportInfo(transportInfo: fm.liveswitch.TransportInfo): void;
        getTransportInfo(): fm.liveswitch.TransportInfo;
    }
}
declare namespace fm.liveswitch {
    /**
    Media stream base properties/methods.
    */
    abstract class WebRtcMediaStreamBase extends fm.liveswitch.WebRtcStream {
        getTypeString(): string;
        /** @hidden */
        private __disabledCodecs;
        /** @hidden */
        private __localCanonicalName;
        /** @hidden */
        private __localDirection;
        /** @hidden */
        private __maxReceiveBitrate;
        /** @hidden */
        private __maxSendBitrate;
        /** @hidden */
        private __onLocalEncodingDisabled;
        /** @hidden */
        private __onLocalEncodingEnabled;
        /** @hidden */
        private __pendingLocalDirection;
        /** @hidden */
        private __remoteDirection;
        /** @hidden */
        private _localBandwidth;
        /** @hidden */
        private _onLocalEncodingDisabled;
        /** @hidden */
        private _onLocalEncodingEnabled;
        /** @hidden */
        private _preferredCodecs;
        /** @hidden */
        private _remoteBandwidth;
        /** @hidden */
        private _remoteCanonicalName;
        /** @hidden */
        private _remoteEncoding;
        /** @hidden */
        private _remoteMuted;
        /** @hidden */
        private _renegotiationLock;
        /** @hidden */
        private _renegotiationPending;
        private fmliveswitchWebRtcMediaStreamBaseInit;
        /**
        Initializes a new instance of the [[fm.liveswitch.mediaStreamBase]] class.
        @param type The type.
        */
        constructor(type: fm.liveswitch.StreamType);
        /**
        Adds a handler that is raised when a local encoding is disabled.
        */
        addOnLocalEncodingDisabled(value: fm.liveswitch.IAction1<fm.liveswitch.EncodingInfo>): void;
        /**
        Adds a handler that is raised when a local encoding is enabled.
        */
        addOnLocalEncodingEnabled(value: fm.liveswitch.IAction1<fm.liveswitch.EncodingInfo>): void;
        /**
        Records the pending direction of this stream. The LocalDirection of this stream will be updated when the connection renegotiation commences.
        */
        changeDirection(newDirection: fm.liveswitch.StreamDirection): fm.liveswitch.Error;
        /** @hidden */
        extractCanonicalName(mediaDescription: fm.liveswitch.sdp.MediaDescription, isLocalDescription: boolean): void;
        /**
        Gets the canonical name. Getting the value of MediaStream.CanonicalName is deprecated. Get the value of MediaStream.LocalCanonicalName instead.
        */
        getCanonicalName(): string;
        /**
        Gets whether a codec is disabled.
        @param name The codec name.
        @return Whether the codec is disabled.
        */
        getCodecDisabled(name: string): boolean;
        /**
        Gets control transport info.
        */
        abstract getControlTransportInfo(): fm.liveswitch.TransportInfo;
        /**
        Gets the direction.
        */
        getDirection(): fm.liveswitch.StreamDirection;
        /**
        Gets the media stream info.
        */
        getInfo(): fm.liveswitch.MediaStreamInfo;
        /**
        Gets whether the input track is muted.
        */
        abstract getInputMuted(): boolean;
        /**
        Gets a label that identifies this class.
        */
        getLabel(): string;
        /**
        Gets the local bandwidth, in kbps. This value is signalled in the local session description sent to the remote endpoint so it can limit its outbound media bitrate. Use [[fm.liveswitch.mediaStreamBase.maxReceiveBitrate]] to control inbound media bitrate once the session has been negotiated.
        */
        getLocalBandwidth(): number;
        /**
        Gets the local canonical name.
        */
        getLocalCanonicalName(): string;
        /**
        Gets current direction indicated by the local description.
        */
        getLocalDirection(): fm.liveswitch.StreamDirection;
        /**
        Gets and value indicating if local is muted. Alias for [[fm.liveswitch.mediaStreamBase.muted]].
        */
        getLocalMuted(): boolean;
        /**
        Gets the maximum desired receive bitrate, in kbps. This value must be less than or equal to [[fm.liveswitch.mediaStreamBase.localBandwidth]].
        */
        getMaxReceiveBitrate(): number;
        /**
        Gets the maximum desired send bitrate, in kbps. This value must be less than or equal to [[fm.liveswitch.mediaStreamBase.remoteBandwidth]].
        */
        getMaxSendBitrate(): number;
        /**
        Gets whether the input track is muted. Alias for [[fm.liveswitch.mediaStreamBase.inputMuted]].
        */
        getMuted(): boolean;
        /**
        Gets whether the output track is muted.
        */
        abstract getOutputMuted(): boolean;
        /** @hidden */
        getPendingLocalDirection(): fm.liveswitch.StreamDirection;
        /**
        Gets any preferred codecs, in order of preference.
        */
        getPreferredCodecs(): string[];
        /**
        Gets the remote bandwidth, in kbps. This value is signalled in the remote session description received from the remote endpoint so we can limit our outbound media bitrate. Use [[fm.liveswitch.mediaStreamBase.maxSendBitrate]] to control outbound media bitrate once the session has been negotiated.
        */
        getRemoteBandwidth(): number;
        /**
        Gets the remote canonical name.
        */
        getRemoteCanonicalName(): string;
        /**
        Gets current direction indicated by the remote description.
        */
        getRemoteDirection(): fm.liveswitch.StreamDirection;
        /**
        Gets the remote encoding.
        */
        getRemoteEncoding(): fm.liveswitch.EncodingInfo;
        /**
        Gets a value indicating if remote is muted.
        */
        getRemoteMuted(): boolean;
        /**
        Gets whether there exist changes that are pending SDP renegotiation.
        */
        protected getRenegotiationPending(): boolean;
        /**
        Gets the simulcast mode.
        */
        abstract getSimulcastMode(): fm.liveswitch.SimulcastMode;
        /**
        Populates the media stream info.
        @param info
        */
        protected abstract populateInfo(info: fm.liveswitch.MediaStreamInfo): void;
        /**
        Raises the OnLocalEncodingDisabled event.
        @param encoding The encoding.
        */
        protected raiseLocalEncodingDisabled(encoding: fm.liveswitch.EncodingInfo): void;
        /**
        Raises the OnLocalEncodingEnabled event.
        @param encoding The encoding.
        */
        protected raiseLocalEncodingEnabled(encoding: fm.liveswitch.EncodingInfo): void;
        /**
        Removes a handler that is raised when a local encoding is disabled.
        */
        removeOnLocalEncodingDisabled(value: fm.liveswitch.IAction1<fm.liveswitch.EncodingInfo>): void;
        /**
        Removes a handler that is raised when a local encoding is enabled.
        */
        removeOnLocalEncodingEnabled(value: fm.liveswitch.IAction1<fm.liveswitch.EncodingInfo>): void;
        /**
        Sets whether a codec is disabled.
        @param name The codec name.
        @param disabled Whether to disable the codec.
        */
        setCodecDisabled(name: string, disabled: boolean): void;
        /**
        Sets whether the input track is muted.
        */
        abstract setInputMuted(value: boolean): void;
        /**
        Sets the local bandwidth, in kbps. This value is signalled in the local session description sent to the remote endpoint so it can limit its outbound media bitrate. Use [[fm.liveswitch.mediaStreamBase.maxReceiveBitrate]] to control inbound media bitrate once the session has been negotiated.
        */
        setLocalBandwidth(value: number): void;
        /** @hidden */
        setLocalCanonicalName(value: string): void;
        /**
        Sets current direction indicated by the local description.
        */
        setLocalDirection(value: fm.liveswitch.StreamDirection): void;
        /**
        Sets and value indicating if local is muted. Alias for [[fm.liveswitch.mediaStreamBase.muted]].
        */
        setLocalMuted(value: boolean): void;
        /**
        Sets the maximum desired receive bitrate, in kbps. This value must be less than or equal to [[fm.liveswitch.mediaStreamBase.localBandwidth]].
        */
        setMaxReceiveBitrate(value: number): void;
        /**
        Sets the maximum desired send bitrate, in kbps. This value must be less than or equal to [[fm.liveswitch.mediaStreamBase.remoteBandwidth]].
        */
        setMaxSendBitrate(value: number): void;
        /**
        Sets whether the input track is muted. Alias for [[fm.liveswitch.mediaStreamBase.inputMuted]].
        */
        setMuted(value: boolean): void;
        /**
        Sets whether the output track is muted.
        */
        abstract setOutputMuted(value: boolean): void;
        /** @hidden */
        setPendingLocalDirection(value: fm.liveswitch.StreamDirection): void;
        /**
        Sets any preferred codecs, in order of preference.
        */
        setPreferredCodecs(value: string[]): void;
        /**
        Sets the remote bandwidth, in kbps. This value is signalled in the remote session description received from the remote endpoint so we can limit our outbound media bitrate. Use [[fm.liveswitch.mediaStreamBase.maxSendBitrate]] to control outbound media bitrate once the session has been negotiated.
        */
        protected setRemoteBandwidth(value: number): void;
        /** @hidden */
        setRemoteCanonicalName(value: string): void;
        /** @hidden */
        setRemoteDirection(value: fm.liveswitch.StreamDirection): void;
        /**
        Sets the remote encoding.
        */
        setRemoteEncoding(value: fm.liveswitch.EncodingInfo): void;
        /**
        Sets a value indicating if remote is muted.
        */
        setRemoteMuted(value: boolean): void;
        /**
        Sets whether there exist changes that are pending SDP renegotiation.
        */
        protected setRenegotiationPending(value: boolean): void;
        /**
        Sets the simulcast mode.
        */
        abstract setSimulcastMode(value: fm.liveswitch.SimulcastMode): void;
    }
}
declare namespace fm.liveswitch {
    abstract class WebRtcMediaStream<TTrack extends fm.liveswitch.WebRtcMediaTrack> extends fm.liveswitch.WebRtcMediaStreamBase implements fm.liveswitch.IMediaStream, fm.liveswitch.IInternalMediaStream {
        getTypeString(): string;
        /** @hidden */
        abstract _getExternal(): fm.liveswitch.IExternalMediaStream;
        /** @hidden */
        private _onDiscardBitrateRequestValues;
        /** @hidden */
        private _onDiscardBitrateNotificationValues;
        /** @hidden */
        private _deactivatedByServer;
        /** @hidden */
        private _localTrack;
        getLocalTrack(): TTrack;
        setLocalTrack(localTrack: TTrack): void;
        /** @hidden */
        private _remoteTrack;
        getRemoteTrack(): TTrack;
        setRemoteTrack(remoteTrack: TTrack): void;
        setInputMuted(muted: boolean): void;
        getInputMuted(): boolean;
        setOutputMuted(muted: boolean): void;
        getOutputMuted(): boolean;
        constructor(external: fm.liveswitch.IExternalMediaStream, localTrack: TTrack, remoteTrack: TTrack, type: fm.liveswitch.StreamType);
        /** @hidden */
        private _maxVideoSize;
        /** @hidden */
        setMaxWidthAndHeight(width: number, height: number): void;
        populateInfo(info: fm.liveswitch.MediaStreamInfo): void;
        /** @hidden */
        private toFormatInfos;
        /** @hidden */
        private _sender;
        /** @hidden */
        getSender(): RTCRtpSender;
        /** @hidden */
        setSender(value: RTCRtpSender, applySendEncodings: boolean): void;
        /** @hidden */
        private _receiver;
        /** @hidden */
        getReceiver(): RTCRtpReceiver;
        /** @hidden */
        setReceiver(value: RTCRtpReceiver): void;
        /** @hidden */
        private _singleSendBitrate;
        /** @hidden */
        getSingleSendBitrate(): number;
        /** @hidden */
        private _sendEncodings;
        /** @hidden */
        getSendEncodings(): fm.liveswitch.EncodingConfig[];
        /** @hidden */
        setSendEncodings(sendEncodings: fm.liveswitch.EncodingConfig[]): void;
        /** @hidden */
        private applySendEncodings;
        /** @hidden */
        private _receiveEncodings;
        /** @hidden */
        getReceiveEncodings(): fm.liveswitch.EncodingConfig[];
        /** @hidden */
        setReceiveEncodings(receiveEncodings: fm.liveswitch.EncodingConfig[]): void;
        /** @hidden */
        getNativeSendEncodings(): RTCRtpEncodingParameters[];
        /** @hidden */
        getSendEncodingInfos(): fm.liveswitch.EncodingInfo[];
        /** @hidden */
        getReceiveEncodingInfos(): fm.liveswitch.EncodingInfo[];
        /** @hidden */
        private updateNativeEncoding;
        /** @hidden */
        private updateEncodingInfo;
        /** @hidden */
        private getNativeTrack;
        /** @hidden */
        getSourceEncoding(): fm.liveswitch.EncodingInfo;
        /** @hidden */
        replaceLocalTrack(localTrack: TTrack): fm.liveswitch.Future<object>;
        /** @hidden */
        replaceRemoteTrack(remoteTrack: TTrack): fm.liveswitch.Future<object>;
        processCachedChanges(): void;
        resetRemoteDirection(): void;
        processSdpMediaDescription(sdpMessage: fm.liveswitch.sdp.Message, sdpMediaDescription: fm.liveswitch.sdp.MediaDescription, index: number, isLocalDescription: boolean, isOffer: boolean, isRenegotiation: boolean): fm.liveswitch.Error;
        getDirectionCapabilities(): fm.liveswitch.StreamDirection;
        private _controlTransportInfo;
        setControlTransportInfo(info: fm.liveswitch.TransportInfo): void;
        getControlTransportInfo(): fm.liveswitch.TransportInfo;
        private _simulcastMode;
        getSimulcastMode(): fm.liveswitch.SimulcastMode;
        setSimulcastMode(value: fm.liveswitch.SimulcastMode): void;
        addOnDiscardBitrateRequest(value: fm.liveswitch.IAction1<fm.liveswitch.BitrateRequest>): void;
        removeOnDiscardBitrateRequest(value: fm.liveswitch.IAction1<fm.liveswitch.BitrateRequest>): void;
        /** @hidden */
        private raiseOnDiscardBitrateRequest;
        /** @hidden */
        protected processBitrateRequest(bitrateRequest: fm.liveswitch.BitrateRequest): void;
        raiseBitrateRequest(bitrateRequest: fm.liveswitch.BitrateRequest): boolean;
        private remoteRequestedMaxSendBitrate;
        private findSendEncodingIndex;
        addOnDiscardBitrateNotification(value: fm.liveswitch.IAction1<fm.liveswitch.BitrateNotification>): void;
        removeOnDiscardBitrateNotification(value: fm.liveswitch.IAction1<fm.liveswitch.BitrateNotification>): void;
        /** @hidden */
        private _raiseOnDiscardBitrateNotification;
        /** @hidden */
        protected processBitrateNotification(bitrateNotification: fm.liveswitch.BitrateNotification): void;
        raiseBitrateNotification(bitrateNotification: fm.liveswitch.BitrateNotification): boolean;
        setMaxSendBitrate(value: number): fm.liveswitch.Future<object>;
        setMaxReceiveBitrate(value: number): void;
    }
}
declare namespace fm.liveswitch {
    class WebRtcAudioStream extends fm.liveswitch.WebRtcMediaStream<fm.liveswitch.WebRtcAudioTrack> implements fm.liveswitch.IAudioStream, fm.liveswitch.IInternalAudioStream {
        getTypeString(): string;
        /** @hidden */
        private _dtmfSender;
        /** @hidden */
        private _onSendDtmfToneValues;
        /** @hidden */
        private _onSendDtmfToneChangeValues;
        /** @hidden */
        private _external;
        /** @hidden */
        _getExternal(): fm.liveswitch.IExternalAudioStream;
        /** @hidden */
        private _discardDtmfTones;
        /** @hidden */
        private _onDiscardOutboundDtmfTonesValues;
        /** @hidden */
        private raiseOnDiscardOutboundDtmfTones;
        constructor(external: fm.liveswitch.IExternalAudioStream, localTrack: fm.liveswitch.WebRtcAudioTrack, remoteTrack: fm.liveswitch.WebRtcAudioTrack);
        addOnReceiveDtmfTone(value: fm.liveswitch.IAction1<fm.liveswitch.dtmf.Tone>): void;
        addOnReceiveDtmfToneChange(value: fm.liveswitch.IAction1<fm.liveswitch.dtmf.Tone>): void;
        addOnSendDtmfTone(value: fm.liveswitch.IAction1<fm.liveswitch.dtmf.Tone>): void;
        addOnSendDtmfToneChange(value: fm.liveswitch.IAction1<fm.liveswitch.dtmf.Tone>): void;
        insertDtmfTone(dtmfTone: fm.liveswitch.dtmf.Tone): boolean;
        insertDtmfTones(dtmfTones: fm.liveswitch.dtmf.Tone[]): boolean;
        removeOnReceiveDtmfTone(value: fm.liveswitch.IAction1<fm.liveswitch.dtmf.Tone>): void;
        removeOnReceiveDtmfToneChange(value: fm.liveswitch.IAction1<fm.liveswitch.dtmf.Tone>): void;
        removeOnSendDtmfTone(value: fm.liveswitch.IAction1<fm.liveswitch.dtmf.Tone>): void;
        removeOnSendDtmfToneChange(value: fm.liveswitch.IAction1<fm.liveswitch.dtmf.Tone>): void;
        getOpusDisabled(): boolean;
        getG722Disabled(): boolean;
        getPcmuDisabled(): boolean;
        getPcmaDisabled(): boolean;
        setOpusDisabled(value: boolean): void;
        setG722Disabled(value: boolean): void;
        setPcmuDisabled(value: boolean): void;
        setPcmaDisabled(value: boolean): void;
    }
}
declare namespace fm.liveswitch {
    /**
    Media track base properties/methods.
    */
    abstract class WebRtcMediaTrackBase extends fm.liveswitch.Dynamic implements fm.liveswitch.IMediaTrack {
        getTypeString(): string;
        constructor();
        /**
        Adds a handler that is raised when the track is destroyed.
        */
        abstract addOnDestroyed(value: fm.liveswitch.IAction0): void;
        /**
        Adds a handler that is raised when the track is started. Only applicable for local media tracks.
        */
        abstract addOnStarted(value: fm.liveswitch.IAction0): void;
        /**
        Adds a handler that is raised when the track is stopped. Only applicable for local media tracks.
        */
        abstract addOnStopped(value: fm.liveswitch.IAction0): void;
        /**
        Changes the sink output while the media track is active.
        @param sinkOutput The sink output.
        */
        abstract changeSinkOutput(sinkOutput: fm.liveswitch.SinkOutput): fm.liveswitch.Future<Object>;
        /**
        Changes the source input while the media track is active.
        @param sourceInput The source input.
        */
        abstract changeSourceInput(sourceInput: fm.liveswitch.SourceInput): fm.liveswitch.Future<Object>;
        /**
        Destroys this media track.
        */
        abstract destroy(): boolean;
        /**
        Gets a value indicating whether this track is muted.
        */
        abstract getMuted(): boolean;
        /**
        Gets the current sink output.
        */
        abstract getSinkOutput(): fm.liveswitch.SinkOutput;
        /**
        Gets the available sink outputs.
        @return
                    A future with an array of sink outputs.
            
        */
        abstract getSinkOutputs(): fm.liveswitch.Future<fm.liveswitch.SinkOutput[]>;
        /**
        Gets the current source input.
        */
        abstract getSourceInput(): fm.liveswitch.SourceInput;
        /**
        Gets the available source inputs.
        @return
                    A future with an array of source inputs.
            
        */
        abstract getSourceInputs(): fm.liveswitch.Future<fm.liveswitch.SourceInput[]>;
        /**
        Removes a handler that is raised when the track is destroyed.
        */
        abstract removeOnDestroyed(value: fm.liveswitch.IAction0): void;
        /**
        Removes a handler that is raised when the track is started. Only applicable for local media tracks.
        */
        abstract removeOnStarted(value: fm.liveswitch.IAction0): void;
        /**
        Removes a handler that is raised when the track is stopped. Only applicable for local media tracks.
        */
        abstract removeOnStopped(value: fm.liveswitch.IAction0): void;
        /**
        Sets a value indicating whether this track is muted.
        */
        abstract setMuted(value: boolean): void;
        /**
        Sets the current sink output.
        */
        abstract setSinkOutput(value: fm.liveswitch.SinkOutput): void;
        /**
        Sets the current source input.
        */
        abstract setSourceInput(value: fm.liveswitch.SourceInput): void;
    }
}
declare namespace fm.liveswitch {
    abstract class WebRtcMediaTrack extends fm.liveswitch.WebRtcMediaTrackBase implements fm.liveswitch.IMediaTrack, fm.liveswitch.IInternalMediaTrack {
        getTypeString(): string;
        addOnStarted(value: fm.liveswitch.IAction0): void;
        addOnStopped(value: fm.liveswitch.IAction0): void;
        addOnDestroyed(value: fm.liveswitch.IAction0): void;
        removeOnStarted(value: fm.liveswitch.IAction0): void;
        removeOnStopped(value: fm.liveswitch.IAction0): void;
        removeOnDestroyed(value: fm.liveswitch.IAction0): void;
        getMedia(): fm.liveswitch.WebRtcMedia<fm.liveswitch.WebRtcAudioTrack, fm.liveswitch.WebRtcVideoTrack>;
        constructor(external: fm.liveswitch.IExternalMediaTrack, media: fm.liveswitch.WebRtcMedia<fm.liveswitch.WebRtcAudioTrack, fm.liveswitch.WebRtcVideoTrack>);
        private _muted;
        getMuted(): boolean;
        setMuted(muted: boolean): void;
        stop(): void;
        destroy(): boolean;
        private raiseOnStopped;
    }
}
declare namespace fm.liveswitch {
    class WebRtcAudioTrack extends fm.liveswitch.WebRtcMediaTrack implements fm.liveswitch.IAudioTrack, fm.liveswitch.IInternalAudioTrack {
        getTypeString(): string;
        constructor(external: fm.liveswitch.IExternalAudioTrack, media: fm.liveswitch.WebRtcMedia<fm.liveswitch.WebRtcAudioTrack, fm.liveswitch.WebRtcVideoTrack>);
        private isLocal;
        changeSinkOutput(sinkOutput: fm.liveswitch.SinkOutput): fm.liveswitch.Future<Object>;
        getSinkOutput(): fm.liveswitch.SinkOutput;
        getSinkOutputs(): fm.liveswitch.Future<fm.liveswitch.SinkOutput[]>;
        setSinkOutput(value: fm.liveswitch.SinkOutput): void;
        changeSourceInput(sourceInput: fm.liveswitch.SourceInput): fm.liveswitch.Future<Object>;
        getSourceInput(): fm.liveswitch.SourceInput;
        getSourceInputs(): fm.liveswitch.Future<fm.liveswitch.SourceInput[]>;
        setSourceInput(value: fm.liveswitch.SourceInput): void;
        addOnLevel(value: fm.liveswitch.IAction1<number>): void;
        getGain(): number;
        getVolume(): number;
        removeOnLevel(value: fm.liveswitch.IAction1<number>): void;
        setGain(value: number): void;
        setVolume(value: number): void;
    }
}
declare namespace fm.liveswitch {
    /**
    Connection base properties/methods.
    */
    abstract class WebRtcConnectionBase<TConnection extends fm.liveswitch.WebRtcConnectionBase<TConnection, TStream, TAudioStream, TVideoStream, TDataStream, TDataChannel>, TStream extends fm.liveswitch.WebRtcStreamBase, TAudioStream extends fm.liveswitch.IAudioStream, TVideoStream extends fm.liveswitch.IVideoStream, TDataStream extends fm.liveswitch.IDataStream<TDataChannel>, TDataChannel extends fm.liveswitch.IDataChannel<TDataChannel>> extends fm.liveswitch.Dynamic implements fm.liveswitch.IConnection<TConnection, TStream, TAudioStream, TVideoStream, TDataStream> {
        getTypeString(): string;
        /** @hidden */
        private __bundlePolicy;
        /** @hidden */
        private __closed;
        /** @hidden */
        private __connected;
        /** @hidden */
        private __externalId;
        /** @hidden */
        private __failed;
        /** @hidden */
        private __iceServers;
        /** @hidden */
        private __id;
        /** @hidden */
        private __localDTLSRole;
        /** @hidden */
        private __onExternalIdChange;
        /** @hidden */
        private __onGatheringStateChange;
        /** @hidden */
        private __onIceConnectionStateChange;
        /** @hidden */
        private __onLocalCandidate;
        /** @hidden */
        private __onLocalDescription;
        /** @hidden */
        private __onRemoteCandidate;
        /** @hidden */
        private __onRemoteDescription;
        /** @hidden */
        private __onSignallingStateChange;
        /** @hidden */
        private __onStateChange;
        /** @hidden */
        private __remoteDTLSRole;
        /** @hidden */
        private __signallingState;
        /** @hidden */
        private __stateMachine;
        /** @hidden */
        private __trickleIcePolicy;
        /** @hidden */
        private __useTrickleIce;
        /** @hidden */
        _connectionLock: Object;
        /** @hidden */
        private _deadStreamTimeout;
        /** @hidden */
        private _earlyRemoteCandidatePromises;
        /** @hidden */
        private _error;
        /** @hidden */
        private _iceGatherPolicy;
        /** @hidden */
        private _legacyTimeout;
        /** @hidden */
        private _onExternalIdChange;
        /** @hidden */
        private _onGatheringStateChange;
        /** @hidden */
        private _onIceConnectionStateChange;
        /** @hidden */
        private _onLocalCandidate;
        /** @hidden */
        private _onLocalDescription;
        /** @hidden */
        private _onRemoteCandidate;
        /** @hidden */
        private _onRemoteDescription;
        /** @hidden */
        private _onSignallingStateChange;
        /** @hidden */
        private _onStateChange;
        /** @hidden */
        private _tieBreaker;
        /** @hidden */
        private _timeout;
        private fmliveswitchWebRtcConnectionBaseInit;
        /**
        Initializes a new instance of the [[fm.liveswitch.connectionBase]] class.
        */
        constructor(sharedLock: Object);
        /**
        Adds an ICE server.
        @param iceServer The ICE server.
        */
        addIceServer(iceServer: fm.liveswitch.IceServer): void;
        /**
        Adds some ICE servers.
        @param iceServers The ICE servers.
        */
        addIceServers(iceServers: fm.liveswitch.IceServer[]): void;
        /**
        Adds a handler that is raised when external Id of this connection changes. Old external Id as well as internal Id are raised.
        */
        addOnExternalIdChange(value: fm.liveswitch.IAction2<string, string>): void;
        /**
        Adds a handler that is raised when the gathering state changes.
        */
        addOnGatheringStateChange(value: fm.liveswitch.IAction1<TConnection>): void;
        /**
        Adds a handler that is raised when the ice connection state changes.
        */
        addOnIceConnectionStateChange(value: fm.liveswitch.IAction1<TConnection>): void;
        /**
        Adds a handler that is raised when a local candidate is added.
        */
        addOnLocalCandidate(value: fm.liveswitch.IAction2<TConnection, fm.liveswitch.Candidate>): void;
        /**
        Adds a handler that is raised when a local description is set.
        */
        addOnLocalDescription(value: fm.liveswitch.IAction2<TConnection, fm.liveswitch.SessionDescription>): void;
        /**
        Adds a handler that is raised when a remote description is added.
        */
        addOnRemoteCandidate(value: fm.liveswitch.IAction2<TConnection, fm.liveswitch.Candidate>): void;
        /**
        Adds a handler that is raised when a remote description is set.
        */
        addOnRemoteDescription(value: fm.liveswitch.IAction2<TConnection, fm.liveswitch.SessionDescription>): void;
        /**
        Adds a handler that is raised when the signalling state changes.
        */
        addOnSignallingStateChange(value: fm.liveswitch.IAction1<TConnection>): void;
        /**
        Adds a handler that is raised when the connection state changes.
        */
        addOnStateChange(value: fm.liveswitch.IAction1<TConnection>): void;
        /**
        Adds the remote candidate.
        @param remoteCandidate The remote candidate.
        */
        addRemoteCandidate(remoteCandidate: fm.liveswitch.Candidate): fm.liveswitch.Future<fm.liveswitch.Candidate>;
        /** @hidden */
        private addRemoteCandidatePromise;
        /**
        Closes this instance.
        */
        abstract close(): boolean;
        /** @hidden */
        private connectionBase_OnStateChange;
        /**
        Creates an answer.
        */
        createAnswer(): fm.liveswitch.Future<fm.liveswitch.SessionDescription>;
        /** @hidden */
        private createAnswerWrapper;
        /**
        Creates an offer.
        */
        createOffer(): fm.liveswitch.Future<fm.liveswitch.SessionDescription>;
        /** @hidden */
        private createOfferWrapper;
        /**
        Adds the remote candidate.
        @param promise The promise.
        @param remoteCandidate The remote candidate.
        */
        protected abstract doAddRemoteCandidate(promise: fm.liveswitch.Promise<fm.liveswitch.Candidate>, remoteCandidate: fm.liveswitch.Candidate): void;
        /**
        Creates an answer.
        */
        protected abstract doCreateAnswer(promise: fm.liveswitch.Promise<fm.liveswitch.SessionDescription>): void;
        /**
        Creates an offer.
        */
        protected abstract doCreateOffer(promise: fm.liveswitch.Promise<fm.liveswitch.SessionDescription>): boolean;
        /**
        Processes a session description.
        @param description The session description.
        @param isLocalDescription Whether this is a local session description.
        */
        protected doProcessDescription(description: fm.liveswitch.SessionDescription, isLocalDescription: boolean): fm.liveswitch.Error;
        /**
        Dispatches cached local candidates that were gathered while Connection generated session description.
        */
        protected abstract doSendCachedLocalCandidates(): void;
        /**
        Sets the local description.
        @param promise The promise.
        @param localDescription The local description.
        */
        protected abstract doSetLocalDescription(promise: fm.liveswitch.Promise<fm.liveswitch.SessionDescription>, localDescription: fm.liveswitch.SessionDescription): void;
        /** @hidden */
        private doSetLocalDescriptionInternal;
        /**
        Sets the remote description.
        @param promise The promise.
        @param remoteDescription The remote description.
        */
        protected abstract doSetRemoteDescription(promise: fm.liveswitch.Promise<fm.liveswitch.SessionDescription>, remoteDescription: fm.liveswitch.SessionDescription): void;
        /** @hidden */
        private doSetRemoteDescriptionInternal;
        /** @hidden */
        private dtlsRole;
        /**
        Gets the first audio stream.
        */
        getAudioStream(): TAudioStream;
        /**
        Gets the audio streams.
        */
        abstract getAudioStreams(): TAudioStream[];
        /**
        Gets the bundle policy.
        */
        getBundlePolicy(): fm.liveswitch.BundlePolicy;
        /**
        Gets the canonical name. Getting the value of Connection.CanonicalName is deprecated. Get the value of MediaStream.LocalCanonicalName instead.
        */
        getCanonicalName(): string;
        /**
        Gets a future that resolves if the connection enters the Closed state or rejects if the connection enters the Failed state before that happens.
        */
        getClosed(): fm.liveswitch.Future<Object>;
        /**
        Gets a future that resolves if the connection enters the Connected state or rejects if the connection enters the Failed state before that happens.
        */
        getConnected(): fm.liveswitch.Future<Object>;
        /** @hidden */
        getConnectionWideCanonicalName(): string;
        /**
        Gets the first data stream.
        */
        getDataStream(): TDataStream;
        /**
        Gets the data streams.
        */
        abstract getDataStreams(): TDataStream[];
        /**
        Gets the amount of time (in milliseconds) to wait for connectivity checks to re-establish after they start to fail on a live connection. Defaults to 15,000.
        */
        getDeadStreamTimeout(): number;
        /**
        Gets the error.
        */
        getError(): fm.liveswitch.Error;
        /**
        Gets the external identifier.
        */
        getExternalId(): string;
        /**
        Gets a future that resolves if the connection enters the Failed state or rejects if the connection enters the Closed state before that happens.
        */
        getFailed(): fm.liveswitch.Future<Object>;
        /**
        Gets the ICE gathering state.
        */
        abstract getGatheringState(): fm.liveswitch.IceGatheringState;
        /**
        Gets whether this connection has an audio stream.
        */
        getHasAudio(): boolean;
        /**
        Gets whether this connection has a data stream.
        */
        getHasData(): boolean;
        /**
        Gets whether this connection has a video stream.
        */
        getHasVideo(): boolean;
        /**
        Gets the ICE connection state.
        */
        abstract getIceConnectionState(): fm.liveswitch.IceConnectionState;
        /**
        Gets the ICE gather policy.
        */
        getIceGatherPolicy(): fm.liveswitch.IceGatherPolicy;
        /**
        Gets the ICE server.
        */
        getIceServer(): fm.liveswitch.IceServer;
        /**
        Gets the ICE servers.
        */
        getIceServers(): fm.liveswitch.IceServer[];
        /**
        Gets the identifier.
        */
        getId(): string;
        /**
        Gets the current instance.
        */
        protected abstract getInstance(): TConnection;
        /**
        Gets a value indicating whether the connection is currently closed or failed.
        */
        getIsTerminated(): boolean;
        /**
        Gets a value indicating whether the connection is currently closing or failing.
        */
        getIsTerminating(): boolean;
        /**
        Gets a value indicating whether the connection is currently closing, failing, closed, or failed.
        */
        getIsTerminatingOrTerminated(): boolean;
        /**
        Gets a value indicating whether legacy Connection.Timeout should be used. When disabled, Connection.Timeout only accounts for the time spent trying to establish connectivity (i.e. time it takes to transition from the Connecting to the Connected state; from the time point when both offer and answer had been set to the connection being fully established). When enabled, Connection.Timeout accounts for the time spent from receiving an offer (or creating an offer) to establishing connectivity (i.e. time it takes to transition from Initializing to Connected state). By default, LegacyTimeout is set to true, so that existing behavior is preserved. However, in the future default will be updated to false. This means that IL will not account for any signalling delays that may occur while establishing connectivity. This option will be later deprecated.
        */
        getLegacyTimeout(): boolean;
        /**
        Gets the local description.
        */
        abstract getLocalDescription(): fm.liveswitch.SessionDescription;
        /**
        Gets the remote description.
        */
        abstract getRemoteDescription(): fm.liveswitch.SessionDescription;
        /** @hidden */
        abstract getSessionDescriptionManager(): fm.liveswitch.SessionDescriptionManagerBase<TStream, TAudioStream, TVideoStream, TDataStream, TDataChannel>;
        /**
        Gets the state of the signalling.
        */
        getSignallingState(): fm.liveswitch.SignallingState;
        /**
        Gets the state of the connection.
        */
        getState(): fm.liveswitch.ConnectionState;
        /**
        Gets the current connection stats.
        */
        abstract getStats(): fm.liveswitch.Future<fm.liveswitch.ConnectionStats>;
        /**
        Gets the first stream.
        */
        getStream(): TStream;
        /**
        Gets the streams.
        */
        abstract getStreams(): TStream[];
        /**
        Gets the tie breaker.
        */
        getTieBreaker(): string;
        /**
        Gets the amount of time (in milliseconds) to wait for a connection to establish before giving up and closing it. Defaults to 30,000.
        */
        getTimeout(): number;
        /**
        Gets Trickle Ice Support Policy. Cf. https://tools.ietf.org/html/draft-ietf-ice-trickle-05
        */
        getTrickleIcePolicy(): fm.liveswitch.TrickleIcePolicy;
        /** @hidden */
        getUseTrickleIce(): boolean;
        /**
        Gets the first video stream.
        */
        getVideoStream(): TVideoStream;
        /**
        Gets the video streams.
        */
        abstract getVideoStreams(): TVideoStream[];
        /** @hidden */
        private logInvalidStateTransition;
        /**
        Processes a session description.
        @param description The session description.
        @param isLocalDescription Whether this is a local session description.
        */
        protected processDescription(description: fm.liveswitch.SessionDescription, isLocalDescription: boolean): fm.liveswitch.Error;
        /**
        Processes a state change.
        */
        protected processStateChange(): void;
        /** @hidden */
        raiseCachedCandidates(): void;
        /** @hidden */
        private raiseConnected;
        /**
        Raises gathering state change.
        */
        protected raiseGatheringStateChange(connection: TConnection): void;
        /**
        Raises ICE connection state change.
        */
        protected raiseIceConnectionStateChange(connection: TConnection): void;
        /**
        Raises a local candidate but only if it has not been already raised.
        @param localCandidate The local candidate.
        */
        protected raiseLocalCandidate(localCandidate: fm.liveswitch.Candidate): void;
        /** @hidden */
        private raiseLocalDescription;
        /** @hidden */
        private raiseRemoteCandidate;
        /** @hidden */
        private raiseRemoteDescription;
        /** @hidden */
        private raiseStateChange;
        /** @hidden */
        private raiseTerminated;
        /** @hidden */
        registerStreamWithSessionDescriptionManager(stream: TStream): void;
        /**
        Removes an ICE server.
        @param iceServer The ICE server.
        */
        removeIceServer(iceServer: fm.liveswitch.IceServer): void;
        /**
        Removes some ICE servers.
        @param iceServers The ICE servers.
        */
        removeIceServers(iceServers: fm.liveswitch.IceServer[]): void;
        /**
        Removes a handler that is raised when external Id of this connection changes. Old external Id as well as internal Id are raised.
        */
        removeOnExternalIdChange(value: fm.liveswitch.IAction2<string, string>): void;
        /**
        Removes a handler that is raised when the gathering state changes.
        */
        removeOnGatheringStateChange(value: fm.liveswitch.IAction1<TConnection>): void;
        /**
        Removes a handler that is raised when the ice connection state changes.
        */
        removeOnIceConnectionStateChange(value: fm.liveswitch.IAction1<TConnection>): void;
        /**
        Removes a handler that is raised when a local candidate is added.
        */
        removeOnLocalCandidate(value: fm.liveswitch.IAction2<TConnection, fm.liveswitch.Candidate>): void;
        /**
        Removes a handler that is raised when a local description is set.
        */
        removeOnLocalDescription(value: fm.liveswitch.IAction2<TConnection, fm.liveswitch.SessionDescription>): void;
        /**
        Removes a handler that is raised when a remote description is added.
        */
        removeOnRemoteCandidate(value: fm.liveswitch.IAction2<TConnection, fm.liveswitch.Candidate>): void;
        /**
        Removes a handler that is raised when a remote description is set.
        */
        removeOnRemoteDescription(value: fm.liveswitch.IAction2<TConnection, fm.liveswitch.SessionDescription>): void;
        /**
        Removes a handler that is raised when the signalling state changes.
        */
        removeOnSignallingStateChange(value: fm.liveswitch.IAction1<TConnection>): void;
        /**
        Removes a handler that is raised when the connection state changes.
        */
        removeOnStateChange(value: fm.liveswitch.IAction1<TConnection>): void;
        /** @hidden */
        private saveDtlsSRole;
        /**
        Sets the bundle policy.
        */
        setBundlePolicy(value: fm.liveswitch.BundlePolicy): void;
        /**
        Sets the amount of time (in milliseconds) to wait for connectivity checks to re-establish after they start to fail on a live connection. Defaults to 15,000.
        */
        setDeadStreamTimeout(value: number): void;
        /**
        Sets the error.
        */
        setError(value: fm.liveswitch.Error): void;
        /**
        Sets the external identifier.
        */
        setExternalId(value: string): void;
        /**
        Sets the ICE gathering state.
        */
        protected abstract setGatheringState(value: fm.liveswitch.IceGatheringState): void;
        /**
        Sets the ICE connection state.
        */
        protected abstract setIceConnectionState(value: fm.liveswitch.IceConnectionState): void;
        /**
        Sets the ICE gather policy.
        */
        setIceGatherPolicy(value: fm.liveswitch.IceGatherPolicy): void;
        /**
        Sets the ICE server.
        */
        setIceServer(value: fm.liveswitch.IceServer): void;
        /**
        Sets the ICE servers.
        */
        setIceServers(value: fm.liveswitch.IceServer[]): void;
        /**
        Sets a value indicating whether legacy Connection.Timeout should be used. When disabled, Connection.Timeout only accounts for the time spent trying to establish connectivity (i.e. time it takes to transition from the Connecting to the Connected state; from the time point when both offer and answer had been set to the connection being fully established). When enabled, Connection.Timeout accounts for the time spent from receiving an offer (or creating an offer) to establishing connectivity (i.e. time it takes to transition from Initializing to Connected state). By default, LegacyTimeout is set to true, so that existing behavior is preserved. However, in the future default will be updated to false. This means that IL will not account for any signalling delays that may occur while establishing connectivity. This option will be later deprecated.
        */
        setLegacyTimeout(value: boolean): void;
        /**
        Sets the local description.
        @param localDescription The local description.
        */
        setLocalDescription(localDescription: fm.liveswitch.SessionDescription): fm.liveswitch.Future<fm.liveswitch.SessionDescription>;
        /** @hidden */
        private setLocalDescriptionInternal;
        /**
        Sets the remote description.
        @param remoteDescription The remote description.
        */
        setRemoteDescription(remoteDescription: fm.liveswitch.SessionDescription): fm.liveswitch.Future<fm.liveswitch.SessionDescription>;
        /** @hidden */
        private setRemoteDescriptionInternal;
        /** @hidden */
        abstract setSessionDescriptionManager(value: fm.liveswitch.SessionDescriptionManagerBase<TStream, TAudioStream, TVideoStream, TDataStream, TDataChannel>): void;
        /**
        Sets the state of the signalling.
        */
        protected setSignallingState(value: fm.liveswitch.SignallingState): void;
        /** @hidden */
        setState(state: fm.liveswitch.ConnectionState): boolean;
        /** @hidden */
        setState(state: fm.liveswitch.ConnectionState, error: fm.liveswitch.Error): boolean;
        /**
        Sets the tie breaker.
        */
        setTieBreaker(value: string): void;
        /**
        Sets the amount of time (in milliseconds) to wait for a connection to establish before giving up and closing it. Defaults to 30,000.
        */
        setTimeout(value: number): void;
        /**
        Sets Trickle Ice Support Policy. Cf. https://tools.ietf.org/html/draft-ietf-ice-trickle-05
        */
        setTrickleIcePolicy(value: fm.liveswitch.TrickleIcePolicy): void;
        /** @hidden */
        setUseTrickleIce(value: boolean): void;
        /** @hidden */
        unregisterStreamWithSessionDescriptionManager(stream: TStream): void;
        /** @hidden */
        updateBundlePolicy(policy: fm.liveswitch.BundlePolicy): void;
        /** @hidden */
        updateRemoteCandidateIndex(candidate: fm.liveswitch.Candidate): void;
        /** @hidden */
        private updateRemoteDescriptionDtlsRole;
        /** @hidden */
        private verifySessionIdAndVersion;
    }
}
declare function fmicelinkWebRtcConnection_makeMediaStream(): MediaStream;
declare type fmicelinkWebRtcConnection_GlobalMediaStream = MediaStream;
declare namespace fm.liveswitch {
    class WebRtcConnection extends fm.liveswitch.WebRtcConnectionBase<fm.liveswitch.WebRtcConnection, fm.liveswitch.WebRtcStream, fm.liveswitch.WebRtcAudioStream, fm.liveswitch.WebRtcVideoStream, fm.liveswitch.WebRtcDataStream, fm.liveswitch.WebRtcDataChannel> implements fm.liveswitch.IInternalConnection {
        getTypeString(): string;
        /** @hidden */
        private _external;
        /** @hidden */
        _getExternal(): fm.liveswitch.IExternalConnection;
        /** @hidden */
        private _streams;
        /** @hidden */
        private _mediaStreams;
        /** @hidden */
        private _audioStreams;
        /** @hidden */
        private _videoStreams;
        /** @hidden */
        private _dataStreams;
        /** @hidden */
        private _offerer;
        /** @hidden */
        private _initialized;
        /** @hidden */
        private _localDescription;
        /** @hidden */
        private _remoteDescription;
        /** @hidden */
        private _gatheringState;
        /** @hidden */
        private _iceConnectionState;
        /** @hidden */
        private _remoteMedia;
        /** @hidden */
        private _isRenegotiation;
        getRemoteMedia(): fm.liveswitch.WebRtcRemoteMedia;
        /** @hidden */
        private _nativePeerConnection;
        getNativePeerConnection(): RTCPeerConnection;
        /** @hidden */
        private _discoveredCandidates;
        private _remoteMediaTrackCount;
        private _dataStreamsReady;
        private _mediaStreamsReady;
        /** @hidden */
        private _nativeIceGatherers;
        getNativeIceGatherers(): RTCIceGatherer[];
        /** @hidden */
        private _nativeIceTransports;
        getNativeIceTransports(): RTCIceTransport[];
        /** @hidden */
        private _nativeDtlsTransports;
        getNativeDtlsTransports(): RTCDtlsTransport[];
        /** @hidden */
        private _nativeRtpSenders;
        getNativeRtpSenders(): RTCRtpSender[];
        /** @hidden */
        private _nativeRtpReceivers;
        getNativeRtpReceivers(): RTCRtpReceiver[];
        /** @hidden */
        private _remoteNativeMediaStream;
        /** @hidden */
        private _rtpKinds;
        /** @hidden */
        private _ortcLocalDescription;
        /** @hidden */
        private _ortcRemoteDescription;
        /** @hidden */
        private _remoteCandidatesTimer;
        /** @hidden */
        private _remoteCandidatesDone;
        /** @hidden */
        private _transportsRemaining;
        /** @hidden */
        private _ortcSupportsTcp;
        constructor(external: fm.liveswitch.IExternalConnection, streams: fm.liveswitch.WebRtcStream[], remoteMedia: fm.liveswitch.WebRtcRemoteMedia);
        getInstance(): fm.liveswitch.WebRtcConnection;
        private addStreamInternal;
        private addStreamsInternal;
        processStateChange(): void;
        private startConnectionTimeout;
        getStreams(): fm.liveswitch.WebRtcStream[];
        getMediaStreams(): fm.liveswitch.WebRtcMediaStream<fm.liveswitch.WebRtcMediaTrack>[];
        getAudioStreams(): fm.liveswitch.WebRtcAudioStream[];
        getVideoStreams(): fm.liveswitch.WebRtcVideoStream[];
        getDataStreams(): fm.liveswitch.WebRtcDataStream[];
        private constraintMin;
        private constraintMax;
        getStats(): fm.liveswitch.Future<fm.liveswitch.ConnectionStats>;
        private getMediaSenderStats;
        private getMediaReceiverStats;
        private getTransportStats;
        private getCertificateStats;
        private getCandidateStats;
        private getCandidatePairStats;
        private getCodecStats;
        private getWebRTCBundlePolicyString;
        private _lastMediaComponentFrameStatsCollection;
        private getMediaTrackStats;
        private initialize;
        private setupTransceivers;
        private initializeTrack;
        private validateCandidate;
        private createIceGatherer;
        private sessionDescriptionTypeToString;
        private sessionDescriptionTypeToEnum;
        private webrtcCandidateToCandidate;
        private webrtcCandidateFromCandidate;
        private webrtcSessionDescriptionToSessionDescription;
        private webrtcSessionDescriptionFromSessionDescription;
        private rtcCandidateToSdpCandidateAttribute;
        private rtcCandidateFromSdpCandidateAttribute;
        private ortcCandidateToCandidate;
        private ortcCandidateFromCandidate;
        private ortcSessionDescriptionToSessionDescription;
        private ortcSessionDescriptionFromSessionDescription;
        private applyMediaFormatParametersAttributes;
        private applyMediaFeedbackAttributes;
        /** @hidden */
        private _iceCandidateProcessingTimeout;
        getIceCandidateProcessingTimeout(): number;
        setIceCandidateProcessingTimeout(value: number): void;
        protected doCreateOffer(promise: fm.liveswitch.Promise<fm.liveswitch.SessionDescription>): boolean;
        protected doCreateAnswer(promise: fm.liveswitch.Promise<fm.liveswitch.SessionDescription>): void;
        private processIceGatheringStateComplete;
        private injectDiscoveredCandidatesIntoSdp;
        private setNativeDescriptionSuccess;
        private modifyExtRtpMapId;
        private getExtRtpMapAttributesWithNoDuplicateUri;
        private reallocateRtpExtMapId;
        private reorderExtRtpMapIdsOnRenegotiationOffer;
        private doCreate;
        getLocalDescription(): fm.liveswitch.SessionDescription;
        getGatheringState(): fm.liveswitch.IceGatheringState;
        getIceConnectionState(): fm.liveswitch.IceConnectionState;
        protected setGatheringState(state: fm.liveswitch.IceGatheringState): void;
        protected setIceConnectionState(state: fm.liveswitch.IceConnectionState): void;
        getRemoteDescription(): fm.liveswitch.SessionDescription;
        /** @hidden */
        private _sessionDescriptionManager;
        /** @hidden */
        getSessionDescriptionManager(): fm.liveswitch.SessionDescriptionManager;
        /** @hidden */
        setSessionDescriptionManager(manager: fm.liveswitch.SessionDescriptionManager): void;
        private updateLocalDescription;
        protected doSetLocalDescription(promise: fm.liveswitch.Promise<fm.liveswitch.SessionDescription>, localDescription: fm.liveswitch.SessionDescription): void;
        private processRemoteDescriptionOnRenegotiation;
        private removeSdesAttributesIfNeeded;
        protected doSetRemoteDescription(promise: fm.liveswitch.Promise<fm.liveswitch.SessionDescription>, remoteDescription: fm.liveswitch.SessionDescription): void;
        protected doSendCachedLocalCandidates(): void;
        private startOrtc;
        private startOrtcTrack;
        private selectCodecs;
        private selectEncodings;
        private selectRtcp;
        protected doAddRemoteCandidate(promise: fm.liveswitch.Promise<fm.liveswitch.Candidate>, remoteCandidate: fm.liveswitch.Candidate): void;
        private setRemoteCandidatesDoneTimer;
        protected assignRemoteDescriptionInternal(sessionDescription: fm.liveswitch.SessionDescription): void;
        close(): boolean;
        private doClose;
        private dtmfSender;
        getDtmfSender(): RTCDtmfSender;
        replaceLocalTrack(localTrack: fm.liveswitch.WebRtcMediaTrack, mediaStream: fm.liveswitch.WebRtcMediaStream<fm.liveswitch.WebRtcMediaTrack>): fm.liveswitch.Future<object>;
        replaceRemoteTrack(remoteTrack: fm.liveswitch.WebRtcMediaTrack, mediaStream: fm.liveswitch.WebRtcMediaStream<fm.liveswitch.WebRtcMediaTrack>): fm.liveswitch.Future<object>;
        private getRtpSender;
        private tryGetRtpSender;
        private _setMaxSendBitrateQueue;
        private _processingMaxSendBitrate;
        setMaxSendBitrate(bitrate: number, streamType: fm.liveswitch.StreamType): fm.liveswitch.Future<object>;
        private processNextSetMaxSendBitrate;
        private doSetMaxSendBitrate;
        private updateMaxBitrateSdpMessage;
        private updateMaxBitrateSdpMediaDescription;
        /** @hidden */
        private static __webRtcConnectionInitialized;
        /** @hidden */
        static webRtcConnectionInitialize(): void;
    }
}
declare namespace fm.liveswitch {
    /**
    Data channel base properties/methods.
    */
    abstract class WebRtcDataChannelBase<TDataChannel> extends fm.liveswitch.Dynamic implements fm.liveswitch.IDataChannel<TDataChannel> {
        getTypeString(): string;
        /** @hidden */
        private __bytesReceived;
        /** @hidden */
        private __bytesSent;
        /** @hidden */
        private __id;
        /** @hidden */
        private __log;
        /** @hidden */
        private __messagesReceived;
        /** @hidden */
        private __messagesSent;
        /** @hidden */
        private __onDataReceived;
        /** @hidden */
        private __onDataSent;
        /** @hidden */
        private __onStateChange;
        /** @hidden */
        private __stateLock;
        /** @hidden */
        private __stateMachine;
        /** @hidden */
        private _connectionId;
        /** @hidden */
        private _getRemoteConnectionInfo;
        /** @hidden */
        private _label;
        /** @hidden */
        private _onDataReceived;
        /** @hidden */
        private _onDataSent;
        /** @hidden */
        private _onReceive;
        /** @hidden */
        private _onStateChange;
        /** @hidden */
        private _ordered;
        /** @hidden */
        private _streamId;
        /** @hidden */
        private _subprotocol;
        private fmliveswitchWebRtcDataChannelBaseInit;
        /**
        Initializes a new instance of the [[fm.liveswitch.dataChannelBase]] class.
        @param label The label.
        @param ordered Whether messages will be delivered in the order they are sent.
        @param subprotocol The subprotocol.
        */
        constructor(label: string, ordered: boolean, subprotocol: string);
        /** @hidden */
        addOnDataReceived(value: fm.liveswitch.IAction1<number>): void;
        /** @hidden */
        addOnDataSent(value: fm.liveswitch.IAction1<number>): void;
        /**
        Adds a handler that is raised when the data channel state changes.
        */
        addOnStateChange(value: fm.liveswitch.IAction1<TDataChannel>): void;
        /**
        Gets the number of bytes received.
        */
        getBytesReceived(): number;
        /**
        Gets the number of bytes sent.
        */
        getBytesSent(): number;
        /**
        Gets the connection identifier.
        */
        getConnectionId(): string;
        /** @hidden */
        getGetRemoteConnectionInfo(): fm.liveswitch.IFunction1<string, Object>;
        /**
        Gets the identifier.
        */
        getId(): string;
        /**
        Gets the data channel info.
        */
        getInfo(): fm.liveswitch.DataChannelInfo;
        /**
        Gets the current instance.
        */
        protected abstract getInstance(): TDataChannel;
        /**
        Gets a value indicating whether the data channel is currently closed or failed.
        */
        getIsTerminated(): boolean;
        /**
        Gets a value indicating whether the data channel is currently closing.
        */
        getIsTerminating(): boolean;
        /**
        Gets a value indicating whether the data channel is currently closing, closed, or failed.
        */
        getIsTerminatingOrTerminated(): boolean;
        /**
        Gets the label.
        */
        getLabel(): string;
        /**
        Gets the number of messages received.
        */
        getMessagesReceived(): number;
        /**
        Gets the number of messages sent.
        */
        getMessagesSent(): number;
        /**
        Gets the callback to execute when a message is received.
        */
        getOnReceive(): fm.liveswitch.IAction1<fm.liveswitch.DataChannelReceiveArgs>;
        /**
        Gets a value indicating whether messages will be delivered in the order they are sent.
        */
        getOrdered(): boolean;
        /**
        Gets the state.
        */
        getState(): fm.liveswitch.DataChannelState;
        /** @hidden */
        getStateLock(): Object;
        /**
        Gets the stream identifier.
        */
        getStreamId(): string;
        /**
        Gets the subprotocol.
        */
        getSubprotocol(): string;
        /** @hidden */
        private logInvalidStateTransition;
        /** @hidden */
        prepareAndSendMessage(buffer: fm.liveswitch.DataBuffer, promise: fm.liveswitch.Promise<Object>): void;
        /** @hidden */
        prepareAndSendMessage(msg: string, promise: fm.liveswitch.Promise<Object>): void;
        /**
        Processes a state change.
        */
        protected processStateChange(): void;
        /**
        Processes a state lock change.
        */
        protected processStateLockChange(): void;
        /** @hidden */
        abstract promisedSendDataBytes(dataBytes: fm.liveswitch.DataBuffer, dataLength: number, promise: fm.liveswitch.Promise<Object>): void;
        /** @hidden */
        abstract promisedSendDataString(dataString: string, dataLength: number, promise: fm.liveswitch.Promise<Object>): void;
        /**
        Raises the OnReceive callback with data bytes.
        @param dataBytes The data bytes.
        */
        protected raiseDataBytes(dataBytes: fm.liveswitch.DataBuffer): void;
        /**
        Raises the OnReceive callback with a data string.
        @param dataString The data string.
        */
        protected raiseDataString(dataString: string): void;
        /** @hidden */
        private raiseStateChange;
        /**
        Registers that a data has been sent.
        @param dataLength The data length.
        */
        protected registerDataReceived(dataLength: number): void;
        /**
        Registers that a data has been sent.
        @param dataLength The data length.
        */
        protected registerDataSent(dataLength: number): void;
        /** @hidden */
        removeOnDataReceived(value: fm.liveswitch.IAction1<number>): void;
        /** @hidden */
        removeOnDataSent(value: fm.liveswitch.IAction1<number>): void;
        /**
        Removes a handler that is raised when the data channel state changes.
        */
        removeOnStateChange(value: fm.liveswitch.IAction1<TDataChannel>): void;
        /**
        Sends some bytes.
        @param dataBytes The data bytes.
        */
        abstract sendDataBytes(dataBytes: fm.liveswitch.DataBuffer): fm.liveswitch.Future<Object>;
        /**
        Sends a string.
        @param dataString The data string.
        */
        abstract sendDataString(dataString: string): fm.liveswitch.Future<Object>;
        /** @hidden */
        setConnectionId(value: string): void;
        /** @hidden */
        setGetRemoteConnectionInfo(value: fm.liveswitch.IFunction1<string, Object>): void;
        /** @hidden */
        private setLabel;
        /**
        Sets the callback to execute when a message is received.
        */
        setOnReceive(value: fm.liveswitch.IAction1<fm.liveswitch.DataChannelReceiveArgs>): void;
        /** @hidden */
        private setOrdered;
        /** @hidden */
        setState(state: fm.liveswitch.DataChannelState): boolean;
        /** @hidden */
        setStateLock(value: Object): void;
        /** @hidden */
        setStreamId(value: string): void;
        /** @hidden */
        private setSubprotocol;
    }
}
declare namespace fm.liveswitch {
    class WebRtcDataChannel extends fm.liveswitch.WebRtcDataChannelBase<fm.liveswitch.WebRtcDataChannel> implements fm.liveswitch.IInternalDataChannel {
        getTypeString(): string;
        /** @hidden */
        private _external;
        /** @hidden */
        _getExternal(): fm.liveswitch.IExternalDataChannel;
        /** @hidden */
        private sendQueue;
        /** @hidden */
        private _nativeDataChannel;
        getNativeDataChannel(): any;
        setNativeDataChannel(nativeDataChannel: any): void;
        constructor(external: fm.liveswitch.IExternalDataChannel, label: string, ordered?: boolean, subprotocol?: string);
        getInstance(): fm.liveswitch.WebRtcDataChannel;
        sendDataString(dataString: string): fm.liveswitch.Future<Object>;
        /** @hidden */
        promisedSendDataBytes(dataBytes: fm.liveswitch.DataBuffer, dataLength: number, promise: fm.liveswitch.Promise<Object>): void;
        /** @hidden */
        promisedSendDataString(dataString: string, dataLength: number, promise: fm.liveswitch.Promise<Object>): void;
        sendDataBytes(dataBytes: fm.liveswitch.DataBuffer): fm.liveswitch.Future<Object>;
    }
}
declare namespace fm.liveswitch {
    /**
    Data stream base properties/methods.
    */
    abstract class WebRtcDataStreamBase<TDataChannel extends fm.liveswitch.WebRtcDataChannelBase<TDataChannel>> extends fm.liveswitch.WebRtcStream implements fm.liveswitch.IDataStream<TDataChannel>, fm.liveswitch.IStream {
        getTypeString(): string;
        /** @hidden */
        private __bytesReceived;
        /** @hidden */
        private __bytesSent;
        /** @hidden */
        private __getRemoteConnectionInfo;
        /** @hidden */
        private __messagesReceived;
        /** @hidden */
        private __messagesSent;
        /** @hidden */
        private __obsoleteCanonicalName;
        /**
        Initializes a new instance of the [[fm.liveswitch.dataStreamBase]] class.
        */
        constructor();
        /**
        Attaches a data channel to this stream (events and IDs).
        @param channel
        */
        protected attachToChannel(channel: TDataChannel): void;
        /**
        Changes this stream's direction
        */
        changeDirection(newDirection: fm.liveswitch.StreamDirection): fm.liveswitch.Error;
        /**
        Gets the number of bytes received.
        */
        getBytesReceived(): number;
        /**
        Gets the number of bytes sent.
        */
        getBytesSent(): number;
        /**
        Gets the canonical name. Getting the value of DataStream.CanonicalName is deprecated and will be removed in a future release.
        */
        getCanonicalName(): string;
        /**
        Gets the channels.
        */
        abstract getChannels(): TDataChannel[];
        /**
        Gets the current direction.
        */
        getDirection(): fm.liveswitch.StreamDirection;
        /** @hidden */
        getDirectionCapabilities(): fm.liveswitch.StreamDirection;
        /** @hidden */
        getGetRemoteConnectionInfo(): fm.liveswitch.IFunction1<string, Object>;
        /**
        Gets the data stream info.
        */
        getInfo(): fm.liveswitch.DataStreamInfo;
        /**
        Gets a label that identifies this class.
        */
        getLabel(): string;
        /**
        Gets the current direction.
        */
        getLocalDirection(): fm.liveswitch.StreamDirection;
        /**
        Gets the number of messages received.
        */
        getMessagesReceived(): number;
        /**
        Gets the number of messages sent.
        */
        getMessagesSent(): number;
        /**
        Gets the current direction.
        */
        getRemoteDirection(): fm.liveswitch.StreamDirection;
        /**
        Processes a state change.
        */
        protected processStateChange(): void;
        /**
        Processes a state lock change.
        */
        protected processStateLockChange(): void;
        /**
        Registers that a data has been received.
        @param dataLength The data length.
        */
        protected registerDataReceived(dataLength: number): void;
        /**
        Registers that a data has been received.
        @param dataLength The data length.
        */
        protected registerDataSent(dataLength: number): void;
        /** @hidden */
        setCanonicalName(canonicalName: string): void;
        /** @hidden */
        setGetRemoteConnectionInfo(value: fm.liveswitch.IFunction1<string, Object>): void;
        /**
        Sets the current direction.
        */
        setLocalDirection(value: fm.liveswitch.StreamDirection): void;
        /** @hidden */
        setRemoteDirection(value: fm.liveswitch.StreamDirection): void;
    }
}
declare namespace fm.liveswitch {
    class WebRtcDataStream extends fm.liveswitch.WebRtcDataStreamBase<fm.liveswitch.WebRtcDataChannel> implements fm.liveswitch.IInternalDataStream {
        getTypeString(): string;
        processSdpMediaDescription(sdpMessage: fm.liveswitch.sdp.Message, sdpMediaDescription: fm.liveswitch.sdp.MediaDescription, index: number, isLocalDescription: boolean, isOffer: boolean, isRenegotiation: boolean): fm.liveswitch.Error;
        /** @hidden */
        private _external;
        /** @hidden */
        _getExternal(): fm.liveswitch.IExternalDataStream;
        /** @hidden */
        private _channels;
        constructor(external: fm.liveswitch.IExternalDataStream, channels: fm.liveswitch.WebRtcDataChannel[]);
        getChannels(): fm.liveswitch.WebRtcDataChannel[];
    }
}
declare namespace fm.liveswitch {
    class WebRtcDomAudioSink extends fm.liveswitch.Dynamic implements fm.liveswitch.IInternalDomAudioSink {
        getTypeString(): string;
        getTrack(): fm.liveswitch.WebRtcAudioTrack;
        getLocal(): boolean;
        getAudio(): HTMLAudioElement;
        getVolume(): number;
        setVolume(volume: number): void;
        getMuted(): boolean;
        setMuted(muted: boolean): void;
        constructor(external: fm.liveswitch.DomAudioSink, track: fm.liveswitch.WebRtcAudioTrack);
        setTrack(track: fm.liveswitch.WebRtcAudioTrack): boolean;
        private playAudio;
    }
}
declare namespace fm.liveswitch {
    class WebRtcDomVideoSink extends fm.liveswitch.Dynamic implements fm.liveswitch.IInternalDomVideoSink {
        getTypeString(): string;
        getTrack(): fm.liveswitch.WebRtcVideoTrack;
        getLocal(): boolean;
        getView(): HTMLElement;
        getViewScale(): fm.liveswitch.LayoutScale;
        setViewScale(viewScale: fm.liveswitch.LayoutScale): void;
        getViewMirror(): boolean;
        setViewMirror(viewMirror: boolean): void;
        getVideo(): HTMLVideoElement;
        getVideoWidth(): number;
        getVideoHeight(): number;
        getVolume(): number;
        setVolume(volume: number): void;
        getMuted(): boolean;
        setMuted(muted: boolean): void;
        destroy(): void;
        constructor(external: fm.liveswitch.IExternalDomVideoSink, track: fm.liveswitch.WebRtcVideoTrack);
        setTrack(track: fm.liveswitch.WebRtcVideoTrack): boolean;
        private playVideo;
        private applyScale;
    }
}
declare namespace fm.liveswitch {
    /**
    A collection of audio/video track base methods/properties.
    */
    abstract class WebRtcMediaBase<TIAudioTrack extends fm.liveswitch.IAudioTrack, TIVideoTrack extends fm.liveswitch.IVideoTrack> extends fm.liveswitch.Dynamic implements fm.liveswitch.IMedia<TIAudioTrack, TIVideoTrack> {
        getTypeString(): string;
        /** @hidden */
        private _id;
        /**
        Initializes a new instance of the [[fm.liveswitch.mediaBase]] class.
        */
        constructor();
        /**
        Adds a handler that is raised when the first audio track is destroyed.
        */
        abstract addOnAudioDestroyed(value: fm.liveswitch.IAction0): void;
        /**
        Adds a handler that is raised whenever the level of the first audio track is calculated.
        */
        abstract addOnAudioLevel(value: fm.liveswitch.IAction1<number>): void;
        /**
        Adds a handler that is raised when the first video track is destroyed.
        */
        abstract addOnVideoDestroyed(value: fm.liveswitch.IAction0): void;
        /**
        Adds a handler that is raised whenever the size of the first video track is calculated.
        */
        abstract addOnVideoSize(value: fm.liveswitch.IAction1<fm.liveswitch.Size>): void;
        /**
        Destroys this media.
        */
        abstract destroy(): void;
        /**
        Gets a value indicating the gain (input amplification) of the first audio track.
        */
        getAudioGain(): number;
        /**
        Gets a value indicating whether the first audio track is muted.
        */
        getAudioMuted(): boolean;
        /**
        Gets the first audio track.
        */
        getAudioTrack(): TIAudioTrack;
        /**
        Gets the audio tracks.
        */
        abstract getAudioTracks(): TIAudioTrack[];
        /**
        Gets a value indicating the volume (output resistance) of the first audio track.
        */
        getAudioVolume(): number;
        /**
        Gets the identifier.
        */
        getId(): string;
        /**
        Gets a value indicating whether the first video track is muted.
        */
        getVideoMuted(): boolean;
        /**
        Gets the size of the first video track.
        */
        abstract getVideoSize(): fm.liveswitch.Size;
        /**
        Gets the first video track.
        */
        getVideoTrack(): TIVideoTrack;
        /**
        Gets the video tracks.
        */
        abstract getVideoTracks(): TIVideoTrack[];
        /**
        Grabs a frame from the first video track.
        */
        abstract grabVideoFrame(): fm.liveswitch.Future<fm.liveswitch.VideoBuffer>;
        /**
        Removes a handler that is raised when the first audio track is destroyed.
        */
        abstract removeOnAudioDestroyed(value: fm.liveswitch.IAction0): void;
        /**
        Removes a handler that is raised whenever the level of the first audio track is calculated.
        */
        abstract removeOnAudioLevel(value: fm.liveswitch.IAction1<number>): void;
        /**
        Removes a handler that is raised when the first video track is destroyed.
        */
        abstract removeOnVideoDestroyed(value: fm.liveswitch.IAction0): void;
        /**
        Removes a handler that is raised whenever the size of the first video track is calculated.
        */
        abstract removeOnVideoSize(value: fm.liveswitch.IAction1<fm.liveswitch.Size>): void;
        /**
        Sets a value indicating the gain (input amplification) of the first audio track.
        */
        setAudioGain(value: number): void;
        /**
        Sets a value indicating whether the first audio track is muted.
        */
        setAudioMuted(value: boolean): void;
        /**
        Sets a value indicating the volume (output resistance) of the first audio track.
        */
        setAudioVolume(value: number): void;
        /**
        Sets the identifier.
        */
        setId(value: string): void;
        /**
        Sets a value indicating whether the first video track is muted.
        */
        setVideoMuted(value: boolean): void;
    }
}
declare type fmicelinkWebRtcMedia_GlobalMediaStream = MediaStream;
declare namespace fm.liveswitch {
    abstract class WebRtcMedia<TAudioTrack extends fm.liveswitch.WebRtcAudioTrack, TVideoTrack extends fm.liveswitch.WebRtcVideoTrack> extends fm.liveswitch.WebRtcMediaBase<fm.liveswitch.WebRtcAudioTrack, fm.liveswitch.WebRtcVideoTrack> implements fm.liveswitch.IMedia<fm.liveswitch.WebRtcAudioTrack, fm.liveswitch.WebRtcVideoTrack>, fm.liveswitch.IInternalMedia {
        getTypeString(): string;
        protected _setAudioMediaStream(audioMediaStream: fmicelinkWebRtcMedia_GlobalMediaStream): boolean;
        protected _setVideoMediaStream(videoMediaStream: fmicelinkWebRtcMedia_GlobalMediaStream): boolean;
        getAudio(): any;
        setAudio(audio: any): void;
        getVideo(): any;
        setVideo(video: any): void;
        constructor(external: any | fm.liveswitch.IExternalMedia);
        addOnAudioDestroyed(value: fm.liveswitch.IAction0): void;
        addOnVideoDestroyed(value: fm.liveswitch.IAction0): void;
        removeOnAudioDestroyed(value: fm.liveswitch.IAction0): void;
        removeOnVideoDestroyed(value: fm.liveswitch.IAction0): void;
        addOnAudioLevel(value: fm.liveswitch.IAction1<number>): void;
        addOnVideoSize(value: fm.liveswitch.IAction1<fm.liveswitch.Size>): void;
        destroy(): void;
        getAudioGain(): number;
        getAudioTracks(): fm.liveswitch.WebRtcAudioTrack[];
        getAudioVolume(): number;
        getVideoSize(): fm.liveswitch.Size;
        getVideoTracks(): fm.liveswitch.WebRtcVideoTrack[];
        getAudioSink(): fm.liveswitch.WebRtcDomAudioSink;
        getVideoSink(): fm.liveswitch.WebRtcDomVideoSink;
        getView(): HTMLElement;
        getViewSink(): fm.liveswitch.WebRtcDomVideoSink;
        grabVideoFrame(): fm.liveswitch.Future<fm.liveswitch.VideoBuffer>;
        removeOnAudioLevel(value: fm.liveswitch.IAction1<number>): void;
        removeOnVideoSize(value: fm.liveswitch.IAction1<fm.liveswitch.Size>): void;
        setAudioGain(value: number): void;
        setAudioVolume(value: number): void;
        protected initializeAudioContext(): void;
        protected destroyAudioContext(): void;
    }
}
declare namespace fm.liveswitch {
    /**
    A collection of local audio/video track base methods.
    */
    abstract class WebRtcLocalMediaBase<TLocalMedia extends fm.liveswitch.WebRtcLocalMediaBase<TLocalMedia, TAudioTrack, TVideoTrack>, TAudioTrack extends fm.liveswitch.WebRtcAudioTrack, TVideoTrack extends fm.liveswitch.WebRtcVideoTrack> extends fm.liveswitch.WebRtcMedia<TAudioTrack, TVideoTrack> {
        getTypeString(): string;
        /** @hidden */
        private __audioEncodingsSet;
        /** @hidden */
        private __audioEncodingsSetLock;
        /** @hidden */
        private __audioSimulcast;
        /** @hidden */
        private __stateLock;
        /** @hidden */
        private __videoEncodingsSet;
        /** @hidden */
        private __videoEncodingsSetLock;
        /** @hidden */
        private __videoSimulcast;
        /** @hidden */
        private _state;
        /** @hidden */
        private static fm_liveswitch_WebRtcLocalMediaBase___defaultVideoBitsPerPixel;
        private fmliveswitchWebRtcLocalMediaBaseInit;
        /**
        Initializes a new instance of the [[fm.liveswitch.localMediaBase]] class.
        @param external The external.
        */
        constructor(external: Object);
        /**
        Gets the default bits-per-pixel for video.
        */
        static getDefaultVideoBitsPerPixel(): number;
        /**
        Sets the default bits-per-pixel for video.
        */
        static setDefaultVideoBitsPerPixel(value: number): void;
        /**
        Aborts the start.
        @param promise The promise.
        @param exception The exception.
        */
        protected abortStart(promise: fm.liveswitch.Promise<TLocalMedia>, exception: fm.liveswitch.Exception): void;
        /**
        Gets the local audio encodings.
        @return The local audio encodings.
        */
        protected abstract doGetAudioEncodings(): fm.liveswitch.AudioEncodingConfig[];
        /**
        Gets the local video encodings.
        @return The local video encodings.
        */
        protected abstract doGetVideoEncodings(): fm.liveswitch.VideoEncodingConfig[];
        /**
        Sets the local audio encodings.
        @param encodings The local audio encodings.
        */
        protected abstract doSetAudioEncodings(encodings: fm.liveswitch.AudioEncodingConfig[]): void;
        /**
        Sets the local video encodings.
        @param encodings The local video encodings.
        */
        protected abstract doSetVideoEncodings(encodings: fm.liveswitch.VideoEncodingConfig[]): void;
        /**
        Starts the local media.
        */
        protected abstract doStart(): fm.liveswitch.Future<TLocalMedia>;
        /**
        Stops the local media.
        */
        protected abstract doStop(): fm.liveswitch.Future<TLocalMedia>;
        /**
        Gets the first (primary) local audio encoding.
        */
        getAudioEncoding(): fm.liveswitch.AudioEncodingConfig;
        /**
        Gets the local audio encodings.
        */
        getAudioEncodings(): fm.liveswitch.AudioEncodingConfig[];
        /**
        Gets whether audio simulcast is disabled.
        */
        getAudioSimulcastDisabled(): boolean;
        /**
        Gets the number of audio simulcast encodings.
        */
        getAudioSimulcastEncodingCount(): number;
        /**
        Gets the preferred audio simulcast bitrate, in kbps.
        */
        getAudioSimulcastPreferredBitrate(): number;
        /**
        Gets the state.
        */
        getState(): fm.liveswitch.LocalMediaState;
        /**
        Gets the first (primary) local video encoding.
        */
        getVideoEncoding(): fm.liveswitch.VideoEncodingConfig;
        /**
        Gets the local video encodings.
        */
        getVideoEncodings(): fm.liveswitch.VideoEncodingConfig[];
        /**
        Gets the desired video simulcast bits-per-pixel (bpp). If this value is set and the video source has declared a target width, height, and frame-rate, encoding bitrates will be automatically calculated using this value instad of using preferred bitrate.
        */
        getVideoSimulcastBitsPerPixel(): number;
        /**
        Gets the video simulcast degradation preference.
        */
        getVideoSimulcastDegradationPreference(): fm.liveswitch.VideoDegradationPreference;
        /**
        Gets whether video simulcast is disabled.
        */
        getVideoSimulcastDisabled(): boolean;
        /**
        Gets the number of video simulcast encodings.
        */
        getVideoSimulcastEncodingCount(): number;
        /**
        Gets the preferred video simulcast bitrate, in kbps.
        */
        getVideoSimulcastPreferredBitrate(): number;
        /** @hidden */
        private initializeSimulcastConfigs;
        /**
        Locks the audio encodings in prior to initialization.
        */
        protected lockAudioEncodings(): void;
        /**
        Locks the video encodings in prior to initialization.
        */
        protected lockVideoEncodings(): void;
        /**
        Locks the video encodings in prior to initialization.
        */
        protected lockVideoEncodings(sourceType: fm.liveswitch.VideoType): void;
        /**
        Locks the video encodings in prior to initialization.
        */
        protected lockVideoEncodings(sourceType: fm.liveswitch.VideoType, sourceWidth: number, sourceHeight: number, sourceFrameRate: number): void;
        /**
        Sets the local audio encodings.
        */
        setAudioEncodings(value: fm.liveswitch.AudioEncodingConfig[]): void;
        /**
        Sets whether audio simulcast is disabled.
        */
        setAudioSimulcastDisabled(value: boolean): void;
        /**
        Sets the number of audio simulcast encodings.
        */
        setAudioSimulcastEncodingCount(value: number): void;
        /**
        Sets the preferred audio simulcast bitrate, in kbps.
        */
        setAudioSimulcastPreferredBitrate(value: number): void;
        /** @hidden */
        private setState;
        /**
        Sets the local video encodings.
        */
        setVideoEncodings(value: fm.liveswitch.VideoEncodingConfig[]): void;
        /**
        Sets the desired video simulcast bits-per-pixel (bpp). If this value is set and the video source has declared a target width, height, and frame-rate, encoding bitrates will be automatically calculated using this value instad of using preferred bitrate.
        */
        setVideoSimulcastBitsPerPixel(value: number): void;
        /**
        Sets the video simulcast degradation preference.
        */
        setVideoSimulcastDegradationPreference(value: fm.liveswitch.VideoDegradationPreference): void;
        /**
        Sets whether video simulcast is disabled.
        */
        setVideoSimulcastDisabled(value: boolean): void;
        /**
        Sets the number of video simulcast encodings.
        */
        setVideoSimulcastEncodingCount(value: number): void;
        /**
        Sets the preferred video simulcast bitrate, in kbps.
        */
        setVideoSimulcastPreferredBitrate(value: number): void;
        /**
        Starts the media track sources.
        */
        start(): fm.liveswitch.Future<TLocalMedia>;
        /** @hidden */
        private startInternal;
        /**
        Stops the media track sources.
        */
        stop(): fm.liveswitch.Future<TLocalMedia>;
        /** @hidden */
        private stopInternal;
        /** @hidden */
        private static __fmliveswitchWebRtcLocalMediaBaseInitialized;
        /** @hidden */
        private static __fmliveswitchWebRtcLocalMediaBaseInitializing;
        /** @hidden */
        static fmliveswitchWebRtcLocalMediaBaseInitialize(): void;
    }
}
declare type fmicelinkWebRtcLocalMedia_GlobalMediaStream = MediaStream;
declare namespace fm.liveswitch {
    class WebRtcLocalMedia extends fm.liveswitch.WebRtcLocalMediaBase<fm.liveswitch.WebRtcLocalMedia, fm.liveswitch.WebRtcAudioTrack, fm.liveswitch.WebRtcVideoTrack> implements fm.liveswitch.ILocalMedia<fm.liveswitch.WebRtcLocalMedia, fm.liveswitch.WebRtcAudioTrack, fm.liveswitch.WebRtcVideoTrack>, fm.liveswitch.IInternalLocalMedia {
        getTypeString(): string;
        addOnAudioStarted(value: fm.liveswitch.IAction0): void;
        addOnAudioStopped(value: fm.liveswitch.IAction0): void;
        addOnVideoStarted(value: fm.liveswitch.IAction0): void;
        addOnVideoStopped(value: fm.liveswitch.IAction0): void;
        removeOnAudioStarted(value: fm.liveswitch.IAction0): void;
        removeOnAudioStopped(value: fm.liveswitch.IAction0): void;
        removeOnVideoStarted(value: fm.liveswitch.IAction0): void;
        removeOnVideoStopped(value: fm.liveswitch.IAction0): void;
        getAudioSourceInputs(): fm.liveswitch.Future<fm.liveswitch.SourceInput[]>;
        getVideoSourceInputs(): fm.liveswitch.Future<fm.liveswitch.SourceInput[]>;
        private getSourceInputs;
        private _audioSourceInput;
        getAudioSourceInput(): fm.liveswitch.SourceInput;
        setAudioSourceInput(audioInput: fm.liveswitch.SourceInput): void;
        private _videoSourceInput;
        getVideoSourceInput(): fm.liveswitch.SourceInput;
        setVideoSourceInput(videoInput: fm.liveswitch.SourceInput): void;
        getScreen(): boolean;
        setScreen(screen: boolean): void;
        getAudioConstraints(): MediaTrackConstraints;
        getVideoConstraints(): MediaTrackConstraints;
        changeAudioConstraints(audioConstraints: MediaTrackConstraints): fm.liveswitch.Future<Object>;
        changeVideoConstraints(videoConstraints: MediaTrackConstraints): fm.liveswitch.Future<Object>;
        changeAudioSourceInput(audioSourceInput: fm.liveswitch.SourceInput): fm.liveswitch.Future<Object>;
        changeVideoSourceInput(videoSourceInput: fm.liveswitch.SourceInput): fm.liveswitch.Future<Object>;
        constructor(external: fm.liveswitch.IExternalLocalMedia, audio: any, video: any, screen?: boolean);
        doStart(): fm.liveswitch.Future<fm.liveswitch.WebRtcLocalMedia>;
        private doStartInternal;
        doStop(): fm.liveswitch.Future<fm.liveswitch.WebRtcLocalMedia>;
        protected doGetAudioEncodings(): fm.liveswitch.AudioEncodingConfig[];
        protected doSetAudioEncodings(encodings: fm.liveswitch.AudioEncodingConfig[]): void;
        protected doGetVideoEncodings(): fm.liveswitch.VideoEncodingConfig[];
        protected doSetVideoEncodings(encodings: fm.liveswitch.VideoEncodingConfig[]): void;
    }
}
declare namespace fm.liveswitch {
    class WebRtcRemoteMedia extends fm.liveswitch.WebRtcMedia<fm.liveswitch.WebRtcAudioTrack, fm.liveswitch.WebRtcVideoTrack> implements fm.liveswitch.IRemoteMedia<fm.liveswitch.WebRtcAudioTrack, fm.liveswitch.WebRtcVideoTrack>, fm.liveswitch.IInternalRemoteMedia {
        getTypeString(): string;
        constructor(external: fm.liveswitch.IExternalRemoteMedia, audio: boolean, video: boolean);
        getAudioSinkOutputs(): fm.liveswitch.Future<fm.liveswitch.SinkOutput[]>;
        getVideoSinkOutputs(): fm.liveswitch.Future<fm.liveswitch.SinkOutput[]>;
        private getSinkOutputs;
        getAudioSinkOutput(): fm.liveswitch.SinkOutput;
        setAudioSinkOutput(audioSinkOutput: fm.liveswitch.SinkOutput): void;
        private attachAudioSinkOutput;
        getVideoSinkOutput(): fm.liveswitch.SinkOutput;
        setVideoSinkOutput(videoSinkOutput: fm.liveswitch.SinkOutput): void;
        changeAudioSinkOutput(audioInput: fm.liveswitch.SinkOutput): fm.liveswitch.Future<Object>;
        changeVideoSinkOutput(videoInput: fm.liveswitch.SinkOutput): fm.liveswitch.Future<Object>;
    }
}
declare namespace fm.liveswitch {
    class WebRtcVideoStream extends fm.liveswitch.WebRtcMediaStream<fm.liveswitch.WebRtcVideoTrack> implements fm.liveswitch.IVideoStream, fm.liveswitch.IInternalVideoStream {
        getTypeString(): string;
        /** @hidden */
        private _external;
        /** @hidden */
        _getExternal(): fm.liveswitch.IExternalVideoStream;
        constructor(external: fm.liveswitch.IExternalVideoStream, localTrack: fm.liveswitch.WebRtcVideoTrack, remoteTrack: fm.liveswitch.WebRtcVideoTrack);
        getVp8Disabled(): boolean;
        getVp9Disabled(): boolean;
        getH264Disabled(): boolean;
        getH265Disabled(): boolean;
        setVp8Disabled(value: boolean): void;
        setVp9Disabled(value: boolean): void;
        setH264Disabled(value: boolean): void;
        setH265Disabled(value: boolean): void;
        addOnDiscardKeyFrameRequest(value: fm.liveswitch.IAction1<number[]>): void;
        removeOnDiscardKeyFrameRequest(value: fm.liveswitch.IAction1<number[]>): void;
        raiseKeyFrameRequest(synchronizationSources: number[]): void;
    }
}
declare namespace fm.liveswitch {
    class WebRtcVideoTrack extends fm.liveswitch.WebRtcMediaTrack implements fm.liveswitch.IVideoTrack, fm.liveswitch.IInternalVideoTrack {
        getTypeString(): string;
        constructor(external: fm.liveswitch.IExternalVideoTrack, media: fm.liveswitch.WebRtcMedia<fm.liveswitch.WebRtcAudioTrack, fm.liveswitch.WebRtcVideoTrack>);
        setConfig(config: fm.liveswitch.VideoConfig): void;
        private isLocal;
        changeSinkOutput(sinkOutput: fm.liveswitch.SinkOutput): fm.liveswitch.Future<Object>;
        getSinkOutput(): fm.liveswitch.SinkOutput;
        getSinkOutputs(): fm.liveswitch.Future<fm.liveswitch.SinkOutput[]>;
        setSinkOutput(value: fm.liveswitch.SinkOutput): void;
        changeSourceInput(sourceInput: fm.liveswitch.SourceInput): fm.liveswitch.Future<Object>;
        getSourceInput(): fm.liveswitch.SourceInput;
        getSourceInputs(): fm.liveswitch.Future<fm.liveswitch.SourceInput[]>;
        setSourceInput(value: fm.liveswitch.SourceInput): void;
        addOnSize(value: fm.liveswitch.IAction1<fm.liveswitch.Size>): void;
        getSize(): fm.liveswitch.Size;
        grabFrame(): fm.liveswitch.Future<fm.liveswitch.VideoBuffer>;
        removeOnSize(value: fm.liveswitch.IAction1<fm.liveswitch.Size>): void;
    }
}
declare namespace fm.liveswitch {
    /**
    A crypto library.
    */
    enum CryptoLibrary {
        /**
        Indicates that the default library should be used.
        */
        Default = 1
    }
}
declare namespace fm.liveswitch {
    /**
    Address types.
    */
    enum AddressType {
        /**
        Indicates an IP version 4 address.
        */
        IPv4 = 1,
        /**
        Indicates an IP version 6 address.
        */
        IPv6 = 2,
        /**
        Indicates an unknown address type.
        */
        Unknown = 3
    }
}
declare namespace fm.liveswitch {
    /** @hidden */
    enum JsonCheckerMode {
        Array = 1,
        Done = 2,
        Key = 3,
        Object = 4,
        String = 5
    }
}
declare namespace fm.liveswitch {
    /**
    An operating system.
    */
    enum OperatingSystem {
        /**
        Indicates an unknown or default OS.
        */
        Unknown = 1,
        /**
        Indicates a Windows operating system.
        */
        Windows = 2,
        /**
        Indicates a Android operating system.
        */
        Android = 3,
        /**
        Indicates a macOS operating system.
        */
        MacOS = 4,
        /**
        Indicates a iOS operating system.
        */
        IOS = 5,
        /**
        Indicates a Linux operating system.
        */
        Linux = 6,
        /**
        Indicates a tvOS operating system.
        */
        TvOS = 7,
        /**
        Indicates a watchOS operating system.
        */
        WatchOS = 8
    }
}
declare namespace fm.liveswitch {
    /**
    A CPU architecture.
    */
    enum Architecture {
        /**
        Indicates an unknown or default CPU architecture.
        */
        Unknown = 1,
        /**
        Indicates an Intel-based 32-bit CPU architecture.
        */
        X86 = 2,
        /**
        Indicates an Intel-based 64-bit CPU architecture.
        */
        X64 = 3,
        /**
        Indicates an ARMv7-based 32-bit CPU architecture.
        */
        Armv7 = 4,
        /**
        Indicates an ARMv8-based 32-bit CPU architecture.
        */
        Armv8 = 5,
        /**
        Indicates an ARM-based 64-bit CPU architecture.
        */
        Arm64 = 6,
        /**
        Indicates a MIPS-based 32-bit CPU architecture.
        */
        Mips = 7,
        /**
        Indicates a MIPS-based 64-bit CPU architecture.
        */
        Mips64 = 8
    }
}
declare namespace fm.liveswitch {
    /**
    A protocol type.
    */
    enum ProtocolType {
        /**
        Indicates the UDP protocol.
        */
        Udp = 1,
        /**
        Indicates the TCP protocol.
        */
        Tcp = 2,
        /**
        Indicates the TLS protocol.
        */
        Tls = 3,
        /**
        Indicates an unknown protocol.
        */
        Unknown = 4
    }
}
declare namespace fm.liveswitch {
    /**
    A source language.
    */
    enum SourceLanguage {
        /**
        Indicates that the source language is C#.
        */
        CSharp = 1,
        /**
        Indicates that the source language is Java.
        */
        Java = 2,
        /**
        Indicates that the source language is Objective-C.
        */
        ObjectiveC = 3,
        /**
        Indicates that the source language is TypeScript.
        */
        TypeScript = 4
    }
}
declare namespace fm.liveswitch {
    /** @hidden */
    enum StringType {
        None = 1,
        Single = 2,
        Double = 3
    }
}
declare namespace fm.liveswitch {
    /**
    The compare result in a sort operation.
    */
    enum CompareResult {
        /**
        Indicates that the two elements are equal.
        */
        Equal = 1,
        /**
        Indicates that the first element belongs before the second.
        */
        Negative = 2,
        /**
        Indicates that ths second element belongs before the first.
        */
        Positive = 3
    }
}
declare namespace fm.liveswitch {
    /**
    A hash algorithm.
    */
    enum HashType {
        /**
        Indciates MD5.
        */
        Md5 = 1,
        /**
        Indicates SHA1.
        */
        Sha1 = 2,
        /**
        Indicates SHA256.
        */
        Sha256 = 3
    }
}
declare namespace fm.liveswitch {
    /**
    A message authentication code (MAC) algorithm.
    */
    enum MacType {
        /**
        Indicates HMAC-MD5.
        */
        HmacMd5 = 1,
        /**
        Indicates HMAC-SHA1
        */
        HmacSha1 = 2,
        /**
        Indicates HMAC-SHA256
        */
        HmacSha256 = 3
    }
}
declare namespace fm.liveswitch {
    /**
    Error codes are six digit values, where the first three digits indicate component, while the remaining three digits particular problem with the component.
    */
    enum ErrorCode {
        /**
        Indicates that the socket encountered an error while sending.
        */
        SocketSendError = 100000,
        /**
        Indicates that the socket encountered an error while receiving.
        */
        SocketReceiveError = 100001,
        /**
        Indicates that the socket is closed.
        */
        SocketClosed = 100002,
        /**
        Indicates that the socket's send buffer is full.
        */
        SocketSendBufferFull = 100003,
        /**
        Indicates the IP Protocol mismatch has occurred.
        */
        IPProtocolMismatch = 100004,
        /**
        Indicates the supplied Turn relay server is invalid or not resolved.
        */
        PacketTooLarge = 100005,
        /**
        Indicates the network is unreachable.
        */
        NetworkUnreachable = 100006,
        /**
        300 Try Alternate. RFC5389. Indicates that a server using this extension redirects a client to another server by replying to a request message with an error response message with an error code of 300 (Try Alternate). The server MUST include an ALTERNATE-SERVER attribute in the error response.  The error response message MAY be authenticated; however, there are uses cases for ALTERNATE-SERVER where authentication of the response is not possible or practical.
        */
        StunTryAlternate = 114000,
        /**
        400 Bad Request. RFC5389. Idicates that the original request was malformed.  The client SHOULD NOT retry the request without modification from the previous attempt.  The server may not be able to generate a valid MESSAGE-INTEGRITY for this error, so the client MUST NOT expect a valid MESSAGE-INTEGRITY attribute on this response.
        */
        StunBadRequest = 114001,
        /**
        401  Unauthorized. RFC5389. Indicates that the request did not contain the correct credentials to proceed.  The client should retry the request with proper credentials.
        */
        StunUnauthorized = 114002,
        /**
        403 Forbidden. RFC 5766. Indicates that the request is valid, but the server is refusing to perform it, likely due to administrative restrictions. The client considers the current transaction as having failed. The client MAY notify the user or operator and SHOULD NOT retry the same request with this server until it believes the problem has been fixed.
        */
        StunTurnForbidden = 114003,
        /**
        405 Mobility Forbidden. RFC 8016. Indicates that the request is valid, but the server is refusing to perform it, likely due to administrative restrictions. The client considers the current transaction as having failed. The client can notify the user or operator.  The client SHOULD NOT retry sending the Allocate request containing the MOBILITY-TICKET with this server until it believes the problem has been fixed.
        */
        StunTurnMobilityForbidden = 114004,
        /**
        420  Unknown Attribute. RFC5389. Indicates that the server received a STUN packet containing a comprehension-required attribute that it did not understand. The server MUST put this unknown attribute in the UNKNOWN-ATTRIBUTE attribute of its error response.
        */
        StunUnknownAttribute = 114005,
        /**
        430 Stale credentials; the shared secret sent in the request is expired; the client should obtain a new shared secret.
        */
        StunStaleCredentials = 114006,
        /**
        431 Integrity Check Failure.
        */
        StunIntegrityCheckFailure = 114007,
        /**
        432 Missing Username; the username attribute is not present in the request.
        */
        StunMissingUsername = 114008,
        /**
        437 Allocation Mismatch. RFC 5766. This indicates that the client has picked a 5-tuple that the server sees as already in use. One way this could happen is if an intervening NAT assigned a mapped transport address that was used by another client that recently crashed.  The client considers the current transaction as having failed. The client SHOULD pick another client transport address and retry the Allocate request (using a different transaction id). The client SHOULD try three different client transport addresses before giving up on this server.Once the client gives up on the server, it SHOULD NOT try to create another allocation on the server for 2 minutes.
        */
        StunTurnAllocationMismatch = 114009,
        /**
        438 Stale Nonce. RFC5389. Indicates that the NONCE used by the client was no longer valid. The client should retry, using the NONCE provided in the response.
        */
        StunStaleNonce = 114010,
        /**
        440 Address Family Not Supported. RFC 6156. Indicates that the server does not support the address family requested by the client.
        */
        StunAddressFamilyNotSupported = 114011,
        /**
        441 Wrong Credentials. RFC 5766. Indicates that wrong credential were used by the client. The client should not receive this error in response to an Allocate request.  The client MAY notify the user or operator and SHOULD NOT retry the same request with this server until it believes the problem has been fixed.
        */
        StunTurnWrongCredentials = 114012,
        /**
        442 Unsupported Transport Protocol. The client should not receive this error in response to a request for a UDP allocation. The client MAY notify the user or operator and SHOULD NOT reattempt the request with this server until it believes the problem has been fixed.
        */
        StunTurnUnsupportedTransportProtocol = 114013,
        /**
        443 Peer Address Family Mismatch. A peer address was of a different address family than that of the relayed transport address of the allocation.
        */
        StunTurnPeerAddressFamilyMismatch = 114014,
        /**
        446 Connection Already exists. This indicates that either 1) the server is currently processing a Connect request for this allocation with the same XOR-PEER-ADDRESS; OR 2) the server has already successfully processed a Connect request for this allocation with the same XOR-PEER-ADDRESS, and the resulting client and peer data connections are either pending or active
        */
        StunTurnConnectionAlreadyExists = 114015,
        /**
        447 Connection Timeout or Failure. This indicates that the TURN server was unable to connect to the peer. The client MAY retry with the same XOR-PEER-ADDRESS attribute, but MUST wait at least 10 seconds.
        */
        StunTurnConnectionTimeoutOrFailure = 114016,
        /**
        486 Allocation Quota Reached. The server is currently unable to create any more allocations with this username.  The client considers the current transaction as having failed. The client SHOULD wait at least 1 minute before trying to create any more allocations on the server.
        */
        StunTurnAllocationQuotaReached = 114017,
        /**
        487 Role Conflict. The Binding request contained either the ICE-CONTROLLING or ICE-CONTROLLED attribute, indicating a role that conflicted with the server. The server ran a tie-breaker based on the tie-breaker value in the request and determined that the client needs to switch roles.
        */
        StunIceRoleConflict = 114018,
        /**
        500 Server Error. RFC5389. Indicates that the server has suffered a temporary error. The client should try again.
        */
        StunServerError = 114019,
        /**
        508 Insufficient Capacity. The server has no more relayed transport addresses available, or has none with the requested properties, or the one that was reserved is no longer available. The client considers the current operation as having failed. If the client is using either the EVEN-PORT or the RESERVATION-TOKEN attribute, then the client MAY choose to remove or modify this attribute and try again immediately.  Otherwise, the client SHOULD wait at least 1 minute before trying to create any more allocations on this server.
        */
        StunTurnInsufficientCapacity = 114020,
        /**
        Indicates Invalid Response Type, where message type obtained in reponse to a request is of unexpected type.
        */
        StunInvalidResponseType = 114021,
        /**
        Indicates that a failed response does not contain an error code or when the error code is inconsistent with the contents of the response.
        */
        StunInvalidErrorCode = 114022,
        /**
        Indicates Invalid Stun Transaction Id
        */
        StunInvalidTransactionId = 114023,
        /**
        Indicates Unknown Stun Error Code
        */
        StunUnknownStunErrorCode = 114024,
        /**
        Indicates Invalid Stun Message Integrity
        */
        StunInvalidMessageIntegrity = 114025,
        /**
        Indicates that the stream socket ip is invalid, remote server ip is invalid or there is a mimatch in the the ip of the socket and the remote server ip version
        */
        SocketIPError = 115001,
        /**
        Indicates the local relayed candidate could not be processed.
        */
        IceLocalRelayedDatagramCandidateError = 101000,
        /**
        Indicates the local server reflexive could not be processed.
        */
        IceLocalServerReflexiveCandidateError = 101001,
        /**
        Indicates that an operation was attempted in an invalid state.
        */
        SocketManagerInvalidState = 101002,
        /**
        Indicates that the ICE gatherer could not be started.
        */
        IceStartError = 102000,
        /**
        Indicates that RTCP datagram sockets were assigned incorrectly after the gatherer was started.
        */
        IceUnsuitableSocketAssignment = 102001,
        /**
        Indicates that all ports are in use.
        */
        IceAllPortsInUse = 102002,
        /**
        Indicates that no local addresses were found.
        */
        IceLocalAddressUnavailable = 102003,
        /**
        Indicates that an Ice Gatherer error occurred.
        */
        IceGenericGathererError = 102004,
        /**
        Indicates that the relayed candidate refresh request timed out.
        */
        IceRefreshTimeout = 103000,
        /**
        Indicates that the relayed candidate refresh request failed.
        */
        IceRefreshError = 103001,
        /**
        Indicates that the candidate pair create-permission request timed out.
        */
        IceCreatePermissionTimeout = 104000,
        /**
        Indicates that the candidate pair create-permission request failed.
        */
        IceCreatePermissionError = 104001,
        /**
        Indicates that connectivity checks failed on the candidate pair.
        */
        IceConnectivityCheckFailed = 104002,
        /**
        Indicates that the ICE transport encountered an error while sending.
        */
        IceSendError = 105000,
        /**
        Indicates that the ICE transport encountered a problem creating a peer reflexive candidate.
        */
        IcePeerReflexiveError = 105001,
        /**
        Indicates that the IcePolicy requirements are not supported by the remote client.
        */
        IncompatibleIceSetup = 105002,
        /**
        Indicates that an internal DTLS error occurred.
        */
        DtlsInternalError = 106000,
        /**
        Indicates that the DTLS key exchange failed.
        */
        DtlsKeyExchangeFailed = 106001,
        /**
        Indicates that a DTLS message was received before the DTLS endpoint was ready.
        */
        DtlsNotReady = 106002,
        /**
        Indicates that an SCTP message had no payload data.
        */
        SctpNoPayloadData = 107000,
        /**
        Indicates that an attempt was made to send data on an unsupported stream.
        */
        SctpUnsupportedStream = 107001,
        /**
        Indicates that an operation was attempted while in a state that doesn't allow it.
        */
        SctpInvalidState = 107002,
        /**
        Indicates that an internal SCTP error occurred.
        */
        SctpInternalError = 107003,
        /**
        Indicates the media transport failed.
        */
        MediaTransportFailed = 108000,
        /**
        Indicates that the reliable data channel encountered an error while opening.
        */
        ReliableDataChannelOpenError = 109000,
        /**
        Indicates that the reliable data channel encountered an error while sending.
        */
        ReliableDataChannelSendError = 109001,
        /**
        Indicates that the connection architecture is invalid.
        */
        ConnectionInvalidArchitecture = 110000,
        /**
        Indicates that an internal connection error occurred.
        */
        ConnectionInternalError = 110001,
        /**
        Indicates that the connection's inner transport could not be started.
        */
        ConnectionTransportStartError = 110002,
        /**
        Indicates that the connection's inner transport is closed.
        */
        ConnectionTransportClosed = 110003,
        /**
        Indicates that a connection has failed connectivity checks for an extended period.
        */
        ConnectionDeadStream = 110004,
        /**
        Indicates that a connection has not been established within allocated timeframe.
        */
        ConnectionNotEstablished = 110005,
        /**
        Indicates that the remote end of the connection signalled failure.
        */
        ConnectionRemoteFailure = 110006,
        /**
        Indicates that simulcast is not supported.
        */
        ConnectionSimulcastNotSupported = 110007,
        /**
        Indicates that the stream was disabled.
        */
        StreamDisabled = 111000,
        /**
        Indicates that the local and remote stream encryption modes are not compatible.
        */
        StreamEncryptionMismatch = 111001,
        /**
        Indicates that the local and remote stream directions are not compatible.
        */
        StreamDirectionMismatch = 111002,
        /**
        Indicates that an attempt was made to modify Data Stream direction; however, this is not allowed.
        */
        DataStreamDirectionCannotBeChanged = 111003,
        /**
        Indicates that a Media Stream direction change attempt was made; however, new direction setting is not supported by the existing stream capabilities (inputs or outpus are missing).
        */
        InvalidStreamDirectionChange = 111004,
        /**
        Indicates that an error was encountered while processing the local description.
        */
        LocalDescriptionError = 112000,
        /**
        Indicates that an error was encountered while processing the remote description.
        */
        RemoteDescriptionError = 112001,
        /**
        Indicates the local relayed candidate could not be processed.
        */
        IceLocalRelayedStreamCandidateError = 113000,
        /**
        Indicates the supplied Turn relay server is invalid or not resolved
        */
        IceInvalidServerAssignmentError = 113001
    }
}
declare namespace fm.liveswitch {
    /**
    The method used by an HTTP request.
    */
    enum HttpMethod {
        /**
        Indicates a GET request.
        */
        Get = 1,
        /**
        Indicates a HEAD request.
        */
        Head = 2,
        /**
        Indicates a POST request.
        */
        Post = 3,
        /**
        Indicates a PUT request.
        */
        Put = 4,
        /**
        Indicates a PATCH request.
        */
        Patch = 5,
        /**
        Indicates a DELETE request.
        */
        Delete = 6
    }
}
declare namespace fm.liveswitch {
    /**
    The level at which to log.
    */
    enum LogLevel {
        /**
        Logs extensive messages detailing the program's state for troubleshooting.
        */
        Verbose = 1,
        /**
        Logs messages relevant to development and troubleshooting.
        */
        Debug = 2,
        /**
        Logs messages relevant to expected use.
        */
        Info = 3,
        /**
        Logs messages relevant to potential pit-falls.
        */
        Warn = 4,
        /**
        Logs messages relevant to errors that allow program execution to continue.
        */
        Error = 5,
        /**
        Logs messages relevant to errors that require the program to terminate.
        */
        Fatal = 6,
        /**
        Logs nothing.
        */
        None = 7
    }
}
declare namespace fm.liveswitch {
    /**
    The state of a future.
    */
    enum FutureState {
        /**
        Indicates that the promise has not been resolved or rejected.
        */
        Pending = 1,
        /**
        Indicates that the promise has been resolved.
        */
        Resolved = 2,
        /**
        Indicates that the promise has been rejected.
        */
        Rejected = 3
    }
}
declare namespace fm.liveswitch {
    /**
    An enumeration of potential WebSocket status codes.
    */
    enum WebSocketStatusCode {
        /**
        Indicates normal closure, meaning that the purpose for which the connection was established has been fulfilled.
        */
        Normal = 1000,
        /**
        Indicates that an endpoint is "going away", such as a server going down or a browser having navigated away from a page.
        */
        GoingAway = 1001,
        /**
        Indicates that an endpoint is terminating the connection due to a protocol error.
        */
        ProtocolError = 1002,
        /**
        Indicates that an endpoint is terminating the connection because it has received a type of data that it cannot accept.
        */
        InvalidType = 1003,
        /**
        Indicates that no status code was present in the Close frame. Reserved for use outside Close frames.
        */
        NoStatus = 1005,
        /**
        Indicates that the connection was closed abnormally, without sending a Close frame. Reserved for use outside Close frames.
        */
        Abnormal = 1006,
        /**
        Indicates that an endpoint is terminating the connection because it has received data within a message that was not consistent with the type of message.
        */
        InvalidData = 1007,
        /**
        Indicates that an endpoint is terminating the connection because it has received a message that violates its policy.
        */
        PolicyViolation = 1008,
        /**
        Indicates that an endpoint is terminating the connection because it has received a message that is too big for it to process.
        */
        MessageTooLarge = 1009,
        /**
        Indicates that the client is terminating the connection because it has expected the server to negotiate one or more extensions, but the server didn't return them in the response message of the WebSocket handshake.
        */
        UnsupportedExtension = 1010,
        /**
        Indicates that the server is terminating the connection because it encountered an unexpected condition that prevented it from fulfilling the request.
        */
        UnexpectedCondition = 1011,
        /**
        Indicates that the connection was closed due to a failure to perform a TLS handshake. Reserved for use outside Close frames.
        */
        SecureHandshakeFailure = 1015
    }
}
declare namespace fm.liveswitch {
    /**
    The state of a candidate pair.
    */
    enum CandidatePairState {
        /**
        Indicates that the candidate pair has been formed, but connectivity checks have not yet started.
        */
        New = 1,
        /**
        Indicates that the connectivity check is ready for connectivity checks, but checks have not yet started.
        */
        Waiting = 2,
        /**
        Indicates that connectivity checks are in progress.
        */
        InProgress = 3,
        /**
        Indicates that a connectivity check was successful.
        */
        Succeeded = 4,
        /**
        Indicates that all connectivity checks have timed out or produced a failure response.
        */
        Failed = 5,
        /**
        Indicates that connectivity checks have been stopped intentionally due to transport closure.
        */
        Closed = 6,
        /**
        Indicates that connectivity checks have succeeded in the past, but are currently not responding.
        */
        ConnectivityLost = 7
    }
}
declare namespace fm.liveswitch {
    /**
    The type of a candidate.
    */
    enum CandidateType {
        /**
        Indicates a 'host' candidate, discovered by querying a local network interface adapter. The candidate should contain a private IP address of this client.
        */
        Host = 1,
        /**
        Indicates a 'srflx' candidate, discovered by using a STUN server to echo back the source IP address it sees in a UDP binding request. When the STUN server is properly configured, the candidate should contain a public IP address of this client.
        */
        ServerReflexive = 2,
        /**
        Indicates a 'relay' candidate, discovered by using a TURN server to set up a public port in response to a UDP or TCP allocate request. When the TURN server is properly configured, the candidate should contain a public IP address of the TURN server.
        */
        Relayed = 3,
        /**
        Indicates a 'prflx' candidate, discovered by sending STUN connectivity checks between peers residing behind more restrictive firewalls. The candidate should contain a public IP address of this client.
        */
        PeerReflexive = 4,
        /**
        Indicates an unknown candidate type.
        */
        Unknown = 5
    }
}
declare namespace fm.liveswitch {
    /**
    A value used to indicate whether this codec is used to encode or decode.
    */
    enum CodecType {
        /**
        The attached RTCCodecStats represents a media format that is being encoded, or that the implementation is prepared to encode.
        */
        Encode = 1,
        /**
        The attached RTCCodecStats represents a media format that the implementation is prepared to decode.
        */
        Decode = 2
    }
}
declare namespace fm.liveswitch {
    /**
    The state of a connection.
    */
    enum ConnectionState {
        /**
        Indicates that the connection is new and has not been started.
        */
        New = 1,
        /**
        Indicates that the connection is being initialized but no connecting attempts have been made.
        */
        Initializing = 2,
        /**
        Indicates that the connection is currently connecting.
        */
        Connecting = 3,
        /**
        Indicates that the connection is currently connected.
        */
        Connected = 4,
        /**
        Indicates that the connection has encountered an error and is cleaning up.
        */
        Failing = 5,
        /**
        Indicates that the connection has encountered an error and has cleaned up.
        */
        Failed = 6,
        /**
        Indicates that the connection has been instructed to close and is cleaning up.
        */
        Closing = 7,
        /**
        Indicates that the connection has been instructed to close and has cleaned up.
        */
        Closed = 8
    }
}
declare namespace fm.liveswitch {
    /**
    A data channel state.
    */
    enum DataChannelState {
        /**
        Indicates the data channel has been created and has not started negotiating yet.
        */
        New = 1,
        /**
        Indicates the data channel is in the process of negotiating a secure connection.
        */
        Connecting = 2,
        /**
        Indicates the data channel has completed negotiation of a secure connection.
        */
        Connected = 3,
        /**
        Indicates the data channel is in the process of closing due to an intentional request.
        */
        Closing = 4,
        /**
        Indicates the data channel has been closed due to an intentional request.
        */
        Closed = 5,
        /**
        Indicates the data channel has been closed as the result of an error.
        */
        Failed = 6
    }
}
declare namespace fm.liveswitch {
    /**
    A video degradation preference.
    */
    enum VideoDegradationPreference {
        /**
        Indicates a preference to automate the degradation preference based on the video type. A video type of [[fm.liveswitch.videoType.Screen]] will prefer to degrade [[fm.liveswitch.videoDegradationPreference.FrameRate]]. A video type of [[fm.liveswitch.videoType.Camera]] will prefer to degrade [[fm.liveswitch.videoDegradationPreference.Resolution]]. A video type of [[fm.liveswitch.videoType.Unknown]] will prefer a [[fm.liveswitch.videoDegradationPreference.Balanced]] approach.
        */
        Automatic = 1,
        /**
        Indicates a preference to degrade both frame-rate and resolution together in smaller increments.
        */
        Balanced = 2,
        /**
        Indicates a preference to degrade frame-rate instead of resolution.
        */
        FrameRate = 3,
        /**
        Indicates a preference to degrade resolution instead of frame-rate.
        */
        Resolution = 4
    }
}
declare namespace fm.liveswitch {
    /**
    The encryption mode for the stream.
    */
    enum EncryptionMode {
        /**
        No encryption and no integrity checking.
        */
        Null = 1,
        /**
        AES 128-bit encryption with strong HMAC-SHA1 integrity checking (80-bit).
        */
        Aes128Strong = 2,
        /**
        AES 128-bit encryption with weak HMAC-SHA1 integrity checking (32-bit).
        */
        Aes128Weak = 3,
        /**
        Null encryption with strong HMAC-SHA1 integrity checking (80-bit).
        */
        NullStrong = 4,
        /**
        Null encryption with weak HMAC-SHA1 integrity checking (32-bit).
        */
        NullWeak = 5
    }
}
declare namespace fm.liveswitch {
    /**
    Specifies how an element should be scaled within a layout.
    */
    enum LayoutScale {
        /**
        Indicates that the element should be uniformly scaled (maintaining aspect ratio) to the largest size such that both its width and its height can fit inside its bounding box.
        */
        Contain = 1,
        /**
        Indicates that the element should be uniformly scaled (maintaining aspect ratio) to be as large as possible so that the bounding box is completely covered. Some parts of the element may not be in view (cropped).
        */
        Cover = 2,
        /**
        Indicates that the element should be non-uniformly scaled (not maintaining aspect ratio) so that the bounding box is completely covered, but all parts of the element are in view (no cropping).
        */
        Stretch = 3
    }
}
declare namespace fm.liveswitch.sdp {
    /**
    Specified Multiplexing category of SDP Attribute. Rules governing SDP Attribute multiplexing are as per draft-ietf-mmusic-sdp-mux-attributes
    */
    enum AttributeCategory {
        /**
        The attributes in the NORMAL category can be independently specified when multiplexed and they retain their original semantics.
        */
        Normal = 1,
        /**
        The attributes in the CAUTION category are advised against multiplexing since their usage under multiplexing might lead to incorrect behaviour.
        */
        Caution = 2,
        /**
        The attributes and their associated values (if any) in the IDENTICAL category MUST be repeated across all the media descriptions under multiplexing.
        */
        Identical = 3,
        /**
        The attributes in the SUM category can be set as they are normally used but software using them in the multiplexing scenario MUST apply the sum of all the attributes being multiplexed instead of trying to use them independently.This is typically used for bandwidth or other rate limiting attributes to the underlying transport.
        */
        Sum = 4,
        /**
        The attributes in the TRANSPORT category can be set normally for multiple items in a multiplexed group but the software MUST pick the one that's associated with the "m=" line whose information is used for setting up the underlying transport.
        */
        Transport = 5,
        /**
        The attributes in the INHERIT category encapsulate other SDP attributes or parameters.  These attributes inherit their multiplexing characteristics from the attributes or parameters they encapsulate.  Such attributes are defined in [RFC3407], [RFC5939] and [RFC6871] as part of a generic framework for indicating and negotiating transport, media, and media format related capabilities in the SDP.  The inheritance manifests itself when the encapsulated attribute or parameter is being leveraged.  In the case of SDP Capability Negotiation [RFC5939] for example, this occurs when a capability (encapsulating attribute) is used as part of a configuration; the configuration inherits the multiplexing category of each of its constituent (encapsulated) attributes and parameters.  The inherited attributes MUST be coherent in order to form a valid configuration from a multiplexing point of view (see Section 14 for further details).
        */
        Inherit = 6,
        /**
        The attributes in the IDENTICAL-PER-PT category define the RTP payload configuration on per Payload Type basis and MUST have identical values across all the media descriptions for a given RTP Payload Type when repeated.  These Payload Types identify the same codec configuration as defined in the Section 10.1.2 of [I-D.ietf-mmusic-sdp-bundle-negotiation] under this context.
        */
        IdenticalPerPT = 7,
        /**
        For the attributes in the SPECIAL category, the text in the specification defining the attribute MUST be consulted for further handling when multiplexed.
        */
        Special = 8
    }
}
declare namespace fm.liveswitch.sdp {
    /**
    SDP Attribute types
    */
    enum AttributeType {
        /**
        Unknown SDP Attribute
        */
        UnknownAttribute = 999666,
        /**
        SDP Direction Attribute
        */
        DirectionAttribute = 1,
        /**
        SDP Category Attribute
        */
        CategoryAttribute = 2,
        /**
        SDP Character Set Attribute
        */
        CharacterSetAttribute = 3,
        /**
        SDP Conference Type Attribute
        */
        ConferenceTypeAttribute = 4,
        /**
        SDP Crypto Attribute
        */
        CryptoAttribute = 5,
        /**
        SDP Format Parameters Attribute
        */
        FormatParametersAttribute = 6,
        /**
        SDP Frame Rate Attribute
        */
        FrameRateAttribute = 7,
        /**
        SDP Keywords Attribute
        */
        KeywordsAttribute = 8,
        /**
        SDP Language Attribute
        */
        LanguageAttribute = 9,
        /**
        SDP Max Packet Time Attribute
        */
        MaxPacketTimeAttribute = 10,
        /**
        SDP Orientiation Attribute
        */
        OrientationAttribute = 11,
        /**
        SDP Packet Time Attribute
        */
        PacketTimeAttribute = 12,
        /**
        SDP Quality Attribute
        */
        QualityAttribute = 13,
        /**
        SDP Sdp Language Attribute
        */
        SdpLanguageAttribute = 14,
        /**
        SDP Setup Attribute
        */
        SetupAttribute = 15,
        /**
        SDP Tool  Attribute
        */
        ToolAttribute = 16,
        /**
        SDP Media Stream Id Semantic Attribute
        */
        MediaStreamIdSemanticAttribute = 17,
        /**
        SDP Stream Id Attribute
        */
        MediaStreamIdAttribute = 18,
        /**
        SDP Bundle-only Attribute
        */
        BundleOnlyAttribute = 40,
        /**
        SDP Ice Candidate Attribute
        */
        IceCandidateAttribute = 19,
        /**
        SDP Ice Fingerprint Attribute
        */
        IceFingerprintAttribute = 20,
        /**
        SDP Ice Lite Attribute
        */
        IceLiteAttribute = 21,
        /**
        SDP Ice Mismatch Attribute
        */
        IceMismatchAttribute = 22,
        /**
        SDP Ice Options Attribute
        */
        IceOptionsAttribute = 23,
        /**
        SDP Ice Password Attribute
        */
        IcePasswordAttribute = 24,
        /**
        SDP Ice Ufrag Attribute
        */
        IceUfragAttribute = 25,
        /**
        SDP Ice Remote Candidates Attribute
        */
        IceRemoteCandidatesAttribute = 26,
        /**
        SDP RTP Map Attribute
        */
        RtpMapAttribute = 27,
        /**
        SDP RTP SSRC Attribute
        */
        RtpSsrcAttribute = 28,
        /**
        SDP RTP Extension Map Attribute (https://tools.ietf.org/html/rfc5285#section-5)
        */
        RtpExtMapAttribute = 29,
        /**
        SDP RTCP Attribute
        */
        RtcpAttribute = 30,
        /**
        SDP RTCP Feedback Attribute
        */
        RtcpFeedbackAttribute = 31,
        /**
        SDP RTCP Mux Attribute
        */
        RtcpMuxAttribute = 32,
        /**
        SDP SCTP Port Attribute
        */
        SctpPortAttribute = 33,
        /**
        SDP SCTP Map Attribute
        */
        SctpMapAttribute = 34,
        /**
        SDP SCTP Max Message Size Attribute
        */
        SctpMaxMessageSizeAttribute = 35,
        /**
        SDP Group Attribute
        */
        GroupAttribute = 36,
        /**
        SDP RTP RID Attribute
        */
        RtpRidAttribute = 37,
        /**
        SDP Simulcast Attribute
        */
        SimulcastAttribute = 38,
        /**
        SDP RTP SSRC Group Attribute
        */
        RtpSsrcGroupAttribute = 39,
        /**
        SDP Muted Attribute
        */
        MutedAttribute = 41
    }
}
declare namespace fm.liveswitch.sdp {
    /**
    SDP Group Semantics
    */
    enum GroupSemanticsType {
        /**
        An application that receives a session description that contains "m" lines that are grouped together using LS semantics MUST synchronize the playout of the corresponding media streams.Note that LS semantics not only apply to a video stream that has to be synchronized with an audio stream.The playout of two streams of the same type can be synchronized as well.
        */
        LipSynchronization = 1,
        /**
        An "m" line in an SDP session description defines a media stream. However, SDP does not define what a media stream is.  This definition can be found in the RTSP specification.The RTSP RFC[5] defines a media stream as "a single media instance, e.g., an audio stream or a video stream as well as a single whiteboard or shared application group. When using RTP, a stream consists of all RTP and RTCP packets created by a source within an RTP session".
        */
        FlowIdentification = 2,
        /**
        The extension can be used with the Session Description Protocol(SDP) Offer/Answer mechanism[RFC3264] to negotiate which "m=" sections will become part of a BUNDLE group.
        */
        Bundling = 3,
        /**
        Unknown Group semantics type.
        */
        Unknown = 4
    }
}
declare namespace fm.liveswitch.sdp.ice {
    /**
    A list of known types for [[fm.liveswitch.sdp.ice.optionTag]].
    */
    enum OptionTagType {
        /**
        Indicates an unknown option tag.
        */
        Unknown = 1,
        /**
        Indicates the trickle-ice option tag.
        */
        Trickle = 2
    }
}
declare namespace fm.liveswitch.sdp {
    /**
    Media Stream Id Semantic Tokens
    */
    enum MediaStreamIdSemanticToken {
        /**
        WebRTC Media Stream Semantic
        */
        Wms = 1
    }
}
declare namespace fm.liveswitch {
    /**
    A session description type.
    */
    enum SessionDescriptionType {
        /**
        Indicates an offer.
        */
        Offer = 1,
        /**
        Indicates an answer.
        */
        Answer = 2
    }
}
declare namespace fm.liveswitch {
    /**
    A stream direction.
    */
    enum StreamDirection {
        /**
        Indicates a stream that can send and can receive.
        */
        SendReceive = 1,
        /**
        Indicates a stream that can send.
        */
        SendOnly = 2,
        /**
        Indicates a stream that can receive.
        */
        ReceiveOnly = 3,
        /**
        Indicates a stream that cannot send or receive.
        */
        Inactive = 4,
        /**
        Indicates that a stream direction has not been set.
        */
        Unset = 5
    }
}
declare namespace fm.liveswitch {
    /**
    The state of a stream.
    */
    enum StreamState {
        /**
        Indicates that the stream is new and has not been started.
        */
        New = 1,
        /**
        Indicates that the stream is being initialized but no connecting attempts have been made.
        */
        Initializing = 2,
        /**
        Indicates that the stream is currently connecting.
        */
        Connecting = 3,
        /**
        Indicates that the stream is currently connected.
        */
        Connected = 4,
        /**
        Indicates that the stream has encountered an error and is cleaning up.
        */
        Failing = 5,
        /**
        Indicates that the stream has encountered an error and has cleaned up.
        */
        Failed = 6,
        /**
        Indicates that the stream has been instructed to close and is cleaning up.
        */
        Closing = 7,
        /**
        Indicates that the stream has been instructed to close and has cleaned up.
        */
        Closed = 8
    }
}
declare namespace fm.liveswitch {
    /**
    A stream type.
    */
    enum StreamType {
        /**
        Indicates an audio stream.
        */
        Audio = 1,
        /**
        Indicates a video stream.
        */
        Video = 2,
        /**
        Indicates an application stream.
        */
        Application = 3,
        /**
        Indicates a message stream.
        */
        Message = 4,
        /**
        Indicates a text stream.
        */
        Text = 5
    }
}
declare namespace fm.liveswitch {
    /**
    The CCM TMMBN policy.
    */
    enum CcmTmmbnPolicy {
        /**
        The usage of CCM TMMBN is disabled.
        */
        Disabled = 1,
        /**
        The usage of CCM TMMBN is negotiated with the peer.
        */
        Negotiated = 2
    }
}
declare namespace fm.liveswitch {
    /**
    The CCM TMMBR policy.
    */
    enum CcmTmmbrPolicy {
        /**
        The usage of CCM TMMBR is disabled.
        */
        Disabled = 1,
        /**
        The usage of CCM TMMBR is negotiated with the peer.
        */
        Negotiated = 2
    }
}
declare namespace fm.liveswitch {
    /**
    A video type.
    */
    enum VideoType {
        /**
        Indicates an unknown type.
        */
        Unknown = 1,
        /**
        Indicates camera-based video.
        */
        Camera = 2,
        /**
        Indicates screen-based video.
        */
        Screen = 3
    }
}
declare namespace fm.liveswitch {
    /**
    The CCM LRR policy.
    */
    enum CcmLrrPolicy {
        /**
        The usage of CCM LRR is disabled.
        */
        Disabled = 1,
        /**
        The usage of CCM LRR is negotiated with the peer.
        */
        Negotiated = 2
    }
}
declare namespace fm.liveswitch {
    /**
    The CCM FIR policy.
    */
    enum CcmFirPolicy {
        /**
        The usage of CCM FIR is disabled.
        */
        Disabled = 1,
        /**
        The usage of CCM FIR is negotiated with the peer.
        */
        Negotiated = 2
    }
}
declare namespace fm.liveswitch {
    /**
    The NACK PLI policy.
    */
    enum NackPliPolicy {
        /**
        The usage of NACK PLI is disabled.
        */
        Disabled = 1,
        /**
        The usage of NACK PLI is negotiated with the peer.
        */
        Negotiated = 2
    }
}
declare namespace fm.liveswitch {
    /**
    The simulcast mode.
    */
    enum SimulcastMode {
        /**
        Simulcast will not be signalled.
        */
        Disabled = 1,
        /**
        Simulcast will be signalled using RTP stream identifiers and the "simulcast" media attribute.
        */
        RtpStreamId = 3
    }
}
declare namespace fm.liveswitch {
    /**
    The local bundle negotiation policy. Denotes the policy this peer uses when negotiating resulting connection bundling policy.
    */
    enum BundlePolicy {
        /**
        Indicates that the first media section of each type will contain transport parameters. The second and any subsequent media sections of each type will be marked as "bundle only".
        */
        Balanced = 1,
        /**
        Indicates that all media sections will contain transport parameters. No media sections will be marked as "bundle only".
        */
        MaxCompatibility = 2,
        /**
        Indicates that only the first media section will contain transport parameters. All other media sections will be marked as "bundle only".
        */
        MaxBundle = 3,
        /**
        Indicates that all media sections will contain transport parameters. No support for bundling.
        */
        Disabled = 4
    }
}
declare namespace fm.liveswitch {
    /**
    Indicates encryption policy for a connection.
    */
    enum EncryptionPolicy {
        /**
        Encryption is required. If encryption is not supported by peer, connection must fail.
        */
        Required = 1,
        /**
        Encryption is preferred but not required. If the other peer does not support encryption, connection will be established without encryption.
        */
        Negotiated = 2,
        /**
        Encryption will not be available for the given connection.
        */
        Disabled = 3
    }
}
declare namespace fm.liveswitch {
    /**
    The state of an ICE gatherer.
    */
    enum IceConnectionState {
        /**
        Indicates that the ICE agent(s) is(are) gathering addresses or is(are) waiting to be given remote candidates (or both)..
        */
        New = 1,
        /**
        Indicates that the ICE agent(s) has(ve) been given one or more remote candidates and is(are) checking pairs of local and remote candidates against one another to try to find a compatible match, but has(ve) not yet found a pair which will allow the peer connection to be made. It's possible that gathering of candidates is also still underway.
        */
        Checking = 2,
        /**
        Indicates that a usable pairing of local and remote candidates has been found for all components of the connection, and the connection has been established. It's possible that gathering is still underway, and it's also possible that the ICE agent is still checking candidates against one another looking for a better connection to use.
        */
        Connected = 3,
        /**
        Indicates that the ICE agent has finished gathering candidates, has checked all pairs against one another, and has found a connection for all components.
        */
        Completed = 4,
        /**
        Indicates that the ICE candidate has checked all candidates pairs against one another and has failed to find compatible matches for all components of the connection. It is, however, possible that the ICE agent did find compatible connections for some components.
        */
        Failed = 5,
        /**
        Indicates that checks to ensure that components are still connected failed for at least one component of the RTCPeerConnection. This is a less stringent test than "failed" and may trigger intermittently and resolve just as spontaneously on less reliable networks, or during temporary disconnections. When the problem resolves, the connection may return to the "Connected" state.
        */
        Disconnected = 6,
        /**
        The ICE agent(s) for this RTCPeerConnection has shut down and is no longer handling requests
        */
        Closed = 7
    }
}
declare namespace fm.liveswitch {
    /**
    The state of an ICE gatherer.
    */
    enum IceGatheringState {
        /**
        Indicates that the gatherer has been created and no gathering has occurred yet.
        */
        New = 1,
        /**
        Indicates that the gatherer is in the process of gathering candidates.
        */
        Gathering = 2,
        /**
        Indicates that the gatherer has completed gathering candidates.
        */
        Complete = 3,
        /**
        Indicates that the gatherer has started closing intentionally via a call to stop.
        */
        Closing = 4,
        /**
        Indicates that the gatherer has been closed intentionally via a call to stop.
        */
        Closed = 5,
        /**
        Indicates that the gatherer failed due to an error.
        */
        Failed = 6
    }
}
declare namespace fm.liveswitch {
    /**
    The local policy for gathering candidates.
    */
    enum IceGatherPolicy {
        /**
        All candidates (host, reflexive, and relay) will be gathered.
        */
        All = 1,
        /**
        Only reflexive and relay candidates will be gathered.
        */
        NoHost = 2,
        /**
        Only relay candidates will be gathered.
        */
        Relay = 3
    }
}
declare namespace fm.liveswitch {
    /**
    A layout alignment definition.
    */
    enum LayoutAlignment {
        /**
        Indicates a top-left alignment.
        */
        TopLeft = 1,
        /**
        Indicates a top-center alignment.
        */
        Top = 2,
        /**
        Indicates a top-right alignment.
        */
        TopRight = 3,
        /**
        Indicates a center-left alignment.
        */
        Left = 4,
        /**
        Indicates a center-center alignment.
        */
        Center = 5,
        /**
        Indicates a center-right alignment.
        */
        Right = 6,
        /**
        Indicates a bottom-left alignment.
        */
        BottomLeft = 7,
        /**
        Indicates a bottom-center alignment.
        */
        Bottom = 8,
        /**
        Indicates a bottom-right alignment.
        */
        BottomRight = 9
    }
}
declare namespace fm.liveswitch {
    /**
    Specifies the direction of the layout flow.
    */
    enum LayoutDirection {
        /**
        Indicates that the layout should flow horizontally, filling rows as needed.
        */
        Horizontal = 1,
        /**
        Indicates that the layout should flow vertically, filling columns as needed.
        */
        Vertical = 2
    }
}
declare namespace fm.liveswitch {
    /**
    Specifies the layout mode that should be used.
    */
    enum LayoutMode {
        /**
        Indicates that the local video feed should be displayed as a floating element above the remote video feeds.
        */
        FloatLocal = 1,
        /**
        Indicates that the remote video feeds should be displayed as floating elements above the local video feed.
        */
        FloatRemote = 2,
        /**
        Indicates that the video feed should be displayed as a block element on its own row/column, separate from other video feeds.
        */
        Block = 3,
        /**
        Indicates that the video feed should be displayed as an inline element that shares a row/column with other video feeds.
        */
        Inline = 4,
        /**
        Indicates that the video feed should be displayed as an inline element that shares a row/column with other video feeds, allowing container overflow as needed.
        */
        InlineOverflow = 5
    }
}
declare namespace fm.liveswitch {
    /**
    A layout origin definition.
    */
    enum LayoutOrigin {
        /**
        Indicates an origin where 0,0 is in the top-left corner.
        */
        TopLeft = 1,
        /**
        Indicates an origin where 0,0 is in the top-right corner.
        */
        TopRight = 2,
        /**
        Indicates an origin where 0,0 is in the bottom-right corner.
        */
        BottomRight = 3,
        /**
        Indicates an origin where 0,0 is in the bottom-left corner.
        */
        BottomLeft = 4
    }
}
declare namespace fm.liveswitch {
    /**
    The state of local media.
    */
    enum LocalMediaState {
        /**
        Indicates that the local media has not been started yet.
        */
        New = 1,
        /**
        Indicates that the local media is starting.
        */
        Starting = 2,
        /**
        Indicates that the local media has started.
        */
        Started = 3,
        /**
        Indicates that the local media is stopping.
        */
        Stopping = 4,
        /**
        Indicates that the local media has stopped.
        */
        Stopped = 5,
        /**
        Indicates that the local media is being destroyed.
        */
        Destroying = 6,
        /**
        Indicates that the local media has been destroyed.
        */
        Destroyed = 7
    }
}
declare namespace fm.liveswitch {
    /**
    The local policy for the use of generic RTP Negative Acknowledgements (NACK). Cf. https://tools.ietf.org/html/draft-ietf-rtcweb-rtp-usage-26  NackPolicy is for enabling/configuring negative acknowledgement. Negative acknowledgements are used by media receivers to request that a media sender retransmit a packet. It is highly effective for video in low-latency networks since video is stateful and the cost of losing a packet is high. It is far less effective for audio, where any delay is especially harmful and the cost of losing a packet is not significant. Because of this, it is enabled by default for video and disabled by default for audio. You can modify the buffer size using NackConfig, but generally, it should be left with default values. The option to set these values will most likely be removed in a future release as our adaptive algorithms improve.
    */
    enum NackPolicy {
        /**
        The usage of generic NACKs is disabled.
        */
        Disabled = 1,
        /**
        The usage of generic NACKs is negotiated with the peer.
        */
        Negotiated = 2
    }
}
declare namespace fm.liveswitch {
    /**
    The local policy for the RED Forward Error Correction support. Cf. https://tools.ietf.org/html/draft-ietf-rtcweb-fec-04  RedFecPolicy is for enabling/configuring forward error correction. Forward error correction adds redundancy to the media stream (increased bandwidth) with the intention that media receivers can recover from packet loss without requiring the media server to retransmit anything. It is a last resort for high latency networks. It is disabled by default and not currently supported as it does not have sufficient test coverage.
    */
    enum RedFecPolicy {
        /**
        The usage of RED FEC is disabled.
        */
        Disabled = 1,
        /**
        The usage of RED FEC is negotiated with the peer.
        */
        Negotiated = 2
    }
}
declare namespace fm.liveswitch {
    /**
    The local policy for the use of Receiver Estimated Maximum Bitrates (goog-remb). Cf. https://tools.ietf.org/html/draft-alvestrand-rmcat-remb-03
    */
    enum RembPolicy {
        /**
        The usage of goog-rembs is disabled.
        */
        Disabled = 1,
        /**
        The usage of goog-rembs is negotiated with the peer.
        */
        Negotiated = 2
    }
}
declare namespace fm.liveswitch.rtp {
    /** @hidden */
    enum HeaderExtensionForm {
        OneByte = 1,
        TwoByte = 2
    }
}
declare namespace fm.liveswitch {
    /**
    Indicates Sdes policy for stream.
    */
    enum SdesPolicy {
        /**
        Sdes is preferred but not required. If stream type is compatible (i.e. not a DataStream) Crypto attributes will be included in the session description.
        */
        Negotiated = 2,
        /**
        Sdes is disabled. Crypto attributes will not be included in the session description.
        */
        Disabled = 3
    }
}
declare namespace fm.liveswitch {
    /**
    The signalling state of a connection.
    */
    enum SignallingState {
        /**
        Indicates that no offer/answer exchange ever occurred.
        */
        New = 1,
        /**
        Indicates that the connection has a local offer and remote answer is outstanding.
        */
        HaveLocalOffer = 2,
        /**
        Indicates that the connection has a remote offer and local answer is outstanding.
        */
        HaveRemoteOffer = 3,
        /**
        Indicates that for each offer there is a matching answer.
        */
        Stable = 4
    }
}
declare namespace fm.liveswitch {
    /** @hidden */
    enum TransportType {
        Gatherer = 1,
        IceTransport = 2,
        DtlsTransport = 3,
        SctpTransport = 4,
        ReliableDataTransport = 5,
        SrtpTransport = 6,
        Unset = 7,
        MediaTransport = 8
    }
}
declare namespace fm.liveswitch {
    /**
    The local policy for TrickleIce support. Cf. https://tools.ietf.org/html/draft-ietf-ice-trickle-04
    */
    enum TrickleIcePolicy {
        /**
        A Trickle ICE mode of operation where the offerer gathers all of the possible candidates strictly before creating and sending the offer.
        */
        NotSupported = 1,
        /**
        The regular mode of operation for Trickle ICE agents, in which an initial offer can include any number of candidates (even zero candidates) and does not need to include the entire first generation of candidates as in half trickle.
        */
        FullTrickle = 2,
        /**
        A Trickle ICE mode of operation where the offerer gathers its first generation of candidates strictly before creating and sending the offer. Once sent, that offer can be processed by Vanilla ICE agents and does not require support for this specification. It also allows Trickle ICE capable answerers to still gather candidates and perform connectivity checks in a non-blocking way, thus roughly offering "half" the advantages of Trickle ICE. The mechanism is mostly meant for use in cases where support for Trickle ICE cannot be confirmed prior to sending an initial offer.
        */
        HalfTrickle = 3
    }
}
declare namespace fm.liveswitch {
    /**
    A peer role.
    */
    enum PeerRole {
        /**
        The offering role.
        */
        Offerer = 1,
        /**
        The answering role.
        */
        Answerer = 2
    }
}
declare namespace fm.liveswitch {
    /** @hidden */
    enum FailureSource {
        None = 1,
        Network = 2,
        Message = 3
    }
}
declare namespace fm.liveswitch {
    /**
    The state of a client.
    */
    enum ClientState {
        /**
        Indicates that the client is new and has not yet registered with the gateway.
        */
        New = 1,
        /**
        Indicates that the client is registering with the gateway.
        */
        Registering = 2,
        /**
        Indicates that the client is registered with the gateway.
        */
        Registered = 3,
        /**
        Indicates that the client is unregistering with the gateway.
        */
        Unregistering = 4,
        /**
        Indicates that the client is unregistered with the gateway.
        */
        Unregistered = 5
    }
}
declare namespace fm.liveswitch {
    /**
    The invite feedback states.
    */
    enum InvitationState {
        /**
        Gets the unknown state.
        */
        Unknown = 1,
        /**
        Gets the state for "pending". This state is for when no feedback has been received yet.
        */
        Pending = 2,
        /**
        Gets the state for "proceeding". This state is for when we are waiting for the invited party to respond.
        */
        Proceeding = 3,
        /**
        Gets the state for "sent". This state is for when the invite is sent in a way that does not allow feedback to be returned.
        */
        Sent = 4,
        /**
        Gets the state for "canceled". This state is for when the invite has been canceled.
        */
        Cancelled = 5,
        /**
        Gets the state for "cancelling". This state is for when the invite is in the process of being cancelled. May fail due to timing.
        */
        Cancelling = 6,
        /**
        Gets the state for "rejected". This state is for when the invitation was explicitly rejected.
        */
        Rejected = 7,
        /**
        Gets the state for "accepted". This state is for when the invitation was accepted.
        */
        Accepted = 8,
        /**
        Gets the state for "notFound". This state is for when the invited user id cannot be found.
        */
        NotFound = 9,
        /**
        Gets the state for "busy". This state is for when the invited user signals they are busy.
        */
        Busy = 10,
        /**
        Gets the state for "noResponse". This state is for when the invitation did not receive a response.
        */
        NoResponse = 11,
        /**
        Gets the state for "invalid". This state is when the invitation cannot be processed.
        */
        Invalid = 12,
        /**
        Gets the state for "alreadyInvited". This state is when another invite for the same user id, protocol, and channel already exists.
        */
        AlreadyInvited = 13
    }
}
declare namespace fm.liveswitch.signalling {
    /** @hidden */
    enum ClientState {
        New = 1,
        Connecting = 2,
        Connected = 3,
        Disconnecting = 4,
        Disconnected = 5
    }
}
declare namespace fm.liveswitch.signalling {
    /** @hidden */
    enum ConcurrencyMode {
        Low = 1,
        High = 2,
        Default = 1
    }
}
declare namespace fm.liveswitch.signalling {
    /** @hidden */
    enum ConnectionType {
        WebSocket = 1,
        LongPolling = 2,
        CallbackPolling = 3,
        IFrame = 4,
        Flash = 5,
        NotSet = 99
    }
}
declare namespace fm.liveswitch.signalling {
    /** @hidden */
    enum MessageType {
        Connect = 1,
        Disconnect = 2,
        Bind = 3,
        Unbind = 4,
        Subscribe = 5,
        Unsubscribe = 6,
        Publish = 7,
        Service = 9,
        Stream = 10,
        Unknown = 11
    }
}
declare namespace fm.liveswitch.signalling {
    /** @hidden */
    enum Reconnect {
        Retry = 1,
        Handshake = 2,
        None = 3,
        NotSet = 99
    }
}
declare namespace fm.liveswitch {
    class CryptoLibraryWrapper {
        getTypeString(): string;
        /** @hidden */
        private _value;
        constructor(value: fm.liveswitch.CryptoLibrary);
        toString(): string;
    }
}
declare namespace fm.liveswitch {
    /**
    A data buffer pool interface.
    */
    interface IDataBufferPool {
        take(size: number): fm.liveswitch.DataBuffer;
        take(size: number, littleEndian: boolean): fm.liveswitch.DataBuffer;
        take(size: number, littleEndian: boolean, clearBytes: boolean): fm.liveswitch.DataBuffer;
    }
}
declare namespace fm.liveswitch {
    /**
    A data buffer pool tracer.
    */
    class DataBufferPoolTracer implements fm.liveswitch.IDataBufferPool {
        getTypeString(): string;
        /** @hidden */
        private _pool;
        /** @hidden */
        private _tag;
        /**
        Initializes a new instance of the [[fm.liveswitch.dataBufferPoolTracer]] class.
        */
        constructor(tag: string, pool: fm.liveswitch.DataBufferPool);
        /**
        Gets the underlying pool.
        */
        getPool(): fm.liveswitch.DataBufferPool;
        /**
        Gets the traced usage statistics.
        */
        getStatistics(): fm.liveswitch.PoolStatistics;
        /**
        Gets the tag that identifies requests to the underlying pool.
        */
        getTag(): string;
        /** @hidden */
        private setPool;
        /** @hidden */
        private setTag;
        /**
        Takes a buffer from the pool.
        @param size The number of bytes needed.
        */
        take(size: number): fm.liveswitch.DataBuffer;
        /**
        Takes a buffer from the pool.
        @param size The number of bytes needed.
        @param littleEndian Whether the data buffer should be little-endian.
        */
        take(size: number, littleEndian: boolean): fm.liveswitch.DataBuffer;
        /**
        Takes a buffer from the pool.
        @param size The number of bytes needed.
        @param littleEndian Whether the data buffer should be little-endian.
        @param clearBytes Whether to clear the data buffer.
        */
        take(size: number, littleEndian: boolean, clearBytes: boolean): fm.liveswitch.DataBuffer;
    }
}
declare namespace fm.liveswitch {
    /**
    A system clock interface.
    */
    interface ISystemClock {
        getTimestamp(): number;
    }
}
declare namespace fm.liveswitch {
    /** @hidden */
    class PendingPromise {
        getTypeString(): string;
        /** @hidden */
        private __promise;
        /** @hidden */
        private __result;
        constructor(promise: fm.liveswitch.IPromise, result: Object);
        reject(ex: fm.liveswitch.Exception): void;
        resolve(): void;
    }
}
declare namespace fm.liveswitch {
    /**
    A system clock.
    */
    class SystemClock implements fm.liveswitch.ISystemClock {
        getTypeString(): string;
        constructor();
        /**
        Gets the current system timestamp in ticks. 10,000 ticks is equal to 1 millisecond.
        @return The current system timestamp in ticks.
        */
        getTimestamp(): number;
    }
}
declare namespace fm.liveswitch {
    class AddressTypeWrapper {
        getTypeString(): string;
        /** @hidden */
        private _value;
        constructor(value: fm.liveswitch.AddressType);
        toString(): string;
    }
}
declare namespace fm.liveswitch {
    /**
    ASCII encoding/decoding utility.
    */
    class Ascii {
        getTypeString(): string;
        constructor();
        /**
        Decodes a UTF-8 byte array to a string.
        @param input The input byte array.
        */
        static decode(input: Uint8Array): string;
        /**
        Decodes a UTF-8 byte array to a string.
        @param input The input byte array.
        @param index The index to start reading.
        @param length The length.
        */
        static decode(input: Uint8Array, index: number, length: number): string;
        /**
        Encodes a string to a UTF-8 byte array.
        @param input The input string.
        */
        static encode(input: string): Uint8Array;
        /**
        Gets the number of bytes that would be returned by a call to encode.
        @param input The input string.
        */
        static getByteCount(input: string): number;
    }
}
declare namespace fm.liveswitch {
    /**
    ILog interface for loggers.
    */
    interface ILog {
        debug(message: string): void;
        debug(message: string, ex: fm.liveswitch.Exception): void;
        debug(scope: string, message: string): void;
        debug(scope: string, message: string, ex: fm.liveswitch.Exception): void;
        error(message: string): void;
        error(message: string, ex: fm.liveswitch.Exception): void;
        error(scope: string, message: string): void;
        error(scope: string, message: string, ex: fm.liveswitch.Exception): void;
        fatal(message: string): void;
        fatal(message: string, ex: fm.liveswitch.Exception): void;
        fatal(scope: string, message: string): void;
        fatal(scope: string, message: string, ex: fm.liveswitch.Exception): void;
        flush(): void;
        getIsDebugEnabled(): boolean;
        getIsErrorEnabled(): boolean;
        getIsFatalEnabled(): boolean;
        getIsInfoEnabled(): boolean;
        getIsVerboseEnabled(): boolean;
        getIsWarnEnabled(): boolean;
        getTag(): string;
        info(message: string): void;
        info(message: string, ex: fm.liveswitch.Exception): void;
        info(scope: string, message: string): void;
        info(scope: string, message: string, ex: fm.liveswitch.Exception): void;
        isLogEnabled(level: fm.liveswitch.LogLevel): boolean;
        log(logEvent: fm.liveswitch.LogEvent): void;
        log(message: string): void;
        log(scope: string, message: string): void;
        verbose(message: string): void;
        verbose(message: string, ex: fm.liveswitch.Exception): void;
        verbose(scope: string, message: string): void;
        verbose(scope: string, message: string, ex: fm.liveswitch.Exception): void;
        warn(message: string): void;
        warn(message: string, ex: fm.liveswitch.Exception): void;
        warn(scope: string, message: string): void;
        warn(scope: string, message: string, ex: fm.liveswitch.Exception): void;
    }
}
declare namespace fm.liveswitch {
    /**
    A managed mutex.
    */
    class AtomicMutex {
        getTypeString(): string;
        /** @hidden */
        private __lock;
        /**
        Creates a new instance of an AtomicMutex.
        */
        constructor();
        /**
        Gets if the mutex is locked or not.
        */
        getIsLocked(): boolean;
        /**
        Releases the lock.
        */
        release(): void;
        /**
        Tries to obtain a lock with this thread.
        */
        tryLock(): boolean;
    }
}
declare namespace fm.liveswitch {
    /**
    Common binary methods.
    */
    class Binary {
        getTypeString(): string;
        /** @hidden */
        private static fm_liveswitch_Binary___bitmasks;
        constructor();
        /**
        Converts a bit-string to bytes.
        @param bitString The bit-string.
        */
        static bitStringToBytes(bitString: string): Uint8Array;
        /**
        Converts a bit-string to bytes.
        @param bitString The bit-string.
        @param numberOfUnusedBits The number of unused bits.
        */
        static bitStringToBytes(bitString: string, numberOfUnusedBits: fm.liveswitch.Holder<number>): Uint8Array;
        /**
        Converts a bit-string to bytes.
        @param bitString The bit-string.
        @param padLeft Whether to pad extra zero-bits to the left.
        */
        static bitStringToBytes(bitString: string, padLeft: boolean): Uint8Array;
        /**
        Converts a bit-string to bytes.
        @param bitString The bit-string.
        @param padLeft Whether to pad extra zero-bits to the left.
        @param numberOfUnusedBits The number of unused bits.
        */
        static bitStringToBytes(bitString: string, padLeft: boolean, numberOfUnusedBits: fm.liveswitch.Holder<number>): Uint8Array;
        /**
        Converts bytes to a bit-string.
        @param bytes The bytes.
        */
        static bytesToBitString(bytes: Uint8Array): string;
        /**
        Converts bytes to a bit-string.
        @param bytes The bytes.
        @param offset The offset.
        @param length The length.
        */
        static bytesToBitString(bytes: Uint8Array, offset: number, length: number): string;
        /**
        Converts bytes to a bit-string.
        @param bytes The bytes.
        @param offset The offset.
        @param length The length.
        @param numberOfUnusedBits The number of unused bits.
        */
        static bytesToBitString(bytes: Uint8Array, offset: number, length: number, numberOfUnusedBits: number): string;
        /**
        Converts bytes to a bit-string.
        @param bytes The bytes.
        @param offset The offset.
        @param length The length.
        @param numberOfUnusedBits The number of unused bits.
        @param trimLeft Whether to trim unused bits from the left.
        */
        static bytesToBitString(bytes: Uint8Array, offset: number, length: number, numberOfUnusedBits: number, trimLeft: boolean): string;
        /**
        Deinterleaves a byte array i.e. XYXYXYXY to XXXXYYYY
        @param inputFrame The inputFrame.
        @param outputFrame The outputFrame.
        */
        static deinterleave(inputFrame: Uint8Array, outputFrame: Uint8Array): void;
        /**
        Deinterleaves a byte array i.e. XYXYXYXY to XXXXYYYY
        @param inputFrame The inputFrame.
        @param outputFrame The outputFrame.
        @param start The start.
        @param length The length.
        */
        static deinterleave(inputFrame: Uint8Array, outputFrame: Uint8Array, start: number, length: number): void;
        /**
        Deinterleaves a byte array
        @param inputFrame The inputFrame.
        @param outputFrame The outputFrame.
        @param start The start.
        @param length The length.
        @param reversePlanes The reversePlanes.
        */
        static deinterleave(inputFrame: Uint8Array, outputFrame: Uint8Array, start: number, length: number, reversePlanes: boolean): void;
        /**
        Deinterleave and transform (rotate) a byte array containing two planes
        @param inputFrame The inputFrame.
        @param outputFrame The outputFrame.
        @param width The width.
        @param height The height.
        @param stride The stride.
        @param rotation Values 0, 90, 180, 270.
        */
        static deinterleaveTransform(inputFrame: Uint8Array, outputFrame: Uint8Array, width: number, height: number, stride: number, rotation: number): void;
        /**
        Deinterleave and transform (rotate) a byte array containing two planes
        @param inputFrame The inputFrame.
        @param outputFrame The outputFrame.
        @param width The width.
        @param height The height.
        @param stride The stride.
        @param rotation Values 0, 90, 180, 270.
        @param start The start.
        */
        static deinterleaveTransform(inputFrame: Uint8Array, outputFrame: Uint8Array, width: number, height: number, stride: number, rotation: number, start: number): void;
        /**
        Deinterleave and transform (rotate) a byte array containing two planes
        @param inputFrame The inputFrame.
        @param outputFrame The outputFrame.
        @param width The width.
        @param height The height.
        @param stride The stride.
        @param start The start.
        @param rotation Values 0, 90, 180, 270.
        @param reversePlanes Reverse output plane order.
        */
        static deinterleaveTransform(inputFrame: Uint8Array, outputFrame: Uint8Array, width: number, height: number, stride: number, rotation: number, start: number, reversePlanes: boolean): void;
        /**
        Reads a 1-bit value from a byte array.
        @param input The input byte array.
        @param inputIndex The index to start reading.
        @param bitOffset The offset of the value within the byte.
        @return The value.
        */
        static fromBytes1(input: Uint8Array, inputIndex: number, bitOffset: number): boolean;
        /**
        Reads a 10-bit value from a byte array.
        @param input The input byte array.
        @param inputIndex The index to start reading.
        @param bitOffset The offset of the value within the byte.
        @return The value.
        */
        static fromBytes10(input: Uint8Array, inputIndex: number, bitOffset: number): number;
        /**
        Reads a 11-bit value from a byte array.
        @param input The input byte array.
        @param inputIndex The index to start reading.
        @param bitOffset The offset of the value within the byte.
        @return The value.
        */
        static fromBytes11(input: Uint8Array, inputIndex: number, bitOffset: number): number;
        /**
        Reads a 12-bit value from a byte array.
        @param input The input byte array.
        @param inputIndex The index to start reading.
        @param bitOffset The offset of the value within the byte.
        @return The value.
        */
        static fromBytes12(input: Uint8Array, inputIndex: number, bitOffset: number): number;
        /**
        Reads a 13-bit value from a byte array.
        @param input The input byte array.
        @param inputIndex The index to start reading.
        @param bitOffset The offset of the value within the byte.
        @return The value.
        */
        static fromBytes13(input: Uint8Array, inputIndex: number, bitOffset: number): number;
        /**
        Reads a 14-bit value from a byte array.
        @param input The input byte array.
        @param inputIndex The index to start reading.
        @param bitOffset The offset of the value within the byte.
        @return The value.
        */
        static fromBytes14(input: Uint8Array, inputIndex: number, bitOffset: number): number;
        /**
        Reads a 15-bit value from a byte array.
        @param input The input byte array.
        @param inputIndex The index to start reading.
        @param bitOffset The offset of the value within the byte.
        @return The value.
        */
        static fromBytes15(input: Uint8Array, inputIndex: number, bitOffset: number): number;
        /**
        Reads a 16-bit value from a byte array.
        @param input The input byte array.
        @param inputIndex The index to start reading.
        @param littleEndian Whether to use little-endian format.
        @return The value.
        */
        static fromBytes16(input: Uint8Array, inputIndex: number, littleEndian: boolean): number;
        /**
        Reads an 17-bit value from a byte array.
        @param input The input byte array.
        @param inputIndex The index to start reading.
        @param bitOffset The offset of the value within the byte.
        @return The value.
        */
        static fromBytes17(input: Uint8Array, inputIndex: number, bitOffset: number): number;
        /**
        Reads an 18-bit value from a byte array.
        @param input The input byte array.
        @param inputIndex The index to start reading.
        @param bitOffset The offset of the value within the byte.
        @return The value.
        */
        static fromBytes18(input: Uint8Array, inputIndex: number, bitOffset: number): number;
        /**
        Reads an 19-bit value from a byte array.
        @param input The input byte array.
        @param inputIndex The index to start reading.
        @param bitOffset The offset of the value within the byte.
        @return The value.
        */
        static fromBytes19(input: Uint8Array, inputIndex: number, bitOffset: number): number;
        /**
        Reads a 2-bit value from a byte array.
        @param input The input byte array.
        @param inputIndex The index to start reading.
        @param bitOffset The offset of the value within the byte.
        @return The value.
        */
        static fromBytes2(input: Uint8Array, inputIndex: number, bitOffset: number): number;
        /**
        Reads an 20-bit value from a byte array.
        @param input The input byte array.
        @param inputIndex The index to start reading.
        @param bitOffset The offset of the value within the byte.
        @return The value.
        */
        static fromBytes20(input: Uint8Array, inputIndex: number, bitOffset: number): number;
        /**
        Reads an 21-bit value from a byte array.
        @param input The input byte array.
        @param inputIndex The index to start reading.
        @param bitOffset The offset of the value within the byte.
        @return The value.
        */
        static fromBytes21(input: Uint8Array, inputIndex: number, bitOffset: number): number;
        /**
        Reads an 22-bit value from a byte array.
        @param input The input byte array.
        @param inputIndex The index to start reading.
        @param bitOffset The offset of the value within the byte.
        @return The value.
        */
        static fromBytes22(input: Uint8Array, inputIndex: number, bitOffset: number): number;
        /**
        Reads an 23-bit value from a byte array.
        @param input The input byte array.
        @param inputIndex The index to start reading.
        @param bitOffset The offset of the value within the byte.
        @return The value.
        */
        static fromBytes23(input: Uint8Array, inputIndex: number, bitOffset: number): number;
        /**
        Reads a 24-bit value from a byte array.
        @param input The input byte array.
        @param inputIndex The index to start reading.
        @param littleEndian Whether to use little-endian format.
        @return The value.
        */
        static fromBytes24(input: Uint8Array, inputIndex: number, littleEndian: boolean): number;
        /**
        Reads a 3-bit value from a byte array.
        @param input The input byte array.
        @param inputIndex The index to start reading.
        @param bitOffset The offset of the value within the byte.
        @return The value.
        */
        static fromBytes3(input: Uint8Array, inputIndex: number, bitOffset: number): number;
        /**
        Reads a 32-bit value from a byte array.
        @param input The input byte array.
        @param inputIndex The index to start reading.
        @param littleEndian Whether to use little-endian format.
        @return The value.
        */
        static fromBytes32(input: Uint8Array, inputIndex: number, littleEndian: boolean): number;
        /**
        Reads a 4-bit value from a byte array.
        @param input The input byte array.
        @param inputIndex The index to start reading.
        @param bitOffset The offset of the value within the byte.
        @return The value.
        */
        static fromBytes4(input: Uint8Array, inputIndex: number, bitOffset: number): number;
        /**
        Reads a 40-bit value from a byte array.
        @param input The input byte array.
        @param inputIndex The index to start reading.
        @param littleEndian Whether to use little-endian format.
        @return The value.
        */
        static fromBytes40(input: Uint8Array, inputIndex: number, littleEndian: boolean): number;
        /**
        Reads a 48-bit value from a byte array.
        @param input The input byte array.
        @param inputIndex The index to start reading.
        @param littleEndian Whether to use little-endian format.
        @return The value.
        */
        static fromBytes48(input: Uint8Array, inputIndex: number, littleEndian: boolean): number;
        /**
        Reads a 5-bit value from a byte array.
        @param input The input byte array.
        @param inputIndex The index to start reading.
        @param bitOffset The offset of the value within the byte.
        @return The value.
        */
        static fromBytes5(input: Uint8Array, inputIndex: number, bitOffset: number): number;
        /**
        Reads a 56-bit value from a byte array.
        @param input The input byte array.
        @param inputIndex The index to start reading.
        @param littleEndian Whether to use little-endian format.
        @return The value.
        */
        static fromBytes56(input: Uint8Array, inputIndex: number, littleEndian: boolean): number;
        /**
        Reads a 6-bit value from a byte array.
        @param input The input byte array.
        @param inputIndex The index to start reading.
        @param bitOffset The offset of the value within the byte.
        @return The value.
        */
        static fromBytes6(input: Uint8Array, inputIndex: number, bitOffset: number): number;
        /**
        Reads a 64-bit value from a byte array.
        @param input The input byte array.
        @param inputIndex The index to start reading.
        @param littleEndian Whether to use little-endian format.
        @return The value.
        */
        static fromBytes64(input: Uint8Array, inputIndex: number, littleEndian: boolean): number;
        /**
        Reads a 7-bit value from a byte array.
        @param input The input byte array.
        @param inputIndex The index to start reading.
        @param bitOffset The offset of the value within the byte.
        @return The value.
        */
        static fromBytes7(input: Uint8Array, inputIndex: number, bitOffset: number): number;
        /**
        Reads an 8-bit value from a byte array.
        @param input The input byte array.
        @param inputIndex The index to start reading.
        @return The value.
        */
        static fromBytes8(input: Uint8Array, inputIndex: number): number;
        /**
        Reads a 9-bit value from a byte array.
        @param input The input byte array.
        @param inputIndex The index to start reading.
        @param bitOffset The offset of the value within the byte.
        @return The value.
        */
        static fromBytes9(input: Uint8Array, inputIndex: number, bitOffset: number): number;
        /**
        Interleaves a byte array i.e. XXXXYYYY to XYXYXYXY
        @param inputFrame The inputFrame.
        @param outputFrame The outputFrame.
        */
        static interleave(inputFrame: Uint8Array, outputFrame: Uint8Array): void;
        /**
        Interleaves a byte array i.e. XXXXYYYY to XYXYXYXY
        @param inputFrame The inputFrame.
        @param outputFrame The outputFrame.
        @param start The start.
        @param length The length.
        */
        static interleave(inputFrame: Uint8Array, outputFrame: Uint8Array, start: number, length: number): void;
        /**
        Interleaves a byte array  i.e. XXXXYYYY to XYXYXYXY
        @param inputFrame The inputFrame.
        @param outputFrame The outputFrame.
        @param start The start.
        @param length The length.
        @param reversePlanes XXXXYYYY to YXYXYXYX
        */
        static interleave(inputFrame: Uint8Array, outputFrame: Uint8Array, start: number, length: number, reversePlanes: boolean): void;
        /**
        Interleave and transform (rotate) a byte array containing two planes
        @param inputFrame The inputFrame.
        @param outputFrame The outputFrame.
        @param width The width.
        @param height The height.
        @param stride The stride.
        @param rotation Values 0, 90, 180, 270.
        */
        static interleaveTransform(inputFrame: Uint8Array, outputFrame: Uint8Array, width: number, height: number, stride: number, rotation: number): void;
        /**
        Interleave and transform (rotate) a byte array containing two planes
        @param inputFrame The inputFrame.
        @param outputFrame The outputFrame.
        @param width The width.
        @param height The height.
        @param stride The stride.
        @param rotation Values 0, 90, 180, 270.
        @param start The start.
        */
        static interleaveTransform(inputFrame: Uint8Array, outputFrame: Uint8Array, width: number, height: number, stride: number, rotation: number, start: number): void;
        /**
        Interleave and transform (rotate) a byte array containing two planes
        @param inputFrame The inputFrame.
        @param outputFrame The outputFrame.
        @param width The width.
        @param height The height.
        @param stride The stride.
        @param start The start.
        @param rotation Values 0, 90, 180, 270.
        @param reversePlanes Reverse output plane order.
        */
        static interleaveTransform(inputFrame: Uint8Array, outputFrame: Uint8Array, width: number, height: number, stride: number, rotation: number, start: number, reversePlanes: boolean): void;
        /** @hidden */
        private static roundUp;
        /** @hidden */
        private static toBytes;
        /**
        Converts a 1-bit value to a byte array.
        @param value The value to write.
        @param bitOffset The offset of the value within the byte.
        @return The output byte array.
        */
        static toBytes1(value: boolean, bitOffset: number): Uint8Array;
        /**
        Writes a 1-bit value to a byte array.
        @param value The value to write.
        @param bitOffset The offset of the value within the byte.
        @param output The output byte array.
        @param outputIndex The index to start writing.
        @return The output byte array.
        */
        static toBytes1(value: boolean, bitOffset: number, output: Uint8Array, outputIndex: number): Uint8Array;
        /**
        Converts a 10-bit value to a byte array.
        @param value The value to write.
        @param bitOffset The offset of the value within the byte.
        @param littleEndian Whether to use little-endian format.
        @return The output byte array.
        */
        static toBytes10(value: number, bitOffset: number, littleEndian: boolean): Uint8Array;
        /**
        Writes a 10-bit value to a byte array.
        @param value The value to write.
        @param bitOffset The offset of the value within the byte.
        @param littleEndian Whether to use little-endian format.
        @param output The output byte array.
        @param outputIndex The index to start writing.
        @return The output byte array.
        */
        static toBytes10(value: number, bitOffset: number, littleEndian: boolean, output: Uint8Array, outputIndex: number): Uint8Array;
        /**
        Converts a 11-bit value to a byte array.
        @param value The value to write.
        @param bitOffset The offset of the value within the byte.
        @param littleEndian Whether to use little-endian format.
        @return The output byte array.
        */
        static toBytes11(value: number, bitOffset: number, littleEndian: boolean): Uint8Array;
        /**
        Writes a 11-bit value to a byte array.
        @param value The value to write.
        @param bitOffset The offset of the value within the byte.
        @param littleEndian Whether to use little-endian format.
        @param output The output byte array.
        @param outputIndex The index to start writing.
        @return The output byte array.
        */
        static toBytes11(value: number, bitOffset: number, littleEndian: boolean, output: Uint8Array, outputIndex: number): Uint8Array;
        /**
        Converts a 12-bit value to a byte array.
        @param value The value to write.
        @param bitOffset The offset of the value within the byte.
        @param littleEndian Whether to use little-endian format.
        @return The output byte array.
        */
        static toBytes12(value: number, bitOffset: number, littleEndian: boolean): Uint8Array;
        /**
        Writes a 12-bit value to a byte array.
        @param value The value to write.
        @param bitOffset The offset of the value within the byte.
        @param littleEndian Whether to use little-endian format.
        @param output The output byte array.
        @param outputIndex The index to start writing.
        @return The output byte array.
        */
        static toBytes12(value: number, bitOffset: number, littleEndian: boolean, output: Uint8Array, outputIndex: number): Uint8Array;
        /**
        Converts a 13-bit value to a byte array.
        @param value The value to write.
        @param bitOffset The offset of the value within the byte.
        @param littleEndian Whether to use little-endian format.
        @return The output byte array.
        */
        static toBytes13(value: number, bitOffset: number, littleEndian: boolean): Uint8Array;
        /**
        Writes a 13-bit value to a byte array.
        @param value The value to write.
        @param bitOffset The offset of the value within the byte.
        @param littleEndian Whether to use little-endian format.
        @param output The output byte array.
        @param outputIndex The index to start writing.
        @return The output byte array.
        */
        static toBytes13(value: number, bitOffset: number, littleEndian: boolean, output: Uint8Array, outputIndex: number): Uint8Array;
        /**
        Converts a 14-bit value to a byte array.
        @param value The value to write.
        @param bitOffset The offset of the value within the byte.
        @param littleEndian Whether to use little-endian format.
        @return The output byte array.
        */
        static toBytes14(value: number, bitOffset: number, littleEndian: boolean): Uint8Array;
        /**
        Writes a 14-bit value to a byte array.
        @param value The value to write.
        @param bitOffset The offset of the value within the byte.
        @param littleEndian Whether to use little-endian format.
        @param output The output byte array.
        @param outputIndex The index to start writing.
        @return The output byte array.
        */
        static toBytes14(value: number, bitOffset: number, littleEndian: boolean, output: Uint8Array, outputIndex: number): Uint8Array;
        /**
        Converts a 15-bit value to a byte array.
        @param value The value to write.
        @param bitOffset The offset of the value within the byte.
        @param littleEndian Whether to use little-endian format.
        @return The output byte array.
        */
        static toBytes15(value: number, bitOffset: number, littleEndian: boolean): Uint8Array;
        /**
        Writes a 15-bit value to a byte array.
        @param value The value to write.
        @param bitOffset The offset of the value within the byte.
        @param littleEndian Whether to use little-endian format.
        @param output The output byte array.
        @param outputIndex The index to start writing.
        @return The output byte array.
        */
        static toBytes15(value: number, bitOffset: number, littleEndian: boolean, output: Uint8Array, outputIndex: number): Uint8Array;
        /**
        Converts a 16-bit value to a byte array.
        @param value The value to write.
        @param littleEndian Whether to use little-endian format.
        @return The output byte array.
        */
        static toBytes16(value: number, littleEndian: boolean): Uint8Array;
        /**
        Writes a 16-bit value to a byte array.
        @param value The value to write.
        @param littleEndian Whether to use little-endian format.
        @param output The output byte array.
        @param outputIndex The index to start writing.
        @return The output byte array.
        */
        static toBytes16(value: number, littleEndian: boolean, output: Uint8Array, outputIndex: number): Uint8Array;
        /**
        Converts a 17-bit value to a byte array.
        @param value The value to write.
        @param bitOffset The offset of the value within the byte.
        @param littleEndian Whether to use little-endian format.
        @return The output byte array.
        */
        static toBytes17(value: number, bitOffset: number, littleEndian: boolean): Uint8Array;
        /**
        Writes a 17-bit value to a byte array.
        @param value The value to write.
        @param bitOffset The offset of the value within the byte.
        @param littleEndian Whether to use little-endian format.
        @param output The output byte array.
        @param outputIndex The index to start writing.
        @return The output byte array.
        */
        static toBytes17(value: number, bitOffset: number, littleEndian: boolean, output: Uint8Array, outputIndex: number): Uint8Array;
        /**
        Converts an 18-bit value to a byte array.
        @param value The value to write.
        @param bitOffset The offset of the value within the byte.
        @param littleEndian Whether to use little-endian format.
        @return The output byte array.
        */
        static toBytes18(value: number, bitOffset: number, littleEndian: boolean): Uint8Array;
        /**
        Writes an 18-bit value to a byte array.
        @param value The value to write.
        @param bitOffset The offset of the value within the byte.
        @param littleEndian Whether to use little-endian format.
        @param output The output byte array.
        @param outputIndex The index to start writing.
        @return The output byte array.
        */
        static toBytes18(value: number, bitOffset: number, littleEndian: boolean, output: Uint8Array, outputIndex: number): Uint8Array;
        /**
        Converts a 19-bit value to a byte array.
        @param value The value to write.
        @param bitOffset The offset of the value within the byte.
        @param littleEndian Whether to use little-endian format.
        @return The output byte array.
        */
        static toBytes19(value: number, bitOffset: number, littleEndian: boolean): Uint8Array;
        /**
        Writes a 19-bit value to a byte array.
        @param value The value to write.
        @param bitOffset The offset of the value within the byte.
        @param littleEndian Whether to use little-endian format.
        @param output The output byte array.
        @param outputIndex The index to start writing.
        @return The output byte array.
        */
        static toBytes19(value: number, bitOffset: number, littleEndian: boolean, output: Uint8Array, outputIndex: number): Uint8Array;
        /**
        Converts a 2-bit value to a byte array.
        @param value The value to write.
        @param bitOffset The offset of the value within the byte.
        @return The output byte array.
        */
        static toBytes2(value: number, bitOffset: number): Uint8Array;
        /**
        Writes a 2-bit value to a byte array.
        @param value The value to write.
        @param bitOffset The offset of the value within the byte.
        @param output The output byte array.
        @param outputIndex The index to start writing.
        @return The output byte array.
        */
        static toBytes2(value: number, bitOffset: number, output: Uint8Array, outputIndex: number): Uint8Array;
        /**
        Converts a 20-bit value to a byte array.
        @param value The value to write.
        @param bitOffset The offset of the value within the byte.
        @param littleEndian Whether to use little-endian format.
        @return The output byte array.
        */
        static toBytes20(value: number, bitOffset: number, littleEndian: boolean): Uint8Array;
        /**
        Writes a 20-bit value to a byte array.
        @param value The value to write.
        @param bitOffset The offset of the value within the byte.
        @param littleEndian Whether to use little-endian format.
        @param output The output byte array.
        @param outputIndex The index to start writing.
        @return The output byte array.
        */
        static toBytes20(value: number, bitOffset: number, littleEndian: boolean, output: Uint8Array, outputIndex: number): Uint8Array;
        /**
        Converts a 21-bit value to a byte array.
        @param value The value to write.
        @param bitOffset The offset of the value within the byte.
        @param littleEndian Whether to use little-endian format.
        @return The output byte array.
        */
        static toBytes21(value: number, bitOffset: number, littleEndian: boolean): Uint8Array;
        /**
        Writes a 21-bit value to a byte array.
        @param value The value to write.
        @param bitOffset The offset of the value within the byte.
        @param littleEndian Whether to use little-endian format.
        @param output The output byte array.
        @param outputIndex The index to start writing.
        @return The output byte array.
        */
        static toBytes21(value: number, bitOffset: number, littleEndian: boolean, output: Uint8Array, outputIndex: number): Uint8Array;
        /**
        Converts a 22-bit value to a byte array.
        @param value The value to write.
        @param bitOffset The offset of the value within the byte.
        @param littleEndian Whether to use little-endian format.
        @return The output byte array.
        */
        static toBytes22(value: number, bitOffset: number, littleEndian: boolean): Uint8Array;
        /**
        Writes a 22-bit value to a byte array.
        @param value The value to write.
        @param bitOffset The offset of the value within the byte.
        @param littleEndian Whether to use little-endian format.
        @param output The output byte array.
        @param outputIndex The index to start writing.
        @return The output byte array.
        */
        static toBytes22(value: number, bitOffset: number, littleEndian: boolean, output: Uint8Array, outputIndex: number): Uint8Array;
        /**
        Converts a 23-bit value to a byte array.
        @param value The value to write.
        @param bitOffset The offset of the value within the byte.
        @param littleEndian Whether to use little-endian format.
        @return The output byte array.
        */
        static toBytes23(value: number, bitOffset: number, littleEndian: boolean): Uint8Array;
        /**
        Writes a 23-bit value to a byte array.
        @param value The value to write.
        @param bitOffset The offset of the value within the byte.
        @param littleEndian Whether to use little-endian format.
        @param output The output byte array.
        @param outputIndex The index to start writing.
        @return The output byte array.
        */
        static toBytes23(value: number, bitOffset: number, littleEndian: boolean, output: Uint8Array, outputIndex: number): Uint8Array;
        /**
        Converts a 24-bit value to a byte array.
        @param value The value to write.
        @param littleEndian Whether to use little-endian format.
        @return The output byte array.
        */
        static toBytes24(value: number, littleEndian: boolean): Uint8Array;
        /**
        Writes a 24-bit value to a byte array.
        @param value The value to write.
        @param littleEndian Whether to use little-endian format.
        @param output The output byte array.
        @param outputIndex The index to start writing.
        @return The output byte array.
        */
        static toBytes24(value: number, littleEndian: boolean, output: Uint8Array, outputIndex: number): Uint8Array;
        /**
        Converts a 3-bit value to a byte array.
        @param value The value to write.
        @param bitOffset The offset of the value within the byte.
        @return The output byte array.
        */
        static toBytes3(value: number, bitOffset: number): Uint8Array;
        /**
        Writes a 3-bit value to a byte array.
        @param value The value to write.
        @param bitOffset The offset of the value within the byte.
        @param output The output byte array.
        @param outputIndex The index to start writing.
        @return The output byte array.
        */
        static toBytes3(value: number, bitOffset: number, output: Uint8Array, outputIndex: number): Uint8Array;
        /**
        Converts a 32-bit value to a byte array.
        @param value The value to write.
        @param littleEndian Whether to use little-endian format.
        @return The output byte array.
        */
        static toBytes32(value: number, littleEndian: boolean): Uint8Array;
        /**
        Writes a 32-bit value to a byte array.
        @param value The value to write.
        @param littleEndian Whether to use little-endian format.
        @param output The output byte array.
        @param outputIndex The index to start writing.
        @return The output byte array.
        */
        static toBytes32(value: number, littleEndian: boolean, output: Uint8Array, outputIndex: number): Uint8Array;
        /**
        Converts a 4-bit value to a byte array.
        @param value The value to write.
        @param bitOffset The offset of the value within the byte.
        @return The output byte array.
        */
        static toBytes4(value: number, bitOffset: number): Uint8Array;
        /**
        Writes a 4-bit value to a byte array.
        @param value The value to write.
        @param bitOffset The offset of the value within the byte.
        @param output The output byte array.
        @param outputIndex The index to start writing.
        @return The output byte array.
        */
        static toBytes4(value: number, bitOffset: number, output: Uint8Array, outputIndex: number): Uint8Array;
        /**
        Converts a 40-bit value to a byte array.
        @param value The value to write.
        @param littleEndian Whether to use little-endian format.
        @return The output byte array.
        */
        static toBytes40(value: number, littleEndian: boolean): Uint8Array;
        /**
        Writes a 40-bit value to a byte array.
        @param value The value to write.
        @param littleEndian Whether to use little-endian format.
        @param output The output byte array.
        @param outputIndex The index to start writing.
        @return The output byte array.
        */
        static toBytes40(value: number, littleEndian: boolean, output: Uint8Array, outputIndex: number): Uint8Array;
        /**
        Converts a 48-bit value to a byte array.
        @param value The value to write.
        @param littleEndian Whether to use little-endian format.
        @return The output byte array.
        */
        static toBytes48(value: number, littleEndian: boolean): Uint8Array;
        /**
        Writes a 48-bit value to a byte array.
        @param value The value to write.
        @param littleEndian Whether to use little-endian format.
        @param output The output byte array.
        @param outputIndex The index to start writing.
        @return The output byte array.
        */
        static toBytes48(value: number, littleEndian: boolean, output: Uint8Array, outputIndex: number): Uint8Array;
        /**
        Converts a 5-bit value to a byte array.
        @param value The value to write.
        @param bitOffset The offset of the value within the byte.
        @return The output byte array.
        */
        static toBytes5(value: number, bitOffset: number): Uint8Array;
        /**
        Writes a 5-bit value to a byte array.
        @param value The value to write.
        @param bitOffset The offset of the value within the byte.
        @param output The output byte array.
        @param outputIndex The index to start writing.
        @return The output byte array.
        */
        static toBytes5(value: number, bitOffset: number, output: Uint8Array, outputIndex: number): Uint8Array;
        /**
        Converts a 56-bit value to a byte array.
        @param value The value to write.
        @param littleEndian Whether to use little-endian format.
        @return The output byte array.
        */
        static toBytes56(value: number, littleEndian: boolean): Uint8Array;
        /**
        Writes a 56-bit value to a byte array.
        @param value The value to write.
        @param littleEndian Whether to use little-endian format.
        @param output The output byte array.
        @param outputIndex The index to start writing.
        @return The output byte array.
        */
        static toBytes56(value: number, littleEndian: boolean, output: Uint8Array, outputIndex: number): Uint8Array;
        /**
        Converts a 6-bit value to a byte array.
        @param value The value to write.
        @param bitOffset The offset of the value within the byte.
        @return The output byte array.
        */
        static toBytes6(value: number, bitOffset: number): Uint8Array;
        /**
        Writes a 6-bit value to a byte array.
        @param value The value to write.
        @param bitOffset The offset of the value within the byte.
        @param output The output byte array.
        @param outputIndex The index to start writing.
        @return The output byte array.
        */
        static toBytes6(value: number, bitOffset: number, output: Uint8Array, outputIndex: number): Uint8Array;
        /**
        Converts a 64-bit value to a byte array.
        @param value The value to write.
        @param littleEndian Whether to use little-endian format.
        @return The output byte array.
        */
        static toBytes64(value: number, littleEndian: boolean): Uint8Array;
        /**
        Writes a 64-bit value to a byte array.
        @param value The value to write.
        @param littleEndian Whether to use little-endian format.
        @param output The output byte array.
        @param outputIndex The index to start writing.
        @return The output byte array.
        */
        static toBytes64(value: number, littleEndian: boolean, output: Uint8Array, outputIndex: number): Uint8Array;
        /**
        Converts a 7-bit value to a byte array.
        @param value The value to write.
        @param bitOffset The offset of the value within the byte.
        @return The output byte array.
        */
        static toBytes7(value: number, bitOffset: number): Uint8Array;
        /**
        Writes a 7-bit value to a byte array.
        @param value The value to write.
        @param bitOffset The offset of the value within the byte.
        @param output The output byte array.
        @param outputIndex The index to start writing.
        @return The output byte array.
        */
        static toBytes7(value: number, bitOffset: number, output: Uint8Array, outputIndex: number): Uint8Array;
        /**
        Converts an 8-bit value to a byte array.
        @param value The value to write.
        @return The output byte array.
        */
        static toBytes8(value: number): Uint8Array;
        /**
        Writes an 8-bit value to a byte array.
        @param value The value to write.
        @param output The output byte array.
        @param outputIndex The index to start writing.
        @return The output byte array.
        */
        static toBytes8(value: number, output: Uint8Array, outputIndex: number): Uint8Array;
        /**
        Converts a 9-bit value to a byte array.
        @param value The value to write.
        @param bitOffset The offset of the value within the byte.
        @param littleEndian Whether to use little-endian format.
        @return The output byte array.
        */
        static toBytes9(value: number, bitOffset: number, littleEndian: boolean): Uint8Array;
        /**
        Writes a 9-bit value to a byte array.
        @param value The value to write.
        @param bitOffset The offset of the value within the byte.
        @param littleEndian Whether to use little-endian format.
        @param output The output byte array.
        @param outputIndex The index to start writing.
        @return The output byte array.
        */
        static toBytes9(value: number, bitOffset: number, littleEndian: boolean, output: Uint8Array, outputIndex: number): Uint8Array;
        /**
        Transforms a byte containing a 2D plane (rotates 90, 180, 270)
        @param inputFrame The inputFrame.
        @param outputFrame The outputFrame.
        @param rotation The rotation.
        @param width The width.
        @param height The height.
        @param stride The stride.
        */
        static transform(inputFrame: Uint8Array, outputFrame: Uint8Array, width: number, height: number, stride: number, rotation: number): void;
        /**
        Transforms a byte containing a 2D plane (rotates 90, 180, 270)
        @param inputFrame The inputFrame.
        @param outputFrame The outputFrame.
        @param rotation The rotation.
        @param width The width.
        @param height The height.
        @param stride The stride.
        @param inputStart The inputStart.
        @param outputStart The outputStart.
        */
        static transform(inputFrame: Uint8Array, outputFrame: Uint8Array, width: number, height: number, stride: number, rotation: number, inputStart: number, outputStart: number): void;
        /**
        Transforms a byte containing a 2D plane (rotates 90, 180, 270). When transforming interleaved planes. Set the chunkLength to the number of planes.
        @param inputFrame The inputFrame.
        @param outputFrame The outputFrame.
        @param rotation The rotation.
        @param width The width.
        @param height The height.
        @param stride The stride.
        @param inputStart The inputStart.
        @param outputStart The outputStart.
        @param chunkLength The chunkLength.
        */
        static transform(inputFrame: Uint8Array, outputFrame: Uint8Array, width: number, height: number, stride: number, rotation: number, inputStart: number, outputStart: number, chunkLength: number): void;
        /**
        Transforms a byte containing a 2D plane (rotates 90, 180, 270)
        @param inputFrame The inputFrame.
        @param outputFrame The outputFrame.
        @param rotation The rotation.
        @param width The width.
        @param height The height.
        @param stride The stride.
        @param start Start position for both input and output frame
        */
        static transform(inputFrame: Uint8Array, outputFrame: Uint8Array, width: number, height: number, stride: number, rotation: number, start: number): void;
        /**
        Tries to read a 1-bit value from a byte array.
        @param input The input byte array.
        @param inputIndex The index to start reading.
        @param bitOffset The offset of the value within the byte.
        @param value The value.
        @return `true` if the index is valid and the value was read; otherwise, `false`
        */
        static tryFromBytes1(input: Uint8Array, inputIndex: number, bitOffset: number, value: fm.liveswitch.Holder<boolean>): boolean;
        /**
        Tries to read a 10-bit value from a byte array.
        @param input The input byte array.
        @param inputIndex The index to start reading.
        @param bitOffset The offset of the value within the byte.
        @param value The value.
        @return `true` if the index is valid and the value was read; otherwise, `false`
        */
        static tryFromBytes10(input: Uint8Array, inputIndex: number, bitOffset: number, value: fm.liveswitch.Holder<number>): boolean;
        /**
        Tries to read a 11-bit value from a byte array.
        @param input The input byte array.
        @param inputIndex The index to start reading.
        @param bitOffset The offset of the value within the byte.
        @param value The value.
        @return `true` if the index is valid and the value was read; otherwise, `false`
        */
        static tryFromBytes11(input: Uint8Array, inputIndex: number, bitOffset: number, value: fm.liveswitch.Holder<number>): boolean;
        /**
        Tries to read a 12-bit value from a byte array.
        @param input The input byte array.
        @param inputIndex The index to start reading.
        @param bitOffset The offset of the value within the byte.
        @param value The value.
        @return `true` if the index is valid and the value was read; otherwise, `false`
        */
        static tryFromBytes12(input: Uint8Array, inputIndex: number, bitOffset: number, value: fm.liveswitch.Holder<number>): boolean;
        /**
        Tries to read a 13-bit value from a byte array.
        @param input The input byte array.
        @param inputIndex The index to start reading.
        @param bitOffset The offset of the value within the byte.
        @param value The value.
        @return `true` if the index is valid and the value was read; otherwise, `false`
        */
        static tryFromBytes13(input: Uint8Array, inputIndex: number, bitOffset: number, value: fm.liveswitch.Holder<number>): boolean;
        /**
        Tries to read a 14-bit value from a byte array.
        @param input The input byte array.
        @param inputIndex The index to start reading.
        @param bitOffset The offset of the value within the byte.
        @param value The value.
        @return `true` if the index is valid and the value was read; otherwise, `false`
        */
        static tryFromBytes14(input: Uint8Array, inputIndex: number, bitOffset: number, value: fm.liveswitch.Holder<number>): boolean;
        /**
        Tries to read a 15-bit value from a byte array.
        @param input The input byte array.
        @param inputIndex The index to start reading.
        @param bitOffset The offset of the value within the byte.
        @param value The value.
        @return `true` if the index is valid and the value was read; otherwise, `false`
        */
        static tryFromBytes15(input: Uint8Array, inputIndex: number, bitOffset: number, value: fm.liveswitch.Holder<number>): boolean;
        /**
        Tries to read a 16-bit value from a byte array.
        @param input The input byte array.
        @param inputIndex The index to start reading.
        @param littleEndian Whether to use little-endian format.
        @param value The value.
        @return `true` if the index is valid and the value was read; otherwise, `false`
        */
        static tryFromBytes16(input: Uint8Array, inputIndex: number, littleEndian: boolean, value: fm.liveswitch.Holder<number>): boolean;
        /**
        Tries to read a 17-bit value from a byte array.
        @param input The input byte array.
        @param inputIndex The index to start reading.
        @param bitOffset The offset of the value within the byte.
        @param value The value.
        @return `true` if the index is valid and the value was read; otherwise, `false`
        */
        static tryFromBytes17(input: Uint8Array, inputIndex: number, bitOffset: number, value: fm.liveswitch.Holder<number>): boolean;
        /**
        Tries to read a 18-bit value from a byte array.
        @param input The input byte array.
        @param inputIndex The index to start reading.
        @param bitOffset The offset of the value within the byte.
        @param value The value.
        @return `true` if the index is valid and the value was read; otherwise, `false`
        */
        static tryFromBytes18(input: Uint8Array, inputIndex: number, bitOffset: number, value: fm.liveswitch.Holder<number>): boolean;
        /**
        Tries to read a 19-bit value from a byte array.
        @param input The input byte array.
        @param inputIndex The index to start reading.
        @param bitOffset The offset of the value within the byte.
        @param value The value.
        @return `true` if the index is valid and the value was read; otherwise, `false`
        */
        static tryFromBytes19(input: Uint8Array, inputIndex: number, bitOffset: number, value: fm.liveswitch.Holder<number>): boolean;
        /**
        Tries to read a 2-bit value from a byte array.
        @param input The input byte array.
        @param inputIndex The index to start reading.
        @param bitOffset The offset of the value within the byte.
        @param value The value.
        @return `true` if the index is valid and the value was read; otherwise, `false`
        */
        static tryFromBytes2(input: Uint8Array, inputIndex: number, bitOffset: number, value: fm.liveswitch.Holder<number>): boolean;
        /**
        Tries to read a 20-bit value from a byte array.
        @param input The input byte array.
        @param inputIndex The index to start reading.
        @param bitOffset The offset of the value within the byte.
        @param value The value.
        @return `true` if the index is valid and the value was read; otherwise, `false`
        */
        static tryFromBytes20(input: Uint8Array, inputIndex: number, bitOffset: number, value: fm.liveswitch.Holder<number>): boolean;
        /**
        Tries to read a 21-bit value from a byte array.
        @param input The input byte array.
        @param inputIndex The index to start reading.
        @param bitOffset The offset of the value within the byte.
        @param value The value.
        @return `true` if the index is valid and the value was read; otherwise, `false`
        */
        static tryFromBytes21(input: Uint8Array, inputIndex: number, bitOffset: number, value: fm.liveswitch.Holder<number>): boolean;
        /**
        Tries to read a 22-bit value from a byte array.
        @param input The input byte array.
        @param inputIndex The index to start reading.
        @param bitOffset The offset of the value within the byte.
        @param value The value.
        @return `true` if the index is valid and the value was read; otherwise, `false`
        */
        static tryFromBytes22(input: Uint8Array, inputIndex: number, bitOffset: number, value: fm.liveswitch.Holder<number>): boolean;
        /**
        Tries to read a 23-bit value from a byte array.
        @param input The input byte array.
        @param inputIndex The index to start reading.
        @param bitOffset The offset of the value within the byte.
        @param value The value.
        @return `true` if the index is valid and the value was read; otherwise, `false`
        */
        static tryFromBytes23(input: Uint8Array, inputIndex: number, bitOffset: number, value: fm.liveswitch.Holder<number>): boolean;
        /**
        Tries to read a 24-bit value from a byte array.
        @param input The input byte array.
        @param inputIndex The index to start reading.
        @param littleEndian Whether to use little-endian format.
        @param value The value.
        @return `true` if the index is valid and the value was read; otherwise, `false`
        */
        static tryFromBytes24(input: Uint8Array, inputIndex: number, littleEndian: boolean, value: fm.liveswitch.Holder<number>): boolean;
        /**
        Tries to read a 3-bit value from a byte array.
        @param input The input byte array.
        @param inputIndex The index to start reading.
        @param bitOffset The offset of the value within the byte.
        @param value The value.
        @return `true` if the index is valid and the value was read; otherwise, `false`
        */
        static tryFromBytes3(input: Uint8Array, inputIndex: number, bitOffset: number, value: fm.liveswitch.Holder<number>): boolean;
        /**
        Tries to read a 32-bit value from a byte array.
        @param input The input byte array.
        @param inputIndex The index to start reading.
        @param littleEndian Whether to use little-endian format.
        @param value The value.
        @return `true` if the index is valid and the value was read; otherwise, `false`
        */
        static tryFromBytes32(input: Uint8Array, inputIndex: number, littleEndian: boolean, value: fm.liveswitch.Holder<number>): boolean;
        /**
        Tries to read a 4-bit value from a byte array.
        @param input The input byte array.
        @param inputIndex The index to start reading.
        @param bitOffset The offset of the value within the byte.
        @param value The value.
        @return `true` if the index is valid and the value was read; otherwise, `false`
        */
        static tryFromBytes4(input: Uint8Array, inputIndex: number, bitOffset: number, value: fm.liveswitch.Holder<number>): boolean;
        /**
        Tries to read a 40-bit value from a byte array.
        @param input The input byte array.
        @param inputIndex The index to start reading.
        @param littleEndian Whether to use little-endian format.
        @param value The value.
        @return `true` if the index is valid and the value was read; otherwise, `false`
        */
        static tryFromBytes40(input: Uint8Array, inputIndex: number, littleEndian: boolean, value: fm.liveswitch.Holder<number>): boolean;
        /**
        Tries to read a 48-bit value from a byte array.
        @param input The input byte array.
        @param inputIndex The index to start reading.
        @param littleEndian Whether to use little-endian format.
        @param value The value.
        @return `true` if the index is valid and the value was read; otherwise, `false`
        */
        static tryFromBytes48(input: Uint8Array, inputIndex: number, littleEndian: boolean, value: fm.liveswitch.Holder<number>): boolean;
        /**
        Tries to read a 5-bit value from a byte array.
        @param input The input byte array.
        @param inputIndex The index to start reading.
        @param bitOffset The offset of the value within the byte.
        @param value The value.
        @return `true` if the index is valid and the value was read; otherwise, `false`
        */
        static tryFromBytes5(input: Uint8Array, inputIndex: number, bitOffset: number, value: fm.liveswitch.Holder<number>): boolean;
        /**
        Tries to read a 56-bit value from a byte array.
        @param input The input byte array.
        @param inputIndex The index to start reading.
        @param littleEndian Whether to use little-endian format.
        @param value The value.
        @return `true` if the index is valid and the value was read; otherwise, `false`
        */
        static tryFromBytes56(input: Uint8Array, inputIndex: number, littleEndian: boolean, value: fm.liveswitch.Holder<number>): boolean;
        /**
        Tries to read a 6-bit value from a byte array.
        @param input The input byte array.
        @param inputIndex The index to start reading.
        @param bitOffset The offset of the value within the byte.
        @param value The value.
        @return `true` if the index is valid and the value was read; otherwise, `false`
        */
        static tryFromBytes6(input: Uint8Array, inputIndex: number, bitOffset: number, value: fm.liveswitch.Holder<number>): boolean;
        /**
        Tries to read a 64-bit value from a byte array.
        @param input The input byte array.
        @param inputIndex The index to start reading.
        @param littleEndian Whether to use little-endian format.
        @param value The value.
        @return `true` if the index is valid and the value was read; otherwise, `false`
        */
        static tryFromBytes64(input: Uint8Array, inputIndex: number, littleEndian: boolean, value: fm.liveswitch.Holder<number>): boolean;
        /**
        Tries to read a 7-bit value from a byte array.
        @param input The input byte array.
        @param inputIndex The index to start reading.
        @param bitOffset The offset of the value within the byte.
        @param value The value.
        @return `true` if the index is valid and the value was read; otherwise, `false`
        */
        static tryFromBytes7(input: Uint8Array, inputIndex: number, bitOffset: number, value: fm.liveswitch.Holder<number>): boolean;
        /**
        Tries to read an 8-bit value from a byte array.
        @param input The input byte array.
        @param inputIndex The index to start reading.
        @param value The value.
        @return `true` if the index is valid and the value was read; otherwise, `false`
        */
        static tryFromBytes8(input: Uint8Array, inputIndex: number, value: fm.liveswitch.Holder<number>): boolean;
        /**
        Tries to read a 9-bit value from a byte array.
        @param input The input byte array.
        @param inputIndex The index to start reading.
        @param bitOffset The offset of the value within the byte.
        @param value The value.
        @return `true` if the index is valid and the value was read; otherwise, `false`
        */
        static tryFromBytes9(input: Uint8Array, inputIndex: number, bitOffset: number, value: fm.liveswitch.Holder<number>): boolean;
        /** @hidden */
        private static __fmliveswitchBinaryInitialized;
        /** @hidden */
        private static __fmliveswitchBinaryInitializing;
        /** @hidden */
        static fmliveswitchBinaryInitialize(): void;
    }
}
declare namespace fm.liveswitch {
    /**
    Class to hold a boolean value passed by reference.
    */
    class BooleanHolder {
        getTypeString(): string;
        /** @hidden */
        private _value;
        private fmliveswitchBooleanHolderInit;
        /**
        Initializes a new instance of the [[fm.liveswitch.booleanHolder]] class.
        */
        constructor();
        /**
        Initializes a new instance of the [[fm.liveswitch.booleanHolder]] class.
        @param value The value.
        */
        constructor(value: boolean);
        /**
        Gets the value.
        */
        getValue(): boolean;
        /**
        Sets the value.
        */
        setValue(value: boolean): void;
    }
}
declare namespace fm.liveswitch {
    /**
    Details about the current build.
    */
    class Build {
        getTypeString(): string;
        /**
        Gets the build version.
        */
        static readonly VersionConstant: string;
        constructor();
        /**
        Gets the build date.
        */
        static getDate(): fm.liveswitch.DateTime;
        /**
        Gets the build day.
        */
        static getDay(): number;
        /**
        Gets the build major version.
        */
        static getMajorVersion(): number;
        /**
        Gets the build minor version.
        */
        static getMinorVersion(): number;
        /**
        Gets the build month.
        */
        static getMonth(): number;
        /**
        Gets the build patch version.
        */
        static getPatchVersion(): number;
        /**
        Gets the build revision version.
        */
        static getRevisionVersion(): number;
        /**
        Gets the full build version.
        */
        static getVersion(): string;
        /**
        Gets the build year.
        */
        static getYear(): number;
    }
}
declare namespace fm.liveswitch {
    /**
    Class to hold a byte value passed by reference.
    */
    class ByteHolder {
        getTypeString(): string;
        /** @hidden */
        private _value;
        private fmliveswitchByteHolderInit;
        /**
        Initializes a new instance of the [[fm.liveswitch.byteHolder]] class.
        */
        constructor();
        /**
        Initializes a new instance of the [[fm.liveswitch.byteHolder]] class.
        @param value The value.
        */
        constructor(value: number);
        /**
        Gets the value.
        */
        getValue(): number;
        /**
        Sets the value.
        */
        setValue(value: number): void;
    }
}
declare namespace fm.liveswitch {
    /**
    Class to hold a character value passed by reference.
    */
    class CharacterHolder {
        getTypeString(): string;
        /** @hidden */
        private _value;
        private fmliveswitchCharacterHolderInit;
        /**
        Initializes a new instance of the [[fm.liveswitch.characterHolder]] class.
        */
        constructor();
        /**
        Initializes a new instance of the [[fm.liveswitch.characterHolder]] class.
        @param value The value.
        */
        constructor(value: number);
        /**
        Gets the value.
        */
        getValue(): number;
        /**
        Sets the value.
        */
        setValue(value: number): void;
    }
}
declare namespace fm.liveswitch {
    /**
    A circular buffer.
    */
    class CircularBuffer {
        getTypeString(): string;
        /** @hidden */
        private __allowRead;
        /** @hidden */
        private __buffer;
        /** @hidden */
        private _latency;
        /** @hidden */
        private _littleEndian;
        /** @hidden */
        private _readOffset;
        /** @hidden */
        private _writeOffset;
        private fmliveswitchCircularBufferInit;
        /**
        Initializes a new instance of the [[fm.liveswitch.circularBuffer]] class.
        @param length The length.
        @param latency The latency.
        */
        constructor(length: number, latency: number);
        /**
        Initializes a new instance of the [[fm.liveswitch.circularBuffer]] class.
        @param length The length.
        @param latency The latency.
        @param littleEndian Whether the data is little-endian.
        */
        constructor(length: number, latency: number, littleEndian: boolean);
        /**
        Gets the number of bytes available for reading.
        */
        getAvailable(): number;
        /**
        Gets the latency.
        */
        getLatency(): number;
        /**
        Gets the length.
        */
        getLength(): number;
        /**
        Gets whether the data is little-endian.
        */
        getLittleEndian(): boolean;
        /**
        Gets the read offset.
        */
        getReadOffset(): number;
        /**
        Gets the read offset.
        */
        getWriteOffset(): number;
        /**
        Reads data from the buffer.
        @param length The number of bytes to read.
        */
        read(length: number): fm.liveswitch.DataBuffer;
        /** @hidden */
        private setLatency;
        /** @hidden */
        private setLittleEndian;
        /** @hidden */
        private setReadOffset;
        /** @hidden */
        private setWriteOffset;
        /**
        Writes data to the buffer.
        @param buffer The data to write.
        */
        write(buffer: fm.liveswitch.DataBuffer): void;
    }
}
declare namespace fm.liveswitch {
    /**
    A collection of values.
    */
    abstract class Collection<T, TCollection extends fm.liveswitch.Collection<T, TCollection>> {
        getTypeString(): string;
        /** @hidden */
        private __values;
        /** @hidden */
        private __valuesCache;
        /** @hidden */
        private __valuesLock;
        /**
        Initializes a new instance of the [[fm.liveswitch.collection]] class.
        */
        constructor();
        /**
        Adds a value.
        @param value The value.
        */
        add(value: T): boolean;
        /**
        Adds some values.
        @param values The values.
        */
        addMany(values: T[]): void;
        /**
        Invoked when an element is added to the collection.
        @param value The value.
        */
        protected addSuccess(value: T): void;
        /**
        Invoked after an element is added to the collection.
        @param value The value.
        */
        protected addSuccessNoLock(value: T): void;
        /**
        Determined whether the collection contains at least one value.
        */
        any(): boolean;
        /**
        Determined whether the collection contains at least one value that matches the specified predicate.
        @param predicate The predicate.
        */
        any(predicate: fm.liveswitch.IFunction1<T, boolean>): boolean;
        /**
        Creates an array from a list.
        @param list The list.
        */
        protected abstract arrayFromList(list: Array<T>): T[];
        /**
        Determines whether the collection contains a value.
        @param value The value.
        */
        contains(value: T): boolean;
        /**
        Creates a collection.
        */
        protected abstract createCollection(): TCollection;
        /**
        Gets the first value. Throws an exception if there are no values in the collection.
        */
        first(): T;
        /**
        Gets the first value that matches the specified predicate. Throws an exception if there are no such values in the collection.
        @param predicate The predicate.
        */
        first(predicate: fm.liveswitch.IFunction1<T, boolean>): T;
        /**
        Gets the first value. Returns a default value if there are no values in the collection.
        */
        firstOrDefault(): T;
        /**
        Gets the first value that matches the specified predicate. Returns a default value if there are no such values in the collection.
        @param predicate The predicate.
        */
        firstOrDefault(predicate: fm.liveswitch.IFunction1<T, boolean>): T;
        /**
        Executes a callback function once per value.
        @param callback The callback to execute.
        */
        forEach(callback: fm.liveswitch.IAction2<T, number>): void;
        /**
        Gets the count.
        */
        getCount(): number;
        /**
        Gets the value.
        */
        getValue(): T;
        /**
        Gets the values.
        */
        getValues(): T[];
        /**
        Gets the last value. Throws an exception if there are no values in the collection.
        */
        last(): T;
        /**
        Gets the last value that matches the specified predicate. Throws an exception if there are no such values in the collection.
        @param predicate The predicate.
        */
        last(predicate: fm.liveswitch.IFunction1<T, boolean>): T;
        /**
        Gets the last value. Returns a default value if there are no values in the collection.
        */
        lastOrDefault(): T;
        /**
        Gets the last value that matches the specified predicate. Returns a default value if there are no such values in the collection.
        @param predicate The predicate.
        */
        lastOrDefault(predicate: fm.liveswitch.IFunction1<T, boolean>): T;
        /**
        Removes a value.
        @param value The value.
        */
        remove(value: T): boolean;
        /**
        Removes all values.
        */
        removeAll(): void;
        /**
        Removes the first value.
        */
        removeFirst(): T;
        /**
        Removes the first value that matches a given condition.
        */
        removeFirst(condition: fm.liveswitch.IFunction1<T, boolean>): T;
        /**
        Removes the last value.
        */
        removeLast(): T;
        /**
        Removes the last value that matches a given condition.
        */
        removeLast(condition: fm.liveswitch.IFunction1<T, boolean>): T;
        /**
        Removes some values.
        @param values The values.
        */
        removeMany(values: T[]): void;
        /**
        Invoked when an element is removed from the collection.
        @param value The value.
        */
        protected removeSuccess(value: T): void;
        /**
        Invoked after an element is removed from the collection.
        @param value The value.
        */
        protected removeSuccessNoLock(value: T): void;
        /**
        Replaces the collection with a new set of values.
        @param values The values.
        */
        replace(values: T[]): void;
        /**
        Sets the value.
        */
        setValue(value: T): void;
        /**
        Sets the values.
        */
        setValues(value: T[]): void;
        /**
        Gets the only value. Throws an exception if there are no values or more than one value in the collection.
        */
        single(): T;
        /**
        Gets the only value that matches the specified predicate. Throws an exception if there are no values or more than one value in the collection.
        */
        single(predicate: fm.liveswitch.IFunction1<T, boolean>): T;
        /**
        Gets the only value. Returns a default value if there are no values or more than one value in the collection.
        */
        singleOrDefault(): T;
        /**
        Gets the only value that matches the specified predicate. Returns a default value if there are no values or more than one value in the collection.
        */
        singleOrDefault(predicate: fm.liveswitch.IFunction1<T, boolean>): T;
        /**
        Clones the values into a new array.
        */
        toArray(): T[];
        /**
        Gets the value at the specified index. Throws an exception if a value does not exist at that index.
        @param index The index.
        */
        valueAt(index: number): T;
        /**
        Gets the value at the specified index. Returns a default value if a value does not exist at that index.
        @param index The index.
        */
        valueAtOrDefault(index: number): T;
        /**
        Creates a new collection with values that match the specified predicate.
        @param predicate The predicate.
        */
        where(predicate: fm.liveswitch.IFunction2<T, number, boolean>): TCollection;
    }
}
declare namespace fm.liveswitch {
    /**
    A record that calculates the min, max, and average from integer samples.
    */
    class DiagnosticSampler {
        getTypeString(): string;
        /** @hidden */
        private __arrayPointer;
        /** @hidden */
        private __count;
        /** @hidden */
        private __max;
        /** @hidden */
        private __min;
        /** @hidden */
        private __samples;
        /** @hidden */
        private __sum;
        /** @hidden */
        private _label;
        /** @hidden */
        private _lastValue;
        private fmliveswitchDiagnosticSamplerInit;
        /**
        Creates a new instance of the DiagnosticRecord.
        */
        constructor();
        /**
        Creates a new instance of the DiagnosticRecord.
        @param averageSampleCount How many samples to include in the average.
        */
        constructor(averageSampleCount: number);
        /**
        Creates a new instance of the DiagnosticRecord.
        @param averageSampleCount How many samples to include in the average.
        @param label The label for this sampler.
        */
        constructor(averageSampleCount: number, label: string);
        /**
        Creates a new instance of the DiagnosticRecord.
        @param label The label for this sampler.
        */
        constructor(label: string);
        /**
        Adds a new sample to the calculation.
        @param longSample The sample to add.
        */
        addSample(longSample: number): void;
        /**
        Gets the average of all samples.
        */
        getAverage(): number;
        /**
        Gets how many samples this record has used.
        */
        getCount(): number;
        /**
        Gets the label for this sampler.
        */
        getLabel(): string;
        /**
        Gets the value of the last sample recorded.
        */
        getLastValue(): number;
        /**
        Gets the maximum sample ever recorded.
        */
        getMax(): number;
        /**
        Gets the minimum sample ever recorded.
        */
        getMin(): number;
        /**
        Gets how many samples are included in the average.
        */
        getSamplesInAverage(): number;
        /**
        Gets the sum of all values.
        */
        getSum(): number;
        /** @hidden */
        private setLabel;
        /** @hidden */
        private setLastValue;
    }
}
declare namespace fm.liveswitch {
    /**
    An interface for detecting equivalency.
    */
    interface IEquivalent<T> {
        isEquivalent(instance: T): boolean;
    }
}
declare namespace fm.liveswitch {
    /**
    Utility class to assist with ISO-8601 timestamp conversions.
    */
    class Iso8601Timestamp {
        getTypeString(): string;
        constructor();
        /**
        Converts a date to a ISO-8601 timestamp.
        @param dateTime The date to convert.
        @return The equivalent ISO-8601 timestamp.
        */
        static dateTimeToIso8601(dateTime: fm.liveswitch.DateTime): string;
        /** @hidden */
        private static getMinimumNeedleIndex;
        /**
        Gets the current UTC time in ISO-8601 format.
        */
        static getUtcNow(): string;
        /**
        Converts a ISO-8601 timestamp to a date.
        @param iso8601 The ISO-8601 timestamp to convert.
        @return The equivalent date.
        */
        static iso8601ToDateTime(iso8601: string): fm.liveswitch.DateTime;
        /** @hidden */
        private static tryParseDate;
        /** @hidden */
        private static tryParseTime;
        /** @hidden */
        private static tryParseTimezone;
        /** @hidden */
        private static tryRead;
    }
}
declare namespace fm.liveswitch {
    /** @hidden */
    class JsonCheckerModeWrapper {
        getTypeString(): string;
        /** @hidden */
        private _value;
        constructor(value: fm.liveswitch.JsonCheckerMode);
        toString(): string;
    }
}
declare namespace fm.liveswitch {
    /**
    A countdown latch that will signal when the counter reaches zero.
    */
    class ManagedCountdownLatch {
        getTypeString(): string;
        /** @hidden */
        private __counter;
        /** @hidden */
        private __waitPromise;
        /**
        Creates a new instance of the latch with an unknown count. This will cause the latch to count into the negatives until SetCount is called.
        */
        constructor();
        /**
        Creates a new instance of the latch with a count.
        @param initialCount The initial counter value.
        */
        constructor(initialCount: number);
        /**
        Decrements the counter by one and signals if it reaches zero.
        */
        decrement(): void;
        /**
        Gets the current count on the latch.
        */
        getCount(): number;
        /**
        Resets the latch with an unknown count. This will cause the latch to count into the negatives until SetCount is called.
        */
        reset(): void;
        /**
        Resets the latch with a count.
        @param initialCount The initial counter value.
        */
        reset(initialCount: number): void;
        /**
        Sets the counter for the latch. This brings the count back up into positive numbers.
        */
        setCount(count: number): void;
        /**
        Generates a string description of this instance.
        */
        toString(): string;
        /**
        Returns a promise that resolves once the counter reaches zero.
        */
        waitAsync(): fm.liveswitch.Future<Object>;
    }
}
declare namespace fm.liveswitch {
    class OperatingSystemWrapper {
        getTypeString(): string;
        /** @hidden */
        private _value;
        constructor(value: fm.liveswitch.OperatingSystem);
        toString(): string;
    }
}
declare namespace fm.liveswitch {
    class ArchitectureWrapper {
        getTypeString(): string;
        /** @hidden */
        private _value;
        constructor(value: fm.liveswitch.Architecture);
        toString(): string;
    }
}
declare namespace fm.liveswitch {
    /**
    A pool of objects.
    */
    class Pool<T> {
        getTypeString(): string;
        /** @hidden */
        private __createObject;
        /** @hidden */
        private __createObjectCounter;
        /** @hidden */
        private __destroyLock;
        /** @hidden */
        private __isDestroyed;
        /** @hidden */
        private __stack;
        /** @hidden */
        private _maxSize;
        /** @hidden */
        private _minSize;
        private fmliveswitchPoolInit;
        /**
        Initializes a new instance of the [[fm.liveswitch.pool]] class with a minimum size of 0 and a maximum size of 2,147,483,647.
        @param createObject A function that creates an object.
        */
        constructor(createObject: fm.liveswitch.IFunction0<T>);
        /**
        Initializes a new instance of the [[fm.liveswitch.pool]] class with a specified minimum size and a maximum size of 2,147,483,647.
        @param createObject A function that creates an object.
        @param minSize The minimum size.
        */
        constructor(createObject: fm.liveswitch.IFunction0<T>, minSize: number);
        /**
        Initializes a new instance of the [[fm.liveswitch.pool]] class. with a specified minimum size and a specified maximum size.
        @param createObject A function that creates an object.
        @param minSize The minimum size.
        @param maxSize The maximum size.
        */
        constructor(createObject: fm.liveswitch.IFunction0<T>, minSize: number, maxSize: number);
        /**
        Removes all items from the pool and calls a callback for each one.
        @param destroyCallback
        */
        destroy(destroyCallback: fm.liveswitch.IAction1<T>): boolean;
        /**
        Gets an object.
        */
        get(): T;
        /**
        Gets the number of available objects.
        */
        getAvailable(): number;
        /**
        Gets the maximum size. Value must be >= 0. A value of 0 indicates no maximum.
        */
        getMaxSize(): number;
        /**
        Gets the minimum size. Value must be >= 0.
        */
        getMinSize(): number;
        /**
        Gets the current size of the pool.
        */
        getSize(): number;
        /**
        Put an object back.
        @param item
        */
        put(item: T): boolean;
        /** @hidden */
        private setMaxSize;
        /** @hidden */
        private setMinSize;
    }
}
declare namespace fm.liveswitch {
    class ProtocolTypeWrapper {
        getTypeString(): string;
        /** @hidden */
        private _value;
        constructor(value: fm.liveswitch.ProtocolType);
        toString(): string;
    }
}
declare namespace fm.liveswitch {
    class SourceLanguageWrapper {
        getTypeString(): string;
        /** @hidden */
        private _value;
        constructor(value: fm.liveswitch.SourceLanguage);
        toString(): string;
    }
}
declare namespace fm.liveswitch {
    /**
    Provides methods for serializing/deserializing .NET value types to/from JSON as well as facilities for converting objects and arrays if appropriate callbacks are supplied to assist with the conversion.
    */
    class JsonSerializer {
        getTypeString(): string;
        constructor();
        /** @hidden */
        private static charToUnicodeString;
        /**
        Deserializes a boolean value.
        @param valueJson The boolean JSON to deserialize.
        @return The deserialized boolean value.
        */
        static deserializeBoolean(valueJson: string): boolean;
        /**
        Deserializes a boolean array from JSON.
        @param arrayJson A JSON-serialized boolean array.
        @return An array of boolean values.
        */
        static deserializeBooleanArray(arrayJson: string): boolean[];
        /**
        Deserializes a decimal value.
        @param valueJson The decimal JSON to deserialize.
        @return The deserialized decimal value.
        */
        static deserializeDecimal(valueJson: string): number;
        /**
        Deserializes a decimal array from JSON.
        @param arrayJson A JSON-serialized decimal array.
        @return An array of decimal values.
        */
        static deserializeDecimalArray(arrayJson: string): number[];
        /**
        Deserializes a JSON string into a dictionary.
        @param dictionaryJson The JSON-encoded dictionary.
        @param createDictionaryCallback The callback that creates a blank dictionary.
        @param deserializeValueCallback The callback that deserializes a value.
        @return
                    The deserialized dictionary.
            
        */
        static deserializeDictionary<T>(dictionaryJson: string, createDictionaryCallback: fm.liveswitch.IFunction0<fm.liveswitch.Hash<string, T>>, deserializeValueCallback: fm.liveswitch.IFunction1<string, T>): fm.liveswitch.Hash<string, T>;
        /**
        Deserializes a double value.
        @param valueJson The double JSON to deserialize.
        @return The deserialized double value.
        */
        static deserializeDouble(valueJson: string): number;
        /**
        Deserializes a double array from JSON.
        @param arrayJson A JSON-serialized double array.
        @return An array of double values.
        */
        static deserializeDoubleArray(arrayJson: string): number[];
        /**
        Deserializes a float value.
        @param valueJson The float JSON to deserialize.
        @return The deserialized float value.
        */
        static deserializeFloat(valueJson: string): number;
        /**
        Deserializes a float array from JSON.
        @param arrayJson A JSON-serialized float array.
        @return An array of float values.
        */
        static deserializeFloatArray(arrayJson: string): number[];
        /**
        Deserializes a globally unique identifier.
        @param valueJson The GUID JSON to deserialize.
        @return The deserialized GUID.
        */
        static deserializeGuid(valueJson: string): fm.liveswitch.Guid;
        /**
        Deserializes a GUID array from JSON.
        @param arrayJson A JSON-serialized GUID array.
        @return An array of GUID values.
        */
        static deserializeGuidArray(arrayJson: string): fm.liveswitch.Guid[];
        /**
        Deserializes an integer value.
        @param valueJson The integer JSON to deserialize.
        @return The deserialized integer value.
        */
        static deserializeInteger(valueJson: string): number;
        /**
        Deserializes a integer array from JSON.
        @param arrayJson A JSON-serialized integer array.
        @return An array of integer values.
        */
        static deserializeIntegerArray(arrayJson: string): number[];
        /**
        Deserializes a long value.
        @param valueJson The long JSON to deserialize.
        @return The deserialized long value.
        */
        static deserializeLong(valueJson: string): number;
        /**
        Deserializes a long array from JSON.
        @param arrayJson A JSON-serialized long array.
        @return An array of long values.
        */
        static deserializeLongArray(arrayJson: string): number[];
        /**
        Deserializes a JSON string into a target object type.
        @param json The JSON-encoded string.
        @param creator The method used for creating a new object.
        @param callback The method used for deserializing a property.
        @return The deserialized object.
        */
        static deserializeObject<T>(json: string, creator: fm.liveswitch.IFunction0<T>, callback: fm.liveswitch.IAction3<T, string, string>): T;
        /**
        Deserializes a JSON string into an array of target object types.
        @param json The JSON-encoded string.
        @param deserializer The callback used to deserialize each item in the array.
        @return An array of deserialized objects.
        */
        static deserializeObjectArray<T>(json: string, deserializer: fm.liveswitch.IFunction1<string, T>): Array<T>;
        /**
        Deserializes a JSON string into a [[fm.liveswitch.serializable]] target object type.
        @param json The JSON-encoded string.
        @param creator The method used for creating a new object.
        @param callback The method used for deserializing a property.
        @return The deserialized object.
        */
        static deserializeObjectFast<T extends fm.liveswitch.Serializable>(json: string, creator: fm.liveswitch.IFunction0<T>, callback: fm.liveswitch.IAction3<T, string, string>): T;
        /**
        Deserializes a piece of raw JSON.
        @param dataJson The raw data.
        @return The deserialized data.
        */
        static deserializeRaw(dataJson: string): string;
        /**
        Deserializes a raw array from JSON.
        @param json A JSON-serialized raw array.
        @return An array of raw values.
        */
        static deserializeRawArray(json: string): Array<string>;
        /**
        Deserializes a string.
        @param valueJson The string to deserialize.
        @return The deserialized string value.
        */
        static deserializeString(valueJson: string): string;
        /**
        Deserializes a simple string array from JSON.
        @param arrayJson A JSON-serialized string array.
        @return An array of string values.
        */
        static deserializeStringArray(arrayJson: string): string[];
        /**
        Escapes any special characters in a string.
        @param text The string without escaped characters.
        @return The escaped string.
        */
        static escapeString(text: string): string;
        /** @hidden */
        private static intToHex;
        /**
        Determines whether the specified JSON string is valid.
        @param json The JSON string to validate.
        @return True if the JSON string is valid; false otherwise.
        */
        static isValidJson(json: string): boolean;
        /**
        Serializes a boolean value.
        @param value The boolean to serialize.
        @return The serialized boolean value.
        */
        static serializeBoolean(value: boolean): string;
        /**
        Serializes a boolean array to JSON.
        @param array An array of boolean values.
        @return A JSON-serialized boolean array.
        */
        static serializeBooleanArray(array: boolean[]): string;
        /**
        Serializes a decimal value.
        @param value The decimal to serialize.
        @return The serialized decimal value.
        */
        static serializeDecimal(value: number): string;
        /**
        Serializes a decimal array to JSON.
        @param array An array of decimal values.
        @return A JSON-serialized decimal array.
        */
        static serializeDecimalArray(array: number[]): string;
        /**
        Serializes a dictionary into a JSON string.
        @param dictionary The dictionary being serialized.
        @param serializeValueCallback The callback that serializes a value.
        @return The dictionary as a JSON string.
        */
        static serializeDictionary<T>(dictionary: fm.liveswitch.Hash<string, T>, serializeValueCallback: fm.liveswitch.IFunction1<T, string>): string;
        /**
        Serializes a double value.
        @param value The double to serialize.
        @return The serialized double value.
        */
        static serializeDouble(value: number): string;
        /**
        Serializes a double array to JSON.
        @param array An array of double values.
        @return A JSON-serialized double array.
        */
        static serializeDoubleArray(array: number[]): string;
        /**
        Serializes a float value.
        @param value The float to serialize.
        @return The serialized float value.
        */
        static serializeFloat(value: number): string;
        /**
        Serializes a float array to JSON.
        @param array An array of float values.
        @return A JSON-serialized float array.
        */
        static serializeFloatArray(array: number[]): string;
        /**
        Serializes a globally unique identifier.
        @param value The GUID to serialize.
        @return The serialized GUID.
        */
        static serializeGuid(value: fm.liveswitch.Guid): string;
        /**
        Serializes a GUID array to JSON.
        @param array An array of GUID values.
        @return A JSON-serialized GUID array.
        */
        static serializeGuidArray(array: fm.liveswitch.Guid[]): string;
        /**
        Serializes an integer value.
        @param value The integer to serialize.
        @return The serialized integer value.
        */
        static serializeInteger(value: number): string;
        /**
        Serializes a integer array to JSON.
        @param array An array of integer values.
        @return A JSON-serialized integer array.
        */
        static serializeIntegerArray(array: number[]): string;
        /**
        Serializes a long value.
        @param value The long to serialize.
        @return The serialized long value.
        */
        static serializeLong(value: number): string;
        /**
        Serializes a long array to JSON.
        @param array An array of long values.
        @return A JSON-serialized long array.
        */
        static serializeLongArray(array: number[]): string;
        /**
        Serializes an object into a JSON string.
        @param source The object being serialized.
        @param callback The method used for serializing properties.
        @return The object as a JSON string.
        */
        static serializeObject<T>(source: T, callback: fm.liveswitch.IAction2<T, fm.liveswitch.Hash<string, string>>): string;
        /**
        Serializes an object array into a JSON string.
        @param objects The object array being serialized.
        @param serializer The callback used to serialize each item in the array.
        @return The object array as a JSON string.
        */
        static serializeObjectArray<T>(objects: T[], serializer: fm.liveswitch.IFunction1<T, string>): string;
        /**
        Serializes a [[fm.liveswitch.serializable]] object into a JSON string.
        @param source The object being serialized.
        @param callback The method used for serializing properties.
        @return The object as a JSON string.
        */
        static serializeObjectFast<T extends fm.liveswitch.Serializable>(source: T, callback: fm.liveswitch.IAction2<T, fm.liveswitch.Hash<string, string>>): string;
        /**
        Serializes a piece of raw JSON.
        @param dataJson The raw data.
        @return The serialized data.
        */
        static serializeRaw(dataJson: string): string;
        /**
        Serializes a raw array to JSON.
        @param jsons An array of raw values.
        @return A JSON-serialized raw array.
        */
        static serializeRawArray(jsons: string[]): string;
        /**
        Serializes a string.
        @param value The string to serialize.
        @return The serialized string value.
        */
        static serializeString(value: string): string;
        /**
        Serializes a string array to JSON.
        @param array An array of string values.
        @return A JSON-serialized string array.
        */
        static serializeStringArray(array: string[]): string;
        /**
        Trims the quotes from a JavaScript string value.
        @param value The JavaScript string value.
        @return The string without quotes.
        */
        static trimQuotes(value: string): string;
        /**
        Unescapes any special characters from a string.
        @param text The string with escaped characters.
        @return The unescaped string.
        */
        static unescapeString(text: string): string;
        /** @hidden */
        private static unicodeStringToChar;
    }
}
declare namespace fm.liveswitch {
    /**
    Provides methods for serializing/deserializing .NET value types to/from JSON as well as facilities for converting objects and arrays if appropriate callbacks are supplied to assist with the conversion.
    */
    class Serializer extends fm.liveswitch.JsonSerializer {
        getTypeString(): string;
        constructor();
    }
}
declare namespace fm.liveswitch {
    /**
    A simple state machine.
    */
    abstract class StateMachine<T> {
        getTypeString(): string;
        /** @hidden */
        private __pendingPromises;
        /** @hidden */
        private __states;
        /** @hidden */
        private __stateValue;
        /** @hidden */
        private __transitionReachabilityMatrix;
        /** @hidden */
        private __transitions;
        /** @hidden */
        private __transitionsLock;
        /** @hidden */
        private _lastStateTicks;
        /** @hidden */
        private _systemTimestamp;
        private fmliveswitchStateMachineInit;
        /**
        Initializes a new instance of the [[fm.liveswitch.stateMachine]] class.
        @param initialState The initial state.
        */
        constructor(initialState: T);
        /** @hidden */
        private addPendingPromise;
        /**
        Adds an allowed transition.
        @param fromState The "from" state.
        @param toState The "to" state.
        */
        addTransition(fromState: T, toState: T): void;
        /**
        Determines whether a transition to the specified state is allowed.
        @param toState The "to" state.
        @return `true` if a transition to the specified state is allowed; otherwise, `false`.
            
        */
        canTransition(toState: T): boolean;
        /** @hidden */
        private checkReachable;
        /** @hidden */
        private computeTransitionMatrix;
        /** @hidden */
        private exploreStates;
        /**
        Gets the length of time spent in the last state, in milliseconds.
        */
        getLastStateMillis(): number;
        /**
        Gets the length of time spent in the last state, in ticks.
        */
        getLastStateTicks(): number;
        /**
        Gets a promise, which may be resolved or rejected depending on the current state of this machine.
        @param state State, in which promise must be resolved.
        @param returnValue Return type of this promise.
        @return Promise, which may be resolved or rejected depending on the current state of this machine
        */
        getPromise<R extends Object>(state: T, returnValue: R): fm.liveswitch.Promise<R>;
        /**
        Gets the state.
        */
        getState(): T;
        /**
        Gets the state value.
        */
        protected getStateValue(): number;
        /**
        Gets the system timestamp of the last state transition.
        */
        getSystemTimestamp(): number;
        /**
        Determines whether a transition to a specified state is possible (even via intermediate hops).
        @param state The "to" state.
        @return `true` if a transition to the specified state is possible; otherwise, `false`.
            
        */
        isReachable(state: T): boolean;
        /** @hidden */
        private setLastStateTicks;
        /** @hidden */
        private setStateValue;
        /** @hidden */
        private setSystemTimestamp;
        /**
        Converts a state to an integer value.
        @param state The state.
        */
        protected abstract stateToValue(state: T): number;
        /**
        Transitions to the specified state.
        @param toState The "to" state.
        @return `true` if a transition to the specified state is allowed; otherwise, `false`.
            
        */
        transition(toState: T): boolean;
        /** @hidden */
        private validatePendingPromises;
        /**
        Converts an integer value to a state.
        @param value The integer value.
        */
        protected abstract valueToState(value: number): T;
    }
}
declare namespace fm.liveswitch {
    /** @hidden */
    class StringTypeWrapper {
        getTypeString(): string;
        /** @hidden */
        private _value;
        constructor(value: fm.liveswitch.StringType);
        toString(): string;
    }
}
declare namespace fm.liveswitch {
    /**
    A linked list node.
    */
    class LinkedListNode<T> {
        getTypeString(): string;
        /** @hidden */
        private _next;
        /** @hidden */
        private _previous;
        /** @hidden */
        private _value;
        /**
        Initializes a new instance of the [[fm.liveswitch.linkedListNode]] class.
        @param item The item.
        */
        constructor(item: T);
        /**
        Gets the next node. Will be `null` if last.
        */
        getNext(): fm.liveswitch.LinkedListNode<T>;
        /**
        Gets the previous node. Null if first.
        */
        getPrevious(): fm.liveswitch.LinkedListNode<T>;
        /**
        Gets the item in the linked list.
        */
        getValue(): T;
        /** @hidden */
        setNext(value: fm.liveswitch.LinkedListNode<T>): void;
        /** @hidden */
        setPrevious(value: fm.liveswitch.LinkedListNode<T>): void;
        /** @hidden */
        private setValue;
    }
}
declare namespace fm.liveswitch {
    /**
    A linked list enumerator.
    */
    class LinkedListEnumerator<T> {
        getTypeString(): string;
        /** @hidden */
        private __currentNode;
        /** @hidden */
        private __root;
        /** @hidden */
        private __started;
        private fmliveswitchLinkedListEnumeratorInit;
        /**
        Initializes a new instance of the [[fm.liveswitch.linkedListEnumerator]] class.
        @param root The root node.
        */
        constructor(root: fm.liveswitch.LinkedListNode<T>);
        /**
        Gets the current value.
        */
        getCurrent(): T;
        /**
        Gets the current node.
        */
        getCurrentNode(): fm.liveswitch.LinkedListNode<T>;
        /**
        Moves to the next node.
        */
        moveNext(): boolean;
        /**
        Resets this instance.
        */
        reset(): void;
    }
}
declare namespace fm.liveswitch {
    /** @hidden */
    class InternalConcurrentQueue<T> {
        getTypeString(): string;
        /** @hidden */
        private _backingData;
        constructor();
        enqueue(item: T): void;
        getCount(): number;
        getIsEmpty(): boolean;
        tryDequeue(item: fm.liveswitch.Holder<T>): boolean;
        tryPeek(item: fm.liveswitch.Holder<T>): boolean;
    }
}
declare namespace fm.liveswitch {
    /** @hidden */
    class InternalConcurrentStack<T> {
        getTypeString(): string;
        /** @hidden */
        private _backingData;
        constructor();
        clear(): void;
        getCount(): number;
        getIsEmpty(): boolean;
        push(item: T): void;
        tryPeek(result: fm.liveswitch.Holder<T>): boolean;
        tryPop(result: fm.liveswitch.Holder<T>): boolean;
    }
}
declare namespace fm.liveswitch {
    /**
    A ConcurrentDictonary that maps to the appropriate platform version.
    */
    class ManagedConcurrentDictionary<TKey, TValue> {
        getTypeString(): string;
        /** @hidden */
        private __dictionary;
        /**
        Creates a new instance.
        */
        constructor();
        /**
        Creates a new ManagedConcurrentDictionary.
        @param hashCallback The hash function to use when the backing dictionary requires the key to be a string.
        */
        constructor(hashCallback: fm.liveswitch.IFunction1<TKey, string>);
        /**
        Updates a value in the dictionary or adds it if it does not exist.
        @param key The key to use for updating for adding.
        @param addValue The value to be added for an absent key.
        */
        addOrUpdate(key: TKey, addValue: TValue): TValue;
        /**
        Updates a value in the dictionary or adds it if it does not exist.
        @param key The key to use for updating for adding.
        @param addValue The value to be added for an absent key.
        @param updateValueFactory The function to use for generating a value based on an existing key.
        */
        addOrUpdate(key: TKey, addValue: TValue, updateValueFactory: fm.liveswitch.IFunction2<TKey, TValue, TValue>): TValue;
        /**
        Clears the dictionary of all items.
        */
        clear(): void;
        /**
        True if the dictionary contains the key.
        @param key The key to check.
        */
        containsKey(key: TKey): boolean;
        /**
        Gets the number of items in the dictionary.
        */
        getCount(): number;
        /**
        Gets true if dictionary is empty.
        */
        getIsEmpty(): boolean;
        /**
        Gets an array of keys.
        */
        getKeys(): Array<TKey>;
        /**
        Gets the value from the dictionary or adds a new one if it does not exist.
        @param key The key to use when adding to the dictionary.
        @param valueFactory The Func that will create a value if needed.
        @return The dictionary value if exist, the value returned by the Func if not.
        */
        getOrAdd(key: TKey, valueFactory: fm.liveswitch.IFunction1<TKey, TValue>): TValue;
        /**
        Gets an array of Values.
        */
        getValues(): Array<TValue>;
        /** @hidden */
        private hash;
        /**
        Tries to add a new value to the dictionary.
        @param key The key to use when adding.
        @param value The value to be added to the dictionary.
        @return True if added, false if key already exists.
        */
        tryAdd(key: TKey, value: TValue): boolean;
        /**
        Tries to get a value from the dictionary.
        @param key They key of the item to get form the dictionary.
        @param value The value that was just received or null if failed.
        @return True if succeeded.
        */
        tryGetValue(key: TKey, value: fm.liveswitch.Holder<TValue>): boolean;
        /**
        Tries and removes a value from the dictionary.
        @param key The key of the item to remove.
        @return True if successful.
        */
        tryRemove(key: TKey): boolean;
        /**
        Tries and removes a value from the dictionary.
        @param key The key of the item to remove.
        @param value The value that was just removed.
        @return True if successful.
        */
        tryRemove(key: TKey, value: fm.liveswitch.Holder<TValue>): boolean;
        /**
        Tries to update the value in the dictionary.
        @param key The key to use when updating.
        @param newValue The new value.
        @param comparisonValue The value to compare with the current value in the dictionary.
        @return True if succeeded.
        */
        tryUpdate(key: TKey, newValue: TValue, comparisonValue: TValue): boolean;
    }
}
declare namespace fm.liveswitch {
    /**
    A thread-safe queue.
    */
    class ManagedConcurrentQueue<T> {
        getTypeString(): string;
        /** @hidden */
        private __queue;
        /**
        Creates a new ConcurrentQueue.
        */
        constructor();
        /**
        Add the item to the end of the queue.
        @param item The item to add.
        */
        enqueue(item: T): void;
        /**
        Gets the amount of items in this queue.
        */
        getCount(): number;
        /**
        Gets true if the queue is empty.
        */
        getIsEmpty(): boolean;
        /**
        Removes and returns the item at the front of the queue.
        @param item The dequeued item.
        @return True if item received, false if no item.
        */
        tryDequeue(item: fm.liveswitch.Holder<T>): boolean;
        /**
        Peeks at the first item in the queue.
        @param item The item at the front of the queue.
        @return False if queue is empty. True if first item peeked at.
        */
        tryPeek(item: fm.liveswitch.Holder<T>): boolean;
    }
}
declare namespace fm.liveswitch {
    /**
    A ConcurrentStack that maps to the appropriate platform version.
    */
    class ManagedConcurrentStack<TValue> {
        getTypeString(): string;
        /** @hidden */
        private __stack;
        /**
        Creates a new instance of a ConcurrentStack.
        */
        constructor();
        /**
        Clears the stack of all items.
        */
        clear(): void;
        /**
        Gets the amount of items in the stack.
        */
        getCount(): number;
        /**
        Gets true if the stack is empty.
        */
        getIsEmpty(): boolean;
        /**
        Pushes a new item on top of the stack.
        @param item The item to push.
        */
        push(item: TValue): void;
        /**
        Tries to peek at the top value in stack.
        @param result The value from the stack if possible, null otherwise.
        @return True if peek succeeded, false if not.
        */
        tryPeek(result: fm.liveswitch.Holder<TValue>): boolean;
        /**
        Tries to pop the top value off of the stack.
        @param result The value from the top of the stack if possible, null otherwise.
        @return True if pop suceeded, false if not.
        */
        tryPop(result: fm.liveswitch.Holder<TValue>): boolean;
    }
}
declare namespace fm.liveswitch {
    /**
    A mutable 2-tuple.
    */
    class MutablePair<T1, T2> {
        getTypeString(): string;
        /** @hidden */
        private _item1;
        /** @hidden */
        private _item2;
        /**
        Initializes a new instance of the [[fm.liveswitch.mutablePair]] class.
        @param item1 First item the tuple holds.
        @param item2 Second item the tuple holds.
        */
        constructor(item1: T1, item2: T2);
        /**
        Gets the first item in the tuple.
        */
        getItem1(): T1;
        /**
        Gets the second item in the tuple.
        */
        getItem2(): T2;
        /**
        Sets the first item in the tuple.
        */
        setItem1(value: T1): void;
        /**
        Sets the second item in the tuple.
        */
        setItem2(value: T2): void;
    }
}
declare namespace fm.liveswitch {
    /**
    A mutable 1-tuple.
    */
    class MutableUnit<T> {
        getTypeString(): string;
        /** @hidden */
        private _item;
        /**
        Initializes a new instance of the [[fm.liveswitch.mutableUnit]] class.
        @param item The item to hold.
        */
        constructor(item: T);
        /**
        Gets the first item in the tuple.
        */
        getItem(): T;
        /**
        Sets the first item in the tuple.
        */
        setItem(value: T): void;
    }
}
declare namespace fm.liveswitch {
    /**
    A 2-tuple.
    */
    class Pair<T1, T2> {
        getTypeString(): string;
        /** @hidden */
        private _item1;
        /** @hidden */
        private _item2;
        /**
        Initializes a new instance of the [[fm.liveswitch.pair]] class.
        @param item1 First item the tuple holds.
        @param item2 Second item the tuple holds.
        */
        constructor(item1: T1, item2: T2);
        /**
        Calculates the hashcode for this pair.
        */
        getHashCode(): number;
        /**
        Gets the first item in the tuple.
        */
        getItem1(): T1;
        /**
        Gets the second item in the tuple.
        */
        getItem2(): T2;
        /** @hidden */
        private setItem1;
        /** @hidden */
        private setItem2;
    }
}
declare namespace fm.liveswitch {
    /**
    Simple log provider that writes log events to a local array.
    */
    class LogEventLogProvider extends fm.liveswitch.LogProvider {
        getTypeString(): string;
        /** @hidden */
        private __events;
        /** @hidden */
        private __eventsLock;
        /**
        Initializes a new instance of the [[fm.liveswitch.logEventLogProvider]] class using [[fm.liveswitch.logLevel.Info]].
        */
        constructor();
        /**
        Initializes a new instance of the [[fm.liveswitch.logEventLogProvider]] class.
        @param level The log level.
        */
        constructor(level: fm.liveswitch.LogLevel);
        /**
        Clears all text from the log and returns the former contents.
        */
        clear(): fm.liveswitch.LogEvent[];
        /**
        Logs a message at the specified log level.
        @param logEvent The log event details.
        */
        protected doLog(logEvent: fm.liveswitch.LogEvent): void;
        /**
        Gets the logged events.
        */
        getEvents(): fm.liveswitch.LogEvent[];
    }
}
declare namespace fm.liveswitch {
    /**
    A 3-tuple.
    */
    class Triple<T1, T2, T3> {
        getTypeString(): string;
        /** @hidden */
        private _item1;
        /** @hidden */
        private _item2;
        /** @hidden */
        private _item3;
        /**
        Initializes a new instance of the [[fm.liveswitch.triple]] class.
        @param item1 First item the tuple holds.
        @param item2 Second item the tuple holds.
        @param item3 Third item the tuple holds.
        */
        constructor(item1: T1, item2: T2, item3: T3);
        /**
        Gets the first item in the tuple.
        */
        getItem1(): T1;
        /**
        Gets the second item in the tuple.
        */
        getItem2(): T2;
        /**
        Gets the third item in the tuple.
        */
        getItem3(): T3;
        /** @hidden */
        private setItem1;
        /** @hidden */
        private setItem2;
        /** @hidden */
        private setItem3;
    }
}
declare namespace fm.liveswitch {
    /**
    A 1-tuple.
    */
    class Unit<T> {
        getTypeString(): string;
        /** @hidden */
        private _item;
        /**
        Initializes a new instance of the [[fm.liveswitch.unit]] class.
        @param item The item to hold.
        */
        constructor(item: T);
        /**
        Gets the item in the tuple.
        */
        getItem(): T;
        /** @hidden */
        private setItem;
    }
}
declare namespace fm.liveswitch {
    class CompareResultWrapper {
        getTypeString(): string;
        /** @hidden */
        private _value;
        constructor(value: fm.liveswitch.CompareResult);
        toString(): string;
    }
}
declare namespace fm.liveswitch {
    /**
    A collection of platform-independent constant values.
    */
    class Constants {
        getTypeString(): string;
        /** @hidden */
        private static fm_liveswitch_Constants___hoursPerDay;
        /** @hidden */
        private static fm_liveswitch_Constants___millisecondsPerDay;
        /** @hidden */
        private static fm_liveswitch_Constants___millisecondsPerHour;
        /** @hidden */
        private static fm_liveswitch_Constants___millisecondsPerMinute;
        /** @hidden */
        private static fm_liveswitch_Constants___millisecondsPerSecond;
        /** @hidden */
        private static fm_liveswitch_Constants___minutesPerDay;
        /** @hidden */
        private static fm_liveswitch_Constants___minutesPerHour;
        /** @hidden */
        private static fm_liveswitch_Constants___nanosecondsPerTick;
        /** @hidden */
        private static fm_liveswitch_Constants___secondsPerDay;
        /** @hidden */
        private static fm_liveswitch_Constants___secondsPerHour;
        /** @hidden */
        private static fm_liveswitch_Constants___secondsPerMinute;
        /** @hidden */
        private static fm_liveswitch_Constants___ticksPerDay;
        /** @hidden */
        private static fm_liveswitch_Constants___ticksPerHour;
        /** @hidden */
        private static fm_liveswitch_Constants___ticksPerMillisecond;
        /** @hidden */
        private static fm_liveswitch_Constants___ticksPerMinute;
        /** @hidden */
        private static fm_liveswitch_Constants___ticksPerSecond;
        constructor();
        /**
        Gets the number of hours in one day.
        */
        static getHoursPerDay(): number;
        /**
        Gets the number of milliseconds in one hour.
        */
        static getMillisecondsPerDay(): number;
        /**
        Gets the number of milliseconds in one hour.
        */
        static getMillisecondsPerHour(): number;
        /**
        Gets the number of milliseconds in one minute.
        */
        static getMillisecondsPerMinute(): number;
        /**
        Gets the number of milliseconds in one second.
        */
        static getMillisecondsPerSecond(): number;
        /**
        Gets the number of minutes in one day.
        */
        static getMinutesPerDay(): number;
        /**
        Gets the number of minutes in one hour.
        */
        static getMinutesPerHour(): number;
        /**
        Gets the number of nanoseconds in one tick.
        */
        static getNanosecondsPerTick(): number;
        /**
        Gets the number of seconds in one day.
        */
        static getSecondsPerDay(): number;
        /**
        Gets the number of seconds in one hour.
        */
        static getSecondsPerHour(): number;
        /**
        Gets the number of seconds in one minute.
        */
        static getSecondsPerMinute(): number;
        /**
        Gets the number of ticks in one day.
        */
        static getTicksPerDay(): number;
        /**
        Gets the number of ticks in one hour.
        */
        static getTicksPerHour(): number;
        /**
        Gets the number of ticks in one millisecond.
        */
        static getTicksPerMillisecond(): number;
        /**
        Gets the number of ticks in one minute.
        */
        static getTicksPerMinute(): number;
        /**
        Gets the number of ticks in one second.
        */
        static getTicksPerSecond(): number;
        /** @hidden */
        private static __fmliveswitchConstantsInitialized;
        /** @hidden */
        private static __fmliveswitchConstantsInitializing;
        /** @hidden */
        static fmliveswitchConstantsInitialize(): void;
    }
}
declare namespace fm.liveswitch {
    /**
    A data buffer stream.
    */
    class DataBufferStream {
        getTypeString(): string;
        /** @hidden */
        private __bitPosition;
        /** @hidden */
        private __buffer;
        /** @hidden */
        private __position;
        private fmliveswitchDataBufferStreamInit;
        /**
        Initializes a new instance of the [[fm.liveswitch.dataBufferStream]] class.
        @param buffer The buffer.
        */
        constructor(buffer: fm.liveswitch.DataBuffer);
        /**
        Initializes a new instance of the [[fm.liveswitch.dataBufferStream]] class.
        @param dataBufferSize Size of the data buffer.
        */
        constructor(dataBufferSize: number);
        /**
        Initializes a new instance of the [[fm.liveswitch.dataBufferStream]] class.
        @param dataBufferSize Size of the data buffer.
        @param littleEndian Whether the data is little-endian.
        */
        constructor(dataBufferSize: number, littleEndian: boolean);
        /**
        Gets the available bytes to be read from the DataBuffer.
        */
        getAvailable(): number;
        /**
        Gets the bit position within a byte.
        */
        getBitPosition(): number;
        /**
        Gets the buffer.
        */
        getBuffer(): fm.liveswitch.DataBuffer;
        /**
        Gets the buffer length.
        */
        getLength(): number;
        /**
        Gets the position within the stream.
        */
        getPosition(): number;
        /**
        Resets the bit count to 0 and advances to the next byte.
        */
        nextByte(): void;
        /**
        Reads an 8-bit value from the DataBuffer without advancing the Position.
        */
        peek(): number;
        /**
        Reads the specified length from the DataBuffer and advances the position by the length.
        @param length The length.
        */
        read(length: number): fm.liveswitch.DataBuffer;
        /**
        Read a single bit and advance the bit position by 1.
        */
        read1(): boolean;
        /**
        Reads an 15-bit value from the DataBuffer and advances the Position by 1 and the BitPosition by 7.
        */
        read15(): number;
        /**
        Reads an 16-bit value from the DataBuffer and advances the Position by 2.
        */
        read16(): number;
        /**
        Read a 2-bit value and advance the BitPosition by 2.
        */
        read2(): number;
        /**
        Reads an 24-bit value from the DataBuffer and advances the Position by 3.
        */
        read24(): number;
        /**
        Read a 3-bit value and advance the BitPosition by 3.
        */
        read3(): number;
        /**
        Reads an 32-bit value from the DataBuffer and advances the Position by 4.
        */
        read32(): number;
        /**
        Read a 4-bit value and advance the BitPosition by 4.
        */
        read4(): number;
        /**
        Reads an 40-bit value from the DataBuffer and advances the Position by 5.
        */
        read40(): number;
        /**
        Reads an 48-bit value from the DataBuffer and advances the Position by 6.
        */
        read48(): number;
        /**
        Reads an 56-bit value from the DataBuffer and advances the Position by 7.
        */
        read56(): number;
        /**
        Reads an 64-bit value from the DataBuffer and advances the Position by 8.
        */
        read64(): number;
        /**
        Reads an 7-bit value from the DataBuffer and advances the BitPosition by 7.
        */
        read7(): number;
        /**
        Reads an 8-bit value from the DataBuffer and advances the Position by 1.
        */
        read8(): number;
        /**
        Reads a single byte from the stream and advances the Position by 1.
        */
        readByte(): number;
        /**
        Read a specified number of bytes from the DataBuffer and advance the Position by that number.
        @param length The number of bytes to read.
        */
        readBytes(length: number): Uint8Array;
        /**
        Sets the bit position within a byte.
        */
        setBitPosition(value: number): void;
        /**
        Sets the position within the stream.
        */
        setPosition(value: number): void;
        /**
        Writes the specified buffer to the DataBuffer and advances the Position by the length of the buffer.
        @param buffer The buffer.
        */
        write(buffer: fm.liveswitch.DataBuffer): fm.liveswitch.DataBufferStream;
        /**
        Writes an 16-bit value to the DataBuffer and advances the Position by 2.
        @param value The value.
        */
        write16(value: number): fm.liveswitch.DataBufferStream;
        /**
        Writes an 32-bit value to the DataBuffer and advances the Position by 4.
        @param value The value.
        */
        write32(value: number): fm.liveswitch.DataBufferStream;
        /**
        Writes an 64-bit value to the DataBuffer and advances the Position by 8.
        @param value The value.
        */
        write64(value: number): fm.liveswitch.DataBufferStream;
        /**
        Writes an 8-bit value to the DataBuffer and advances the Position by 1.
        @param value The value.
        */
        write8(value: number): fm.liveswitch.DataBufferStream;
        /**
        Writes the specified data to the DataBuffer and advances the Position by the length of the data.
        @param data The data.
        */
        writeBytes(data: Uint8Array): fm.liveswitch.DataBufferStream;
        /**
        Writes the specified data to the DataBuffer and advances the Position by the length.
        @param data The data.
        @param index The index.
        @param length The length.
        */
        writeBytes(data: Uint8Array, index: number, length: number): fm.liveswitch.DataBufferStream;
    }
}
declare namespace fm.liveswitch {
    /**
    Binary data buffer implementation
    */
    class DataBuffer {
        getTypeString(): string;
        /** @hidden */
        private _index;
        /** @hidden */
        private _innerData;
        /** @hidden */
        private _length;
        /** @hidden */
        private _littleEndian;
        /** @hidden */
        private static fm_liveswitch_DataBuffer___dataBufferPool;
        private fmliveswitchDataBufferInit;
        constructor();
        constructor(data: Uint8Array, index: number, length: number, littleEndian: boolean);
        /**
        Allocates a new data buffer with a given size (in bytes) in big-endian format.
        @param count Pre-allocated data buffer size  (in bytes).
        */
        static allocate(count: number): fm.liveswitch.DataBuffer;
        /**
        Allocates a new data buffer with a given size (in bytes).
        @param count Pre-allocated data buffer size  (in bytes).
        @param littleEndian Whether the data is little-endian.
        */
        static allocate(count: number, littleEndian: boolean): fm.liveswitch.DataBuffer;
        /**
        Tests if the two buffers have equal contents.
        @param buffer1 First buffer to test.
        @param buffer2 Second buffer to test.
        */
        static areEqual(buffer1: fm.liveswitch.DataBuffer, buffer2: fm.liveswitch.DataBuffer): boolean;
        /**
        Creates an instance from an array of bytes.
        */
        static fromBytes(bytes: Uint8Array): fm.liveswitch.DataBuffer;
        /**
        Creates an instance from an array of bytes.
        */
        static fromBytes(bytes: Uint8Array, littleEndian: boolean): fm.liveswitch.DataBuffer;
        /**
        Creates an instance from a hexadecimal string.
        */
        static fromHexString(hexString: string): fm.liveswitch.DataBuffer;
        /**
        Creates an instance from a hexadecimal string.
        */
        static fromHexString(hexString: string, littleEndian: boolean): fm.liveswitch.DataBuffer;
        /**
        Deserializes an instance from JSON.
        @param dataBufferJson The data buffer JSON.
        */
        static fromJson(dataBufferJson: string): fm.liveswitch.DataBuffer;
        /**
        Deserializes an array of instances from JSON.
        @param dataBuffersJson The data buffers JSON.
        */
        static fromJsonArray(dataBuffersJson: string): fm.liveswitch.DataBuffer[];
        /**
        Gets an empty data buffer.
        */
        static getEmpty(): fm.liveswitch.DataBuffer;
        /**
        Serializes an instance to JSON.
        @param dataBuffer The data buffer.
        */
        static toJson(dataBuffer: fm.liveswitch.DataBuffer): string;
        /**
        Serializes an array of instances to JSON.
        @param dataBuffers The data buffers.
        */
        static toJsonArray(dataBuffers: fm.liveswitch.DataBuffer[]): string;
        /**
        Produces a new data buffer containing supplied data in big-endian format.
        @param data The data.
        */
        static wrap(data: Uint8Array): fm.liveswitch.DataBuffer;
        /**
        Produces a new data buffer containing supplied data in big-endian format.
        @param data The data.
        @param index The index.
        */
        static wrap(data: Uint8Array, index: number): fm.liveswitch.DataBuffer;
        /**
        Produces a new data buffer containing supplied data in big-endian format.
        @param data The data.
        @param index The index.
        @param length The length.
        */
        static wrap(data: Uint8Array, index: number, length: number): fm.liveswitch.DataBuffer;
        /**
        Produces a new data buffer containing supplied data.
        @param data The data.
        @param index The index.
        @param length The length.
        @param littleEndian Whether the data is little-endian.
        */
        static wrap(data: Uint8Array, index: number, length: number, littleEndian: boolean): fm.liveswitch.DataBuffer;
        /**
        Produces a new data buffer containing supplied data.
        @param data The data.
        @param index The index.
        @param littleEndian Whether the data is little-endian.
        */
        static wrap(data: Uint8Array, index: number, littleEndian: boolean): fm.liveswitch.DataBuffer;
        /**
        Produces a new data buffer containing supplied data.
        @param data The data.
        @param littleEndian Whether the data is little-endian.
        */
        static wrap(data: Uint8Array, littleEndian: boolean): fm.liveswitch.DataBuffer;
        /**
        Performs a bitwise "and" operation on a value.
        @param value The value.
        @param offset The offset.
        */
        and(value: number, offset: number): boolean;
        /**
        Appends a buffer.
        @param buffer The buffer.
        */
        append(buffer: fm.liveswitch.DataBuffer): fm.liveswitch.DataBuffer;
        /**
        Appends some buffers.
        @param buffers The buffers.
        */
        append(buffers: fm.liveswitch.DataBuffer[]): fm.liveswitch.DataBuffer;
        /**
        Gets whether this buffer can be resized to the new length.
        @param newLength The new length.
        @param offset The offset.
        */
        canResize(newLength: number, offset: number): boolean;
        /**
        Clones this instance.
        */
        clone(): fm.liveswitch.DataBuffer;
        /**
        Clones this instance.
        @param littleEndian Whether to clone into a little endian buffer.
        */
        clone(littleEndian: boolean): fm.liveswitch.DataBuffer;
        /**
        Copies this instance into new memory.
        */
        copy(): fm.liveswitch.DataBuffer;
        /**
        Copies this instance.
        */
        copy(usePool: boolean): fm.liveswitch.DataBuffer;
        /**
        Decrements the retain count by one and returns the Buffer to the pool if zero.
        */
        free(): fm.liveswitch.DataBuffer;
        /**
        Gets the data.
        */
        getData(): Uint8Array;
        /**
        Gets the index.
        */
        getIndex(): number;
        /**
        Gets backing data buffer.
        */
        protected getInnerData(): Uint8Array;
        /**
        Gets whether this DataBuffer is from a pool.
        */
        getIsPooled(): boolean;
        /**
        Gets whether this DataBuffer is a subset.
        */
        getIsSubset(): boolean;
        /**
        Gets the length.
        */
        getLength(): number;
        /**
        Gets whether [[fm.liveswitch.dataBuffer.data]] is little-endian.
        */
        getLittleEndian(): boolean;
        /**
        Increment the retain count by one.
        */
        keep(): fm.liveswitch.DataBuffer;
        /**
        Performs a bitwise "or" operation on a value.
        @param value The value.
        @param offset The offset.
        */
        or(value: number, offset: number): boolean;
        /**
        Prepends a buffer.
        @param buffer The buffer.
        */
        prepend(buffer: fm.liveswitch.DataBuffer): fm.liveswitch.DataBuffer;
        /**
        Prepends some buffers.
        @param buffers The buffers.
        */
        prepend(buffers: fm.liveswitch.DataBuffer[]): void;
        /**
        Reads a 1-bit value.
        @param offset The offset.
        @param bitOffset The bit offset.
        */
        read1(offset: number, bitOffset: number): boolean;
        /**
        Reads a 10-bit value.
        @param offset The offset.
        @param bitOffset The bitoffset.
        */
        read10(offset: number, bitOffset: number): number;
        /**
        Reads a 10-bit signed value.
        @param offset The offset.
        @param bitOffset The bit offset.
        */
        read10Signed(offset: number, bitOffset: number): number;
        /**
        Reads a 11-bit value.
        @param offset The offset.
        @param bitOffset The bitoffset.
        */
        read11(offset: number, bitOffset: number): number;
        /**
        Reads a 11-bit signed value.
        @param offset The offset.
        @param bitOffset The bit offset.
        */
        read11Signed(offset: number, bitOffset: number): number;
        /**
        Reads a 12-bit value.
        @param offset The offset.
        @param bitOffset The bitoffset.
        */
        read12(offset: number, bitOffset: number): number;
        /**
        Reads a 12-bit signed value.
        @param offset The offset.
        @param bitOffset The bit offset.
        */
        read12Signed(offset: number, bitOffset: number): number;
        /**
        Reads a 13-bit value.
        @param offset The offset.
        @param bitOffset The bitoffset.
        */
        read13(offset: number, bitOffset: number): number;
        /**
        Reads a 13-bit signed value.
        @param offset The offset.
        @param bitOffset The bit offset.
        */
        read13Signed(offset: number, bitOffset: number): number;
        /**
        Reads a 14-bit value.
        @param offset The offset.
        @param bitOffset The bit offset.
        */
        read14(offset: number, bitOffset: number): number;
        /**
        Reads a 14-bit signed value.
        @param offset The offset.
        @param bitOffset The bit offset.
        */
        read14Signed(offset: number, bitOffset: number): number;
        /**
        Reads a 15-bit value.
        @param offset The offset.
        @param bitOffset The bit offset.
        */
        read15(offset: number, bitOffset: number): number;
        /**
        Reads a 15-bit signed value.
        @param offset The offset.
        @param bitOffset The bit offset.
        */
        read15Signed(offset: number, bitOffset: number): number;
        /**
        Reads a 16-bit value.
        @param offset The offset.
        */
        read16(offset: number): number;
        /**
        Reads a 16-bit value.
        @param offset The offset.
        @param offsetPlus The offset plus the value length.
        */
        read16(offset: number, offsetPlus: fm.liveswitch.Holder<number>): number;
        /**
        Reads a 16-bit signed value.
        @param offset The offset.
        */
        read16Signed(offset: number): number;
        /**
        Reads a 16-bit signed value.
        @param offset The offset.
        @param offsetPlus The offset plus the value length.
        */
        read16Signed(offset: number, offsetPlus: fm.liveswitch.Holder<number>): number;
        /**
        Reads a 17-bit value.
        @param offset The offset.
        @param bitOffset The bit offset.
        */
        read17(offset: number, bitOffset: number): number;
        /**
        Reads a 17-bit signed value.
        @param offset The offset.
        @param bitOffset The bit offset.
        */
        read17Signed(offset: number, bitOffset: number): number;
        /**
        Reads an 18-bit value.
        @param offset The offset.
        @param bitOffset The bit offset.
        */
        read18(offset: number, bitOffset: number): number;
        /**
        Reads an 18-bit signed value.
        @param offset The offset.
        @param bitOffset The bit offset.
        */
        read18Signed(offset: number, bitOffset: number): number;
        /**
        Reads a 19-bit value.
        @param offset The offset.
        @param bitOffset The bit offset.
        */
        read19(offset: number, bitOffset: number): number;
        /**
        Reads a 19-bit signed value.
        @param offset The offset.
        @param bitOffset The bit offset.
        */
        read19Signed(offset: number, bitOffset: number): number;
        /**
        Reads a 2-bit value.
        @param offset The offset.
        @param bitOffset The bit offset.
        */
        read2(offset: number, bitOffset: number): number;
        /**
        Reads a 20-bit value.
        @param offset The offset.
        @param bitOffset The bit offset.
        */
        read20(offset: number, bitOffset: number): number;
        /**
        Reads a 20-bit signed value.
        @param offset The offset.
        @param bitOffset The bit offset.
        */
        read20Signed(offset: number, bitOffset: number): number;
        /**
        Reads a 21-bit value.
        @param offset The offset.
        @param bitOffset The bit offset.
        */
        read21(offset: number, bitOffset: number): number;
        /**
        Reads a 21-bit signed value.
        @param offset The offset.
        @param bitOffset The bit offset.
        */
        read21Signed(offset: number, bitOffset: number): number;
        /**
        Reads a 22-bit value.
        @param offset The offset.
        @param bitOffset The bit offset.
        */
        read22(offset: number, bitOffset: number): number;
        /**
        Reads a 22-bit signed value.
        @param offset The offset.
        @param bitOffset The bit offset.
        */
        read22Signed(offset: number, bitOffset: number): number;
        /**
        Reads a 23-bit value.
        @param offset The offset.
        @param bitOffset The bit offset.
        */
        read23(offset: number, bitOffset: number): number;
        /**
        Reads a 23-bit signed value.
        @param offset The offset.
        @param bitOffset The bit offset.
        */
        read23Signed(offset: number, bitOffset: number): number;
        /**
        Reads a 24-bit value.
        @param offset The offset.
        */
        read24(offset: number): number;
        /**
        Reads a 24-bit value.
        @param offset The offset.
        @param offsetPlus The offset plus the value length.
        */
        read24(offset: number, offsetPlus: fm.liveswitch.Holder<number>): number;
        /**
        Reads a 24-bit signed value.
        @param offset The offset.
        */
        read24Signed(offset: number): number;
        /**
        Reads a 24-bit signed value.
        @param offset The offset.
        @param offsetPlus The offset plus the value length.
        */
        read24Signed(offset: number, offsetPlus: fm.liveswitch.Holder<number>): number;
        /**
        Reads a 2-bit signed value.
        @param offset The offset.
        @param bitOffset The bit offset.
        */
        read2Signed(offset: number, bitOffset: number): number;
        /**
        Reads a 3-bit value.
        @param offset The offset.
        @param bitOffset The bit offset.
        */
        read3(offset: number, bitOffset: number): number;
        /**
        Reads a 32-bit value.
        @param offset The offset.
        */
        read32(offset: number): number;
        /**
        Reads a 32-bit value.
        @param offset The offset.
        @param offsetPlus The offset plus the value length.
        */
        read32(offset: number, offsetPlus: fm.liveswitch.Holder<number>): number;
        /**
        Reads a 32-bit signed value.
        @param offset The offset.
        */
        read32Signed(offset: number): number;
        /**
        Reads a 32-bit signed value.
        @param offset The offset.
        @param offsetPlus The offset plus the value length.
        */
        read32Signed(offset: number, offsetPlus: fm.liveswitch.Holder<number>): number;
        /**
        Reads a 3-bit signed value.
        @param offset The offset.
        @param bitOffset The bit offset.
        */
        read3Signed(offset: number, bitOffset: number): number;
        /**
        Reads a 4-bit value.
        @param offset The offset.
        @param bitOffset The bit offset.
        */
        read4(offset: number, bitOffset: number): number;
        /**
        Reads a 40-bit value.
        @param offset The offset.
        */
        read40(offset: number): number;
        /**
        Reads a 40-bit value.
        @param offset The offset.
        @param offsetPlus The offset plus the value length.
        */
        read40(offset: number, offsetPlus: fm.liveswitch.Holder<number>): number;
        /**
        Reads a 40-bit signed value.
        @param offset The offset.
        */
        read40Signed(offset: number): number;
        /**
        Reads a 40-bit signed value.
        @param offset The offset.
        @param offsetPlus The offset plus the value length.
        */
        read40Signed(offset: number, offsetPlus: fm.liveswitch.Holder<number>): number;
        /**
        Reads a 48-bit value.
        @param offset The offset.
        */
        read48(offset: number): number;
        /**
        Reads a 48-bit value.
        @param offset The offset.
        @param offsetPlus The offset plus the value length.
        */
        read48(offset: number, offsetPlus: fm.liveswitch.Holder<number>): number;
        /**
        Reads a 48-bit signed value.
        @param offset The offset.
        */
        read48Signed(offset: number): number;
        /**
        Reads a 48-bit signed value.
        @param offset The offset.
        @param offsetPlus The offset plus the value length.
        */
        read48Signed(offset: number, offsetPlus: fm.liveswitch.Holder<number>): number;
        /**
        Reads a 4-bit signed value.
        @param offset The offset.
        @param bitOffset The bit offset.
        */
        read4Signed(offset: number, bitOffset: number): number;
        /**
        Reads a 5-bit value.
        @param offset The offset.
        @param bitOffset The bit offset.
        */
        read5(offset: number, bitOffset: number): number;
        /**
        Reads a 56-bit value.
        @param offset The offset.
        */
        read56(offset: number): number;
        /**
        Reads a 56-bit value.
        @param offset The offset.
        @param offsetPlus The offset plus the value length.
        */
        read56(offset: number, offsetPlus: fm.liveswitch.Holder<number>): number;
        /**
        Reads a 56-bit signed value.
        @param offset The offset.
        */
        read56Signed(offset: number): number;
        /**
        Reads a 56-bit signed value.
        @param offset The offset.
        @param offsetPlus The offset plus the value length.
        */
        read56Signed(offset: number, offsetPlus: fm.liveswitch.Holder<number>): number;
        /**
        Reads a 5-bit signed value.
        @param offset The offset.
        @param bitOffset The bit offset.
        */
        read5Signed(offset: number, bitOffset: number): number;
        /**
        Reads a 6-bit value.
        @param offset The offset.
        @param bitOffset The bit offset.
        */
        read6(offset: number, bitOffset: number): number;
        /**
        Reads a 64-bit value.
        @param offset The offset.
        */
        read64(offset: number): number;
        /**
        Reads a 64-bit value.
        @param offset The offset.
        @param offsetPlus The offset plus the value length.
        */
        read64(offset: number, offsetPlus: fm.liveswitch.Holder<number>): number;
        /**
        Reads a 64-bit signed value.
        @param offset The offset.
        */
        read64Signed(offset: number): number;
        /**
        Reads a 64-bit signed value.
        @param offset The offset.
        @param offsetPlus The offset plus the value length.
        */
        read64Signed(offset: number, offsetPlus: fm.liveswitch.Holder<number>): number;
        /**
        Reads a 6-bit signed value.
        @param offset The offset.
        @param bitOffset The bit offset.
        */
        read6Signed(offset: number, bitOffset: number): number;
        /**
        Reads a 7-bit value.
        @param offset The offset.
        @param bitOffset The bit offset.
        */
        read7(offset: number, bitOffset: number): number;
        /**
        Reads a 7-bit signed value.
        @param offset The offset.
        @param bitOffset The bit offset.
        */
        read7Signed(offset: number, bitOffset: number): number;
        /**
        Reads an 8-bit value.
        @param offset The offset.
        */
        read8(offset: number): number;
        /**
        Reads an 8-bit value.
        @param offset The offset.
        @param offsetPlus The offset plus the value length.
        */
        read8(offset: number, offsetPlus: fm.liveswitch.Holder<number>): number;
        /**
        Reads an 8-bit signed value.
        @param offset The offset.
        */
        read8Signed(offset: number): number;
        /**
        Reads an 8-bit signed value.
        @param offset The offset.
        @param offsetPlus The offset plus the value length.
        */
        read8Signed(offset: number, offsetPlus: fm.liveswitch.Holder<number>): number;
        /**
        Reads a 9-bit value.
        @param offset The offset.
        @param bitOffset The bitoffset.
        */
        read9(offset: number, bitOffset: number): number;
        /**
        Reads a 9-bit signed value.
        @param offset The offset.
        @param bitOffset The bit offset.
        */
        read9Signed(offset: number, bitOffset: number): number;
        /**
        Read a UTF-8 string.
        @param offset The offset.
        */
        readUtf8String(offset: number): string;
        /**
        Reads a UTF-8 string.
        @param offset The offset.
        @param length The length.
        */
        readUtf8String(offset: number, length: number): string;
        /**
        Resizes this buffer to a new length with new data being inserted at the end.
        @param newLength The new length.
        */
        resize(newLength: number): void;
        /**
        Resizes this buffer to a new length with new data being inserted at a given offset.
        @param newLength The new length.
        @param offset The offset.
        */
        resize(newLength: number, offset: number): void;
        /**
        Resizes this buffer to a new length with new data being inserted at a given offset.
        @param newLength The new length.
        @param offset The offset.
        @param setZero Sets empty space to zero.
        */
        resize(newLength: number, offset: number, setZero: boolean): void;
        /**
        Compares a data buffer for equality.
        @param buffer The data buffer.
        @return `true` if the sequences are equal; otherwise, `false`.
            
        */
        sequenceEquals(buffer: fm.liveswitch.DataBuffer): boolean;
        /**
        Compares a data buffer for equality in constant time.
        @param buffer The buffer.
        @return `true` if the sequences are equal; otherwise, `false`.
            
        */
        sequenceEqualsConstantTime(buffer: fm.liveswitch.DataBuffer): boolean;
        /**
        Sets the data buffer to the specified value.
        @param value The value.
        */
        set(value: number): void;
        /**
        Sets a subset of the data buffer to the specified value.
        @param value The value.
        @param offset The offset.
        */
        set(value: number, offset: number): void;
        /**
        Sets a subset of the data buffer to the specified value.
        @param value The value.
        @param offset The offset.
        @param length The length.
        */
        set(value: number, offset: number, length: number): void;
        /** @hidden */
        setIndex(value: number): void;
        /**
        Sets backing data buffer.
        */
        protected setInnerData(value: Uint8Array): void;
        /** @hidden */
        setLength(value: number): void;
        /**
        Sets whether [[fm.liveswitch.dataBuffer.data]] is little-endian.
        */
        setLittleEndian(value: boolean): void;
        /**
        Gets a subset of this instance.
        @param offset The offset.
        */
        subset(offset: number): fm.liveswitch.DataBuffer;
        /**
        Gets a subset of this instance.
        @param offset The offset.
        @param length The length.
        */
        subset(offset: number, length: number): fm.liveswitch.DataBuffer;
        /**
        Converts this instance to an array of bytes.
        */
        toArray(): Uint8Array;
        /**
        Converts this instance to an array of bytes.
        */
        toBytes(): Uint8Array;
        /**
        Converts this instance to a hexadecimal string.
        */
        toHexString(): string;
        /**
        Serializes this instance to JSON.
        */
        toJson(): string;
        /**
        Attempts to increment the retain count by one.
        @return True if successful.
        */
        tryKeep(): boolean;
        /**
        Tries to read a 1-bit value.
        @param offset The offset.
        @param bitOffset The bit offset.
        @param value if set to `true` [value].
        */
        tryRead1(offset: number, bitOffset: number, value: fm.liveswitch.Holder<boolean>): boolean;
        /**
        Tries to read a 10-bit value.
        @param offset The offset.
        @param bitOffset The bit offset.
        @param value The value.
        */
        tryRead10(offset: number, bitOffset: number, value: fm.liveswitch.Holder<number>): boolean;
        /**
        Tries to read an 11-bit value.
        @param offset The offset.
        @param bitOffset The bit offset.
        @param value The value.
        */
        tryRead11(offset: number, bitOffset: number, value: fm.liveswitch.Holder<number>): boolean;
        /**
        Tries to read a 12-bit value.
        @param offset The offset.
        @param bitOffset The bit offset.
        @param value The value.
        */
        tryRead12(offset: number, bitOffset: number, value: fm.liveswitch.Holder<number>): boolean;
        /**
        Tries to read a 13-bit value.
        @param offset The offset.
        @param bitOffset The bit offset.
        @param value The value.
        */
        tryRead13(offset: number, bitOffset: number, value: fm.liveswitch.Holder<number>): boolean;
        /**
        Tries to read a 14-bit value.
        @param offset The offset.
        @param bitOffset The bit offset.
        @param value The value.
        */
        tryRead14(offset: number, bitOffset: number, value: fm.liveswitch.Holder<number>): boolean;
        /**
        Tries to read a 15-bit value.
        @param offset The offset.
        @param bitOffset The bit offset.
        @param value The value.
        */
        tryRead15(offset: number, bitOffset: number, value: fm.liveswitch.Holder<number>): boolean;
        /**
        Tries to read a 16-bit value.
        @param offset The offset.
        @param value The value.
        */
        tryRead16(offset: number, value: fm.liveswitch.Holder<number>): boolean;
        /**
        Tries to read a 17-bit value.
        @param offset The offset.
        @param bitOffset The bit offset.
        @param value The value.
        */
        tryRead17(offset: number, bitOffset: number, value: fm.liveswitch.Holder<number>): boolean;
        /**
        Tries to read an 18-bit value.
        @param offset The offset.
        @param bitOffset The bit offset.
        @param value The value.
        */
        tryRead18(offset: number, bitOffset: number, value: fm.liveswitch.Holder<number>): boolean;
        /**
        Tries to read a 19-bit value.
        @param offset The offset.
        @param bitOffset The bit offset.
        @param value The value.
        */
        tryRead19(offset: number, bitOffset: number, value: fm.liveswitch.Holder<number>): boolean;
        /**
        Tries to read a 2-bit value.
        @param offset The offset.
        @param bitOffset The bit offset.
        @param value The value.
        */
        tryRead2(offset: number, bitOffset: number, value: fm.liveswitch.Holder<number>): boolean;
        /**
        Tries to read a 20-bit value.
        @param offset The offset.
        @param bitOffset The bit offset.
        @param value The value.
        */
        tryRead20(offset: number, bitOffset: number, value: fm.liveswitch.Holder<number>): boolean;
        /**
        Tries to read a 21-bit value.
        @param offset The offset.
        @param bitOffset The bit offset.
        @param value The value.
        */
        tryRead21(offset: number, bitOffset: number, value: fm.liveswitch.Holder<number>): boolean;
        /**
        Tries to read a 22-bit value.
        @param offset The offset.
        @param bitOffset The bit offset.
        @param value The value.
        */
        tryRead22(offset: number, bitOffset: number, value: fm.liveswitch.Holder<number>): boolean;
        /**
        Tries to read a 23-bit value.
        @param offset The offset.
        @param bitOffset The bit offset.
        @param value The value.
        */
        tryRead23(offset: number, bitOffset: number, value: fm.liveswitch.Holder<number>): boolean;
        /**
        Tries to read a 24-bit value.
        @param offset The offset.
        @param value The value.
        */
        tryRead24(offset: number, value: fm.liveswitch.Holder<number>): boolean;
        /**
        Tries to read a 3-bit value.
        @param offset The offset.
        @param bitOffset The bit offset.
        @param value The value.
        */
        tryRead3(offset: number, bitOffset: number, value: fm.liveswitch.Holder<number>): boolean;
        /**
        Tries to read a 32-bit value.
        @param offset The offset.
        @param value The value.
        */
        tryRead32(offset: number, value: fm.liveswitch.Holder<number>): boolean;
        /**
        Tries to read a 4-bit value.
        @param offset The offset.
        @param bitOffset The bit offset.
        @param value The value.
        */
        tryRead4(offset: number, bitOffset: number, value: fm.liveswitch.Holder<number>): boolean;
        /**
        Tries to read a 40-bit value.
        @param offset The offset.
        @param value The value.
        */
        tryRead40(offset: number, value: fm.liveswitch.Holder<number>): boolean;
        /**
        Tries to read a 48-bit value.
        @param offset The offset.
        @param value The value.
        */
        tryRead48(offset: number, value: fm.liveswitch.Holder<number>): boolean;
        /**
        Tries to read a 5-bit value.
        @param offset The offset.
        @param bitOffset The bit offset.
        @param value The value.
        */
        tryRead5(offset: number, bitOffset: number, value: fm.liveswitch.Holder<number>): boolean;
        /**
        Tries to read a 56-bit value.
        @param offset The offset.
        @param value The value.
        */
        tryRead56(offset: number, value: fm.liveswitch.Holder<number>): boolean;
        /**
        Tries to read a 6-bit value.
        @param offset The offset.
        @param bitOffset The bit offset.
        @param value The value.
        */
        tryRead6(offset: number, bitOffset: number, value: fm.liveswitch.Holder<number>): boolean;
        /**
        Tries to read a 64-bit value.
        @param offset The offset.
        @param value The value.
        */
        tryRead64(offset: number, value: fm.liveswitch.Holder<number>): boolean;
        /**
        Tries to read a 7-bit value.
        @param offset The offset.
        @param bitOffset The bit offset.
        @param value The value.
        */
        tryRead7(offset: number, bitOffset: number, value: fm.liveswitch.Holder<number>): boolean;
        /**
        Tries to read an 8-bit value.
        @param offset The offset.
        @param value The value.
        */
        tryRead8(offset: number, value: fm.liveswitch.Holder<number>): boolean;
        /**
        Tries to read a 9-bit value.
        @param offset The offset.
        @param bitOffset The bit offset.
        @param value The value.
        */
        tryRead9(offset: number, bitOffset: number, value: fm.liveswitch.Holder<number>): boolean;
        /**
        Writes a data buffer to this instance.
        @param buffer The buffer.
        */
        write(buffer: fm.liveswitch.DataBuffer): void;
        /**
        Writes a data buffer to this instance.
        @param buffer The buffer.
        @param offset The offset.
        */
        write(buffer: fm.liveswitch.DataBuffer, offset: number): void;
        /**
        Writes a data buffer to this instance.
        @param buffer The buffer.
        @param offset The offset.
        @param offsetPlus The offset plus the buffer length.
        */
        write(buffer: fm.liveswitch.DataBuffer, offset: number, offsetPlus: fm.liveswitch.Holder<number>): void;
        /**
        Writes a 1-bit value.
        @param value The value.
        @param offset The offset.
        @param bitOffset The bit offset.
        */
        write1(value: boolean, offset: number, bitOffset: number): boolean;
        /**
        Writes a 10-bit value.
        @param value The value.
        @param offset The offset.
        @param bitOffset The bit offset.
        */
        write10(value: number, offset: number, bitOffset: number): boolean;
        /**
        Writes an 11-bit value.
        @param value The value.
        @param offset The offset.
        @param bitOffset The bit offset.
        */
        write11(value: number, offset: number, bitOffset: number): boolean;
        /**
        Writes a 12-bit value.
        @param value The value.
        @param offset The offset.
        @param bitOffset The bit offset.
        */
        write12(value: number, offset: number, bitOffset: number): boolean;
        /**
        Writes a 13-bit value.
        @param value The value.
        @param offset The offset.
        @param bitOffset The bit offset.
        */
        write13(value: number, offset: number, bitOffset: number): boolean;
        /**
        Writes a 14-bit value.
        @param value The value.
        @param offset The offset.
        @param bitOffset The bit offset.
        */
        write14(value: number, offset: number, bitOffset: number): boolean;
        /**
        Writes a 15-bit value.
        @param value The value.
        @param offset The offset.
        @param bitOffset The bit offset.
        */
        write15(value: number, offset: number, bitOffset: number): boolean;
        /**
        Writes a 16-bit value.
        @param value The value.
        @param offset The offset.
        */
        write16(value: number, offset: number): boolean;
        /**
        Writes a 16-bit value.
        @param value The value.
        @param offset The offset.
        @param offsetPlus The offset plus the value length.
        */
        write16(value: number, offset: number, offsetPlus: fm.liveswitch.Holder<number>): boolean;
        /**
        Writes a 17-bit value.
        @param value The value.
        @param offset The offset.
        @param bitOffset The bit offset.
        */
        write17(value: number, offset: number, bitOffset: number): boolean;
        /**
        Writes an 18-bit value.
        @param value The value.
        @param offset The offset.
        @param bitOffset The bit offset.
        */
        write18(value: number, offset: number, bitOffset: number): boolean;
        /**
        Writes a 19-bit value.
        @param value The value.
        @param offset The offset.
        @param bitOffset The bit offset.
        */
        write19(value: number, offset: number, bitOffset: number): boolean;
        /**
        Writes a 2-bit value.
        @param value The value.
        @param offset The offset.
        @param bitOffset The bit offset.
        */
        write2(value: number, offset: number, bitOffset: number): boolean;
        /**
        Writes a 20-bit value.
        @param value The value.
        @param offset The offset.
        @param bitOffset The bit offset.
        */
        write20(value: number, offset: number, bitOffset: number): boolean;
        /**
        Writes a 21-bit value.
        @param value The value.
        @param offset The offset.
        @param bitOffset The bit offset.
        */
        write21(value: number, offset: number, bitOffset: number): boolean;
        /**
        Writes a 22-bit value.
        @param value The value.
        @param offset The offset.
        @param bitOffset The bit offset.
        */
        write22(value: number, offset: number, bitOffset: number): boolean;
        /**
        Writes a 23-bit value.
        @param value The value.
        @param offset The offset.
        @param bitOffset The bit offset.
        */
        write23(value: number, offset: number, bitOffset: number): boolean;
        /**
        Writes a 24-bit value.
        @param value The value.
        @param offset The offset.
        */
        write24(value: number, offset: number): boolean;
        /**
        Writes a 24-bit value.
        @param value The value.
        @param offset The offset.
        @param offsetPlus The offset plus the value length.
        */
        write24(value: number, offset: number, offsetPlus: fm.liveswitch.Holder<number>): boolean;
        /**
        Writes a 3-bit value.
        @param value The value.
        @param offset The offset.
        @param bitOffset The bit offset.
        */
        write3(value: number, offset: number, bitOffset: number): boolean;
        /**
        Writes a 32-bit value.
        @param value The value.
        @param offset The offset.
        */
        write32(value: number, offset: number): boolean;
        /**
        Writes a 32-bit value.
        @param value The value.
        @param offset The offset.
        @param offsetPlus The offset plus the value length.
        */
        write32(value: number, offset: number, offsetPlus: fm.liveswitch.Holder<number>): boolean;
        /**
        Writes a 4-bit value.
        @param value The value.
        @param offset The offset.
        @param bitOffset The bit offset.
        */
        write4(value: number, offset: number, bitOffset: number): boolean;
        /**
        Writes a 40-bit value.
        @param value The value.
        @param offset The offset.
        */
        write40(value: number, offset: number): boolean;
        /**
        Writes a 40-bit value.
        @param value The value.
        @param offset The offset.
        @param offsetPlus The offset plus the value length.
        */
        write40(value: number, offset: number, offsetPlus: fm.liveswitch.Holder<number>): boolean;
        /**
        Writes a 48-bit value.
        @param value The value.
        @param offset The offset.
        */
        write48(value: number, offset: number): boolean;
        /**
        Writes a 48-bit value.
        @param value The value.
        @param offset The offset.
        @param offsetPlus The offset plus the value length.
        */
        write48(value: number, offset: number, offsetPlus: fm.liveswitch.Holder<number>): boolean;
        /**
        Writes a 5-bit value.
        @param value The value.
        @param offset The offset.
        @param bitOffset The bit offset.
        */
        write5(value: number, offset: number, bitOffset: number): boolean;
        /**
        Writes a 56-bit value.
        @param value The value.
        @param offset The offset.
        */
        write56(value: number, offset: number): boolean;
        /**
        Writes a 56-bit value.
        @param value The value.
        @param offset The offset.
        @param offsetPlus The offset plus the value length.
        */
        write56(value: number, offset: number, offsetPlus: fm.liveswitch.Holder<number>): boolean;
        /**
        Writes a 6-bit value.
        @param value The value.
        @param offset The offset.
        @param bitOffset The bit offset.
        */
        write6(value: number, offset: number, bitOffset: number): boolean;
        /**
        Writes a 64-bit value.
        @param value The value.
        @param offset The offset.
        */
        write64(value: number, offset: number): boolean;
        /**
        Writes a 64-bit value.
        @param value The value.
        @param offset The offset.
        @param offsetPlus The offset plus the value length.
        */
        write64(value: number, offset: number, offsetPlus: fm.liveswitch.Holder<number>): boolean;
        /**
        Writes a 7-bit value.
        @param value The value.
        @param offset The offset.
        @param bitOffset The bit offset.
        */
        write7(value: number, offset: number, bitOffset: number): boolean;
        /**
        Writes an 8-bit value.
        @param value The value.
        @param offset The offset.
        */
        write8(value: number, offset: number): boolean;
        /**
        Writes an 8-bit value.
        @param value The value.
        @param offset The offset.
        @param offsetPlus The offset plus the value length.
        */
        write8(value: number, offset: number, offsetPlus: fm.liveswitch.Holder<number>): boolean;
        /**
        Writes a 9-bit value.
        @param value The value.
        @param offset The offset.
        @param bitOffset The bit offset.
        */
        write9(value: number, offset: number, bitOffset: number): boolean;
        /**
        Writes a byte array to this instance.
        @param bytes The bytes.
        */
        writeBytes(bytes: Uint8Array): void;
        /**
        Writes a byte array to this instance.
        @param bytes The bytes.
        @param bytesIndex The bytes index.
        @param bytesLength The bytes length.
        @param offset The offset.
        */
        writeBytes(bytes: Uint8Array, bytesIndex: number, bytesLength: number, offset: number): void;
        /**
        Writes a byte array to this instance.
        @param bytes The bytes.
        @param bytesIndex The bytes index.
        @param bytesLength The bytes length.
        @param offset The offset.
        @param offsetPlus The offset plus the buffer length.
        */
        writeBytes(bytes: Uint8Array, bytesIndex: number, bytesLength: number, offset: number, offsetPlus: fm.liveswitch.Holder<number>): void;
        /**
        Writes a byte array to this instance.
        @param bytes The bytes.
        @param bytesIndex The bytes index.
        @param offset The offset.
        */
        writeBytes(bytes: Uint8Array, bytesIndex: number, offset: number): void;
        /**
        Writes a byte array to this instance.
        @param bytes The bytes.
        @param offset The offset.
        */
        writeBytes(bytes: Uint8Array, offset: number): void;
        /**
        Performs a bitwise "xor" operation on a value.
        @param value The value.
        @param offset The offset.
        */
        xor(value: number, offset: number): boolean;
        /** @hidden */
        private static __fmliveswitchDataBufferInitialized;
        /** @hidden */
        private static __fmliveswitchDataBufferInitializing;
        /** @hidden */
        static fmliveswitchDataBufferInitialize(): void;
    }
}
declare namespace fm.liveswitch {
    /** @hidden */
    class DataBufferPooled extends fm.liveswitch.DataBuffer {
        getTypeString(): string;
        /** @hidden */
        private __counter;
        /** @hidden */
        private __pool;
        /** @hidden */
        private __tag;
        constructor(pool: fm.liveswitch.DataBufferPool, data: Uint8Array, length: number, littleEndian: boolean, tag: string);
        decrementRetain(): number;
        free(): fm.liveswitch.DataBuffer;
        getIsPooled(): boolean;
        getRetainCount(): number;
        invalidate(): Uint8Array;
        keep(): fm.liveswitch.DataBuffer;
    }
}
declare namespace fm.liveswitch {
    /**
    A subset of a DataBuffer.
    */
    class DataBufferSubset extends fm.liveswitch.DataBuffer {
        getTypeString(): string;
        /** @hidden */
        private _parent;
        /** @hidden */
        constructor(buffer: fm.liveswitch.DataBuffer, index: number, length: number);
        /**
        Appends a buffer.
        @param buffer The buffer.
        */
        append(buffer: fm.liveswitch.DataBuffer): fm.liveswitch.DataBuffer;
        /**
        Appends some buffers.
        @param buffers The buffers.
        */
        append(buffers: fm.liveswitch.DataBuffer[]): fm.liveswitch.DataBuffer;
        /**
        Decrements the retain count by one and returns the Buffer to the pool if zero.
        */
        free(): fm.liveswitch.DataBuffer;
        /**
        Gets the data.
        */
        getData(): Uint8Array;
        /**
        Gets whether this DataBuffer is from a pool.
        */
        getIsPooled(): boolean;
        /**
        Gets whether this DataBuffer is a subset.
        */
        getIsSubset(): boolean;
        /**
        Gets the Subset parent.
        */
        getParent(): fm.liveswitch.DataBuffer;
        /**
        Increment the retain count by one.
        */
        keep(): fm.liveswitch.DataBuffer;
        /**
        Prepends a buffer.
        @param buffer The buffer.
        */
        prepend(buffer: fm.liveswitch.DataBuffer): fm.liveswitch.DataBuffer;
        /**
        Prepends some buffers.
        @param buffers The buffers.
        */
        prepend(buffers: fm.liveswitch.DataBuffer[]): void;
        /** @hidden */
        private setParent;
        /**
        Gets a subset of this instance.
        @param offset The offset.
        */
        subset(offset: number): fm.liveswitch.DataBuffer;
        /**
        Gets a subset of this instance.
        @param offset The offset.
        @param length The length.
        */
        subset(offset: number, length: number): fm.liveswitch.DataBuffer;
    }
}
declare namespace fm.liveswitch {
    /**
    Details about a specific log event.
    */
    class LogEvent {
        getTypeString(): string;
        /** @hidden */
        private _exception;
        /** @hidden */
        private _level;
        /** @hidden */
        private _message;
        /** @hidden */
        private _scope;
        /** @hidden */
        private _tag;
        /** @hidden */
        private _threadId;
        /** @hidden */
        private _timestamp;
        private fmliveswitchLogEventInit;
        constructor();
        /**
        Initializes a new instance of the [[fm.liveswitch.logEvent]] class.
        @param timestamp The event timestamp.
        @param tag The event tag.
        @param scope The event scope.
        @param level The event level.
        @param message The event message.
        @param exception The event exception, if one exists.
        @param threadId The ID of the thread generating the event.
        */
        constructor(timestamp: fm.liveswitch.DateTime, tag: string, scope: string, level: fm.liveswitch.LogLevel, message: string, exception: fm.liveswitch.Exception, threadId: number);
        /**
        Deserializes a log event from JSON.
        @param logEventJson The log event JSON.
        */
        static fromJson(logEventJson: string): fm.liveswitch.LogEvent;
        /** @hidden */
        private static logLevelToString;
        /** @hidden */
        private static stringToLogLevel;
        /**
        Serializes a log event to JSON.
        @param logEvent The log event.
        */
        static toJson(logEvent: fm.liveswitch.LogEvent): string;
        /**
        Gets the event exception, if one exists.
        */
        getException(): fm.liveswitch.Exception;
        /**
        Gets the event level.
        */
        getLevel(): fm.liveswitch.LogLevel;
        /**
        Gets the level of this log event. Alias for [[fm.liveswitch.logEvent.level]].
        */
        getLogLevel(): fm.liveswitch.LogLevel;
        /**
        Gets the event message.
        */
        getMessage(): string;
        /**
        Gets the event scope.
        */
        getScope(): string;
        /**
        Gets the event tag.
        */
        getTag(): string;
        /**
        Gets the ID of the thread generating the event.
        */
        getThreadId(): number;
        /**
        Gets the event timestamp.
        */
        getTimestamp(): fm.liveswitch.DateTime;
        /**
        Sets the event exception, if one exists.
        */
        setException(value: fm.liveswitch.Exception): void;
        /**
        Sets the event level.
        */
        setLevel(value: fm.liveswitch.LogLevel): void;
        /** @hidden */
        private setLogLevel;
        /**
        Sets the event message.
        */
        setMessage(value: string): void;
        /**
        Sets the event scope.
        */
        setScope(value: string): void;
        /**
        Sets the event tag.
        */
        setTag(value: string): void;
        /**
        Sets the ID of the thread generating the event.
        */
        setThreadId(value: number): void;
        /**
        Sets the event timestamp.
        */
        setTimestamp(value: fm.liveswitch.DateTime): void;
        /**
        Serializes this instance to JSON.
        */
        toJson(): string;
        /**

        */
        toString(): string;
    }
}
declare namespace fm.liveswitch {
    class HashTypeWrapper {
        getTypeString(): string;
        /** @hidden */
        private _value;
        constructor(value: fm.liveswitch.HashType);
        toString(): string;
    }
}
declare namespace fm.liveswitch {
    class MacTypeWrapper {
        getTypeString(): string;
        /** @hidden */
        private _value;
        constructor(value: fm.liveswitch.MacType);
        toString(): string;
    }
}
declare namespace fm.liveswitch {
    /**
    Utility class to assist with Unix timestamp conversions.
    */
    class UnixTimestamp {
        getTypeString(): string;
        /** @hidden */
        private static fm_liveswitch_UnixTimestamp__baseTicks;
        constructor();
        /**
        Converts a date to a Unix timestamp.
        @param dateTime The date to convert.
        @return The equivalent Unix timestamp.
        */
        static dateTimeToUnix(dateTime: fm.liveswitch.DateTime): number;
        /**
        Converts a date to a Unix timestamp with millisecond precision.
        @param dateTime The date to convert.
        @return The equivalent Unix timestamp.
        */
        static dateTimeToUnixMillis(dateTime: fm.liveswitch.DateTime): number;
        /**
        Gets the current UTC time in Unix format.
        */
        static getUtcNow(): number;
        /**
        Gets the current UTC time in Unix format with millisecond precision.
        */
        static getUtcNowMillis(): number;
        /**
        Converts ticks to a Unix timestamp.
        @param ticks The ticks to convert.
        @return The equivalent Unix timestamp.
        */
        static ticksToUnix(ticks: number): number;
        /**
        Converts ticks to a Unix timestamp with millisecond precision.
        @param ticks The ticks to convert.
        @return The equivalent Unix timestamp.
        */
        static ticksToUnixMillis(ticks: number): number;
        /**
        Converts a Unix timestamp with millisecond precision to a date.
        @param unix The Unix timestamp to convert.
        @return The equivalent date.
        */
        static unixMillisToDateTime(unix: number): fm.liveswitch.DateTime;
        /**
        Converts a Unix timestamp with millisecond precision to ticks.
        @param unix The Unix timestamp to convert.
        @return The equivalent ticks.
        */
        static unixMillisToTicks(unix: number): number;
        /**
        Converts a Unix timestamp to a date.
        @param unix The Unix timestamp to convert.
        @return The equivalent date.
        */
        static unixToDateTime(unix: number): fm.liveswitch.DateTime;
        /**
        Converts a Unix timestamp to ticks.
        @param unix The Unix timestamp to convert.
        @return The equivalent ticks.
        */
        static unixToTicks(unix: number): number;
        /** @hidden */
        private static __fmliveswitchUnixTimestampInitialized;
        /** @hidden */
        private static __fmliveswitchUnixTimestampInitializing;
        /** @hidden */
        static fmliveswitchUnixTimestampInitialize(): void;
    }
}
declare namespace fm.liveswitch {
    /**
    Class to hold a double value passed by reference.
    */
    class DoubleHolder {
        getTypeString(): string;
        /** @hidden */
        private _value;
        private fmliveswitchDoubleHolderInit;
        /**
        Initializes a new instance of the [[fm.liveswitch.doubleHolder]] class.
        */
        constructor();
        /**
        Initializes a new instance of the [[fm.liveswitch.doubleHolder]] class.
        @param value The value.
        */
        constructor(value: number);
        /**
        Gets the value.
        */
        getValue(): number;
        /**
        Sets the value.
        */
        setValue(value: number): void;
    }
}
declare namespace fm.liveswitch {
    /**
    An error.
    */
    class Error {
        getTypeString(): string;
        /** @hidden */
        private _code;
        /** @hidden */
        private _exception;
        /**
        Initializes a new instance of the [[fm.liveswitch.error]] class.
        */
        constructor();
        /**
        Initializes a new instance of the [[fm.liveswitch.error]] class.
        @param code The code.
        @param exception The exception.
        */
        constructor(code: fm.liveswitch.ErrorCode, exception: fm.liveswitch.Exception);
        /**
        Initializes a new instance of the [[fm.liveswitch.error]] class.
        @param code The code.
        @param message The message.
        */
        constructor(code: fm.liveswitch.ErrorCode, message: string);
        /**
        Deserializes an instance from JSON.
        @param errorJson The JSON to deserialize.
        @return The deserialized error.
        */
        static fromJson(errorJson: string): fm.liveswitch.Error;
        /**
        Serializes an instance to JSON.
        @param error The error.
        @return
                    The serialized JSON.
            
        */
        static toJson(error: fm.liveswitch.Error): string;
        /**
        Gets the code.
        */
        getCode(): fm.liveswitch.ErrorCode;
        /**
        Gets the code.
        */
        getCodeValue(): number;
        /**
        Gets the description for this [[fm.liveswitch.error]].
        */
        getDescription(): string;
        /**
        Gets the code. Obsolete. Alias for [[fm.liveswitch.error.code]].
        */
        getErrorCode(): fm.liveswitch.ErrorCode;
        /**
        Gets the exception.
        */
        getException(): fm.liveswitch.Exception;
        /**
        Gets the message.
        */
        getMessage(): string;
        /**
        Sets the code.
        */
        setCode(value: fm.liveswitch.ErrorCode): void;
        /**
        Sets the code.
        */
        setCodeValue(value: number): void;
        /**
        Sets the code. Obsolete. Alias for [[fm.liveswitch.error.code]].
        */
        setErrorCode(value: fm.liveswitch.ErrorCode): void;
        /**
        Sets the exception.
        */
        setException(value: fm.liveswitch.Exception): void;
        /**
        Sets the message.
        */
        setMessage(value: string): void;
        /**
        Serializes this instance to JSON.
        @return
                    The serialized JSON.
            
        */
        toJson(): string;
        /**
        Returns the string representation of this error.
        */
        toString(): string;
    }
}
declare namespace fm.liveswitch {
    class ErrorCodeWrapper {
        getTypeString(): string;
        /** @hidden */
        private _value;
        constructor(value: fm.liveswitch.ErrorCode);
        toString(): string;
    }
}
declare namespace fm.liveswitch {
    /**
    Class to hold a float value passed by reference.
    */
    class FloatHolder {
        getTypeString(): string;
        /** @hidden */
        private _value;
        private fmliveswitchFloatHolderInit;
        /**
        Initializes a new instance of the [[fm.liveswitch.floatHolder]] class.
        */
        constructor();
        /**
        Initializes a new instance of the [[fm.liveswitch.floatHolder]] class.
        @param value The value.
        */
        constructor(value: number);
        /**
        Gets the value.
        */
        getValue(): number;
        /**
        Sets the value.
        */
        setValue(value: number): void;
    }
}
declare namespace fm.liveswitch {
    class HttpMethodWrapper {
        getTypeString(): string;
        /** @hidden */
        private _value;
        constructor(value: fm.liveswitch.HttpMethod);
        toString(): string;
    }
}
declare namespace fm.liveswitch {
    /**
    Arguments for sending an HTTP request.
    */
    class HttpRequestArgs extends fm.liveswitch.Dynamic {
        getTypeString(): string;
        /** @hidden */
        private __headers;
        /** @hidden */
        private _binaryContent;
        /** @hidden */
        private _maxRetries;
        /** @hidden */
        private _method;
        /** @hidden */
        private _onRequestCreated;
        /** @hidden */
        private _onResponseReceived;
        /** @hidden */
        private _sender;
        /** @hidden */
        private _textContent;
        /** @hidden */
        private _timeout;
        /** @hidden */
        private _url;
        private fmliveswitchHttpRequestArgsInit;
        /**
        Initializes a new instance of the [[fm.liveswitch.httpRequestArgs]] class with default values.
        */
        constructor();
        /**
        Gets the binary content to transfer over HTTP. Overrides [[fm.liveswitch.httpRequestArgs.textContent]].
        */
        getBinaryContent(): Uint8Array;
        /**
        Gets the headers to transfer over HTTP.
        */
        getHeaders(): fm.liveswitch.NameValueCollection;
        /**
        Gets the maximum number of retries allowed.
        */
        getMaxRetries(): number;
        /**
        Gets the HTTP method.
        */
        getMethod(): fm.liveswitch.HttpMethod;
        /**
        Gets the callback to invoke once the outgoing HTTP request is created. See [[fm.liveswitch.httpRequestCreatedArgs]] for callback argument details.
        */
        getOnRequestCreated(): fm.liveswitch.IAction1<fm.liveswitch.HttpRequestCreatedArgs>;
        /**
        Gets the callback to invoke once the incoming HTTP response has been received. See [[fm.liveswitch.httpResponseReceivedArgs]] for callback argument details.
        */
        getOnResponseReceived(): fm.liveswitch.IAction1<fm.liveswitch.HttpResponseReceivedArgs>;
        /**
        Gets the sender of the content, either a client or publisher.
        */
        getSender(): Object;
        /**
        Gets the text content to transfer over HTTP.
        */
        getTextContent(): string;
        /**
        Gets the number of milliseconds to wait before timing out the HTTP transfer. Defaults to 15000 ms (15 seconds).
        */
        getTimeout(): number;
        /**
        Gets the target URL for the HTTP request.
        */
        getUrl(): string;
        /**
        Sets the binary content to transfer over HTTP. Overrides [[fm.liveswitch.httpRequestArgs.textContent]].
        */
        setBinaryContent(value: Uint8Array): void;
        /**
        Sets the headers to transfer over HTTP.
        */
        setHeaders(value: fm.liveswitch.NameValueCollection): void;
        /**
        Sets the maximum number of retries allowed.
        */
        setMaxRetries(value: number): void;
        /**
        Sets the HTTP method.
        */
        setMethod(value: fm.liveswitch.HttpMethod): void;
        /**
        Sets the callback to invoke once the outgoing HTTP request is created. See [[fm.liveswitch.httpRequestCreatedArgs]] for callback argument details.
        */
        setOnRequestCreated(value: fm.liveswitch.IAction1<fm.liveswitch.HttpRequestCreatedArgs>): void;
        /**
        Sets the callback to invoke once the incoming HTTP response has been received. See [[fm.liveswitch.httpResponseReceivedArgs]] for callback argument details.
        */
        setOnResponseReceived(value: fm.liveswitch.IAction1<fm.liveswitch.HttpResponseReceivedArgs>): void;
        /**
        Sets the sender of the content, either a client or publisher.
        */
        setSender(value: Object): void;
        /**
        Sets the text content to transfer over HTTP.
        */
        setTextContent(value: string): void;
        /**
        Sets the number of milliseconds to wait before timing out the HTTP transfer. Defaults to 15000 ms (15 seconds).
        */
        setTimeout(value: number): void;
        /**
        Sets the target URL for the HTTP request.
        */
        setUrl(value: string): void;
    }
}
declare namespace fm.liveswitch {
    /**
    Arguments passed into callbacks when an HTTP request is created.
    */
    class HttpRequestCreatedArgs {
        getTypeString(): string;
        /** @hidden */
        private _request;
        /** @hidden */
        private _requestArgs;
        /** @hidden */
        private _sender;
        constructor();
        /**
        Gets the outgoing HTTP request about to be sent to the server.
        */
        getRequest(): any;
        /**
        Gets the original request arguments.
        */
        getRequestArgs(): fm.liveswitch.HttpRequestArgs;
        /**
        Gets the sender of the request, either a client or publisher.
        */
        getSender(): Object;
        /**
        Sets the outgoing HTTP request about to be sent to the server.
        */
        setRequest(value: any): void;
        /**
        Sets the original request arguments.
        */
        setRequestArgs(value: fm.liveswitch.HttpRequestArgs): void;
        /**
        Sets the sender of the request, either a client or publisher.
        */
        setSender(value: Object): void;
    }
}
declare namespace fm.liveswitch {
    /**
    Arguments for receiving an HTTP response.
    */
    class HttpResponseArgs {
        getTypeString(): string;
        /** @hidden */
        private _binaryContent;
        /** @hidden */
        private _exception;
        /** @hidden */
        private _headers;
        /** @hidden */
        private _requestArgs;
        /** @hidden */
        private _retries;
        /** @hidden */
        private _statusCode;
        /** @hidden */
        private _textContent;
        private fmliveswitchHttpResponseArgsInit;
        constructor();
        /**
        Initializes a new instance of the [[fm.liveswitch.httpResponseArgs]] class.
        @param requestArgs The request arguments.
        */
        constructor(requestArgs: fm.liveswitch.HttpRequestArgs);
        /**
        Gets the binary content read from the HTTP response.
        */
        getBinaryContent(): Uint8Array;
        /**
        Gets the exception generated while completing the request.
        */
        getException(): fm.liveswitch.Exception;
        /**
        Gets the headers read from the HTTP response.
        */
        getHeaders(): fm.liveswitch.NameValueCollection;
        /**
        Gets the original [[fm.liveswitch.httpRequestArgs]].
        */
        getRequestArgs(): fm.liveswitch.HttpRequestArgs;
        /**
        Gets the number of retries that were required.
        */
        getRetries(): number;
        /**
        Gets the status code read from the HTTP response.
        */
        getStatusCode(): number;
        /**
        Gets the text content read from the HTTP response.
        */
        getTextContent(): string;
        /**
        Sets the binary content read from the HTTP response.
        */
        setBinaryContent(value: Uint8Array): void;
        /**
        Sets the exception generated while completing the request.
        */
        setException(value: fm.liveswitch.Exception): void;
        /** @hidden */
        private setHeaders;
        /**
        Sets the original [[fm.liveswitch.httpRequestArgs]].
        */
        setRequestArgs(value: fm.liveswitch.HttpRequestArgs): void;
        /**
        Sets the number of retries that were required.
        */
        setRetries(value: number): void;
        /**
        Sets the status code read from the HTTP response.
        */
        setStatusCode(value: number): void;
        /**
        Sets the text content read from the HTTP response.
        */
        setTextContent(value: string): void;
    }
}
declare namespace fm.liveswitch {
    /**
    Arguments passed into callbacks when an HTTP response is received.
    */
    class HttpResponseReceivedArgs {
        getTypeString(): string;
        /** @hidden */
        private _requestArgs;
        /** @hidden */
        private _response;
        /** @hidden */
        private _sender;
        constructor();
        /**
        Gets the original request arguments.
        */
        getRequestArgs(): fm.liveswitch.HttpRequestArgs;
        /**
        Gets the incoming HTTP response received from the server.
        */
        getResponse(): any;
        /**
        Gets the sender of the request, either a client or publisher.
        */
        getSender(): Object;
        /**
        Sets the original request arguments.
        */
        setRequestArgs(value: fm.liveswitch.HttpRequestArgs): void;
        /**
        Sets the incoming HTTP response received from the server.
        */
        setResponse(value: any): void;
        /**
        Sets the sender of the request, either a client or publisher.
        */
        setSender(value: Object): void;
    }
}
declare namespace fm.liveswitch {
    /**
    Arguments for [[fm.liveswitch.httpTransfer.addOnSendStart]].
    */
    class HttpSendFinishArgs {
        getTypeString(): string;
        /** @hidden */
        private _requestBinaryContent;
        /** @hidden */
        private _requestTextContent;
        /** @hidden */
        private _responseBinaryContent;
        /** @hidden */
        private _responseHeaders;
        /** @hidden */
        private _responseTextContent;
        /** @hidden */
        private _sender;
        constructor();
        /**
        Gets the binary content of the request.
        */
        getRequestBinaryContent(): Uint8Array;
        /**
        Gets the text content of the request.
        */
        getRequestTextContent(): string;
        /**
        Gets the binary content of the response.
        */
        getResponseBinaryContent(): Uint8Array;
        /**
        Gets the headers of the response.
        */
        getResponseHeaders(): fm.liveswitch.NameValueCollection;
        /**
        Gets the binary content of the response.
        */
        getResponseTextContent(): string;
        /**
        Gets the sender of the request, either a client or publisher.
        */
        getSender(): Object;
        /** @hidden */
        setRequestBinaryContent(value: Uint8Array): void;
        /** @hidden */
        setRequestTextContent(value: string): void;
        /** @hidden */
        setResponseBinaryContent(value: Uint8Array): void;
        /** @hidden */
        setResponseHeaders(value: fm.liveswitch.NameValueCollection): void;
        /** @hidden */
        setResponseTextContent(value: string): void;
        /** @hidden */
        setSender(value: Object): void;
    }
}
declare namespace fm.liveswitch {
    /**
    Arguments for [[fm.liveswitch.httpTransfer.addOnSendStart]].
    */
    class HttpSendStartArgs {
        getTypeString(): string;
        /** @hidden */
        private _requestBinaryContent;
        /** @hidden */
        private _requestTextContent;
        /** @hidden */
        private _sender;
        constructor();
        /**
        Gets the binary content of the request.
        */
        getRequestBinaryContent(): Uint8Array;
        /**
        Gets the text content of the request.
        */
        getRequestTextContent(): string;
        /**
        Gets the sender of the request, either a client or publisher.
        */
        getSender(): Object;
        /** @hidden */
        setRequestBinaryContent(value: Uint8Array): void;
        /** @hidden */
        setRequestTextContent(value: string): void;
        /** @hidden */
        setSender(value: Object): void;
    }
}
declare namespace fm.liveswitch {
    /**
    Creates implementations of [[fm.liveswitch.httpTransfer]].
    */
    class HttpTransferFactory {
        getTypeString(): string;
        /** @hidden */
        private static fm_liveswitch_HttpTransferFactory__createHttpTransfer;
        constructor();
        /** @hidden */
        static defaultCreateHttpTransfer(): fm.liveswitch.HttpTransfer;
        /**
        Gets the callback that creates an HTTP-based transfer class.
        */
        static getCreateHttpTransfer(): fm.liveswitch.IFunction0<fm.liveswitch.HttpTransfer>;
        /**
        Gets an instance of the HTTP-based transfer class.
        */
        static getHttpTransfer(): fm.liveswitch.HttpTransfer;
        /**
        Sets the callback that creates an HTTP-based transfer class.
        */
        static setCreateHttpTransfer(value: fm.liveswitch.IFunction0<fm.liveswitch.HttpTransfer>): void;
    }
}
declare namespace fm.liveswitch {
    /**
    An HTTP web request sender.
    */
    class HttpWebRequestSender extends fm.liveswitch.Dynamic {
        getTypeString(): string;
        /** @hidden */
        private __disableJsonp;
        /** @hidden */
        private __forceJsonp;
        /** @hidden */
        private _disableCors;
        /** @hidden */
        private _disablePostMessage;
        private fmliveswitchHttpWebRequestSenderInit;
        constructor();
        /**
        Gets a value indicating whether to disable the cross-origin resource sharing (CORS) transport.
        */
        getDisableCors(): boolean;
        /**
        Gets a value indicating whether to disable the JSON-P transport.
        */
        getDisableJsonp(): boolean;
        /**
        Gets a value indicating whether to disable the postMessage transport.
        */
        getDisablePostMessage(): boolean;
        /**
        Gets a value indicating whether to force the JSON-P transport.
        */
        getForceJsonp(): boolean;
        /**
        Sets a value indicating whether to disable the cross-origin resource sharing (CORS) transport.
        */
        setDisableCors(value: boolean): void;
        /**
        Sets a value indicating whether to disable the JSON-P transport.
        */
        setDisableJsonp(value: boolean): void;
        /**
        Sets a value indicating whether to disable the postMessage transport.
        */
        setDisablePostMessage(value: boolean): void;
        /**
        Sets a value indicating whether to force the JSON-P transport.
        */
        setForceJsonp(value: boolean): void;
    }
}
declare namespace fm.liveswitch {
    /**
    Class to hold an integer value passed by reference.
    */
    class IntegerHolder {
        getTypeString(): string;
        /** @hidden */
        private _value;
        private fmliveswitchIntegerHolderInit;
        /**
        Initializes a new instance of the [[fm.liveswitch.integerHolder]] class.
        */
        constructor();
        /**
        Initializes a new instance of the [[fm.liveswitch.integerHolder]] class.
        @param value The value.
        */
        constructor(value: number);
        /**
        Gets the value.
        */
        getValue(): number;
        /**
        Sets the value.
        */
        setValue(value: number): void;
    }
}
declare namespace fm.liveswitch {
    /**
    Interface for a promise that can be rejected.
    */
    interface IPromise {
        castAndResolve(result: Object): boolean;
        reject(exception: fm.liveswitch.Exception): boolean;
    }
}
declare namespace fm.liveswitch {
    /** @hidden */
    class JsonChecker {
        getTypeString(): string;
        /** @hidden */
        private __depth;
        /** @hidden */
        private __offset;
        /** @hidden */
        private __stack;
        /** @hidden */
        private __state;
        /** @hidden */
        private static fm_liveswitch_JsonChecker__ascii_class;
        /** @hidden */
        private static fm_liveswitch_JsonChecker__state_transition_table;
        private fmliveswitchJsonCheckerInit;
        constructor();
        constructor(depth: number);
        /** @hidden */
        private check;
        checkString(str: string): boolean;
        /** @hidden */
        private finalCheck;
        /** @hidden */
        private onError;
        /** @hidden */
        private pop;
        /** @hidden */
        private push;
        /** @hidden */
        private static __fmliveswitchJsonCheckerInitialized;
        /** @hidden */
        private static __fmliveswitchJsonCheckerInitializing;
        /** @hidden */
        static fmliveswitchJsonCheckerInitialize(): void;
    }
}
declare namespace fm.liveswitch {
    /**
    Base class for all JSON provider implementations.
    */
    abstract class JsonProvider {
        getTypeString(): string;
        constructor();
        /**
        Deserializes a value from a JSON string.
        @param valueJson The JSON string to deserialize.
        @return The deserialized value.
        */
        abstract deserialize<T>(valueJson: string): T;
        /**
        Serializes a value to a JSON string.
        @param value The value to serialize.
        @return The serialized JSON string.
        */
        abstract serialize<T>(value: T): string;
    }
}
declare namespace fm.liveswitch {
    /**
    Thread-safe class providing access to a single [[fm.liveswitch.lockedRandomizer.Randomizer]].
    */
    abstract class LockedRandomizer {
        getTypeString(): string;
        /** @hidden */
        private static fm_liveswitch_LockedRandomizer__randomizer;
        /** @hidden */
        private static fm_liveswitch_LockedRandomizer__randomLock;
        /**
        Returns a nonnegative random number.
        */
        static next(): number;
        /**
        Returns a nonnegative random number less than the specified maximum.
        @param maxValue The maximum value (exclusive).
        */
        static next(maxValue: number): number;
        /**
        Returns a random number within a specified range.
        @param minValue The minimum value (inclusive).
        @param maxValue The maximum value (exclusive).
        */
        static next(minValue: number, maxValue: number): number;
        /**
        Fills the elements of a specified array of bytes with random numbers.
        @param buffer The array of bytes to fill.
        */
        static nextBytes(buffer: Uint8Array): void;
        /**
        Returns a random number between 0.0 and 1.0.
        */
        static nextDouble(): number;
        /**
        Returns a nonnegative random number.
        */
        static nextLong(): number;
        /**
        Generates a random string of a specified size.
        @param size The size of the output string.
        */
        static randomString(size: number): string;
        /** @hidden */
        private static __fmliveswitchLockedRandomizerInitialized;
        /** @hidden */
        private static __fmliveswitchLockedRandomizerInitializing;
        /** @hidden */
        static fmliveswitchLockedRandomizerInitialize(): void;
    }
}
declare namespace fm.liveswitch {
    /**
    Log utility class.
    */
    class Log {
        getTypeString(): string;
        /** @hidden */
        private static fm_liveswitch_Log___staticLogger;
        constructor();
        /**
        Registers a log provider as a logging target. Alias for RegisterProvider.
        @param provider The new provider.
        */
        static addProvider(provider: fm.liveswitch.LogProvider): void;
        /**
        Registers a log provider as a logging target, setting its log level in the process. Alias for RegisterProvider.
        @param provider The new provider.
        @param level The log level.
        */
        static addProvider(provider: fm.liveswitch.LogProvider, level: fm.liveswitch.LogLevel): void;
        /**
        Logs a debug-level message.
        @param message The message.
        */
        static debug(message: string): void;
        /**
        Logs a debug-level message.
        @param message The message.
        @param ex The exception.
        */
        static debug(message: string, ex: fm.liveswitch.Exception): void;
        /**
        Logs an error-level message.
        @param message The message.
        */
        static error(message: string): void;
        /**
        Logs an error-level message.
        @param message The message.
        @param ex The exception.
        */
        static error(message: string, ex: fm.liveswitch.Exception): void;
        /**
        Logs a fatal-level message.
        @param message The message.
        */
        static fatal(message: string): void;
        /**
        Logs a fatal-level message.
        @param message The message.
        @param ex The exception.
        */
        static fatal(message: string, ex: fm.liveswitch.Exception): void;
        /**
        Blocks until all logs are written out.
        */
        static flush(): void;
        /**
        Gets a value indicating whether logging is enabled for debug-level messages.
        */
        static getIsDebugEnabled(): boolean;
        /**
        Gets a value indicating whether logging is enabled for error-level messages.
        */
        static getIsErrorEnabled(): boolean;
        /**
        Gets a value indicating whether logging is enabled for fatal-level messages.
        */
        static getIsFatalEnabled(): boolean;
        /**
        Gets a value indicating whether logging is enabled for info-level messages.
        */
        static getIsInfoEnabled(): boolean;
        /**
        Gets a value indicating whether logging is enabled for verbose-level messages.
        */
        static getIsVerboseEnabled(): boolean;
        /**
        Gets a value indicating whether logging is enabled for warn-level messages.
        */
        static getIsWarnEnabled(): boolean;
        /**
        Get a logger for a specific Tag.
        @param tag The tag to log to.
        @return A ILog that will log to the specified tag.
        */
        static getLogger(tag: string): fm.liveswitch.ILog;
        /**
        Get a logger for a specific Tag.
        @param tag The tag to log to.
        @param level Logger's default log level.
        @return A ILog that will log to the specified tag.
        */
        static getLogger(tag: string, level: fm.liveswitch.LogLevel): fm.liveswitch.ILog;
        /**
        Get a logger for a specific Tag. The tag is taken from the class namespace and name.
        @param type The type to use as the tag.
        @return A ILog that will log to the specified tag.
        */
        static getLogger(type: fm.liveswitch.Type): fm.liveswitch.ILog;
        /**
        Get a logger for a specific Tag.  The tag is taken from the class namespace and name.
        @param type The type to use as the tag.
        @param level Logger's default log level.
        @return A ILog that will log to the specified tag.
        */
        static getLogger(type: fm.liveswitch.Type, level: fm.liveswitch.LogLevel): fm.liveswitch.ILog;
        /**
        Gets the default log level.
        */
        static getLogLevel(): fm.liveswitch.LogLevel;
        /**
        Gets the first log provider.
        */
        static getProvider(): fm.liveswitch.LogProvider;
        /**
        Gets the log providers.
        */
        static getProviders(): fm.liveswitch.LogProvider[];
        /**
        Logs an info-level message.
        @param message The message.
        */
        static info(message: string): void;
        /**
        Logs an info-level message.
        @param message The message.
        @param ex The exception.
        */
        static info(message: string, ex: fm.liveswitch.Exception): void;
        /**
        Registers a log provider as a logging target.
        @param provider The provider.
        */
        static registerProvider(provider: fm.liveswitch.LogProvider): void;
        /**
        Registers a log provider as a logging target, setting its log level in the process.
        @param provider The provider.
        @param level The log level.
        */
        static registerProvider(provider: fm.liveswitch.LogProvider, level: fm.liveswitch.LogLevel): void;
        /**
        Unregisters a log provider as a logging target. Alias for UnregisterProvider.
        @param provider The provider.
        */
        static removeProvider(provider: fm.liveswitch.LogProvider): boolean;
        /**
        Unregisters all log providers as logging targets. Alias for UnregisterProviders.
        */
        static removeProviders(): void;
        /**
        Sets the default log level.
        */
        static setLogLevel(value: fm.liveswitch.LogLevel): void;
        /**
        Sets the first log provider.
        */
        static setProvider(value: fm.liveswitch.LogProvider): void;
        /**
        Override the default log level for a specific tag.
        @param tag The Tag to set the log level to.
        @param level The new loglevel to use.
        */
        static setTagOverride(tag: string, level: fm.liveswitch.LogLevel): void;
        /**
        Unregisters a log provider as a logging target.
        @param provider The provider.
        */
        static unregisterProvider(provider: fm.liveswitch.LogProvider): boolean;
        /**
        Unregisters all log providers as logging targets.
        */
        static unregisterProviders(): void;
        /**
        Logs a verbose-level message.
        @param message The message.
        */
        static verbose(message: string): void;
        /**
        Logs a verbose-level message.
        @param message The message.
        @param ex The exception.
        */
        static verbose(message: string, ex: fm.liveswitch.Exception): void;
        /**
        Logs a warn-level message.
        @param message The message.
        */
        static warn(message: string): void;
        /**
        Logs a warn-level message.
        @param message The message.
        @param ex The exception.
        */
        static warn(message: string, ex: fm.liveswitch.Exception): void;
        /**
        Writes a line of text to the log.
        @param text The text to write to the log.
        */
        static writeLine(text: string): void;
        /** @hidden */
        private static __fmliveswitchLogInitialized;
        /** @hidden */
        private static __fmliveswitchLogInitializing;
        /** @hidden */
        static fmliveswitchLogInitialize(): void;
    }
}
declare namespace fm.liveswitch {
    /** @hidden */
    class LogConfiguration {
        getTypeString(): string;
        /** @hidden */
        private static fm_liveswitch_LogConfiguration___lock;
        /** @hidden */
        private static fm_liveswitch_LogConfiguration___logProviders;
        /** @hidden */
        private static fm_liveswitch_LogConfiguration___providerCount;
        /** @hidden */
        private static fm_liveswitch_LogConfiguration___tagOverrides;
        /** @hidden */
        private static fm_liveswitch_LogConfiguration___tagOverridesLock;
        /** @hidden */
        private static fm_liveswitch_LogConfiguration__defaultLogLevel;
        constructor();
        static addLogProvider(provider: fm.liveswitch.LogProvider): void;
        static clearLogProviders(): void;
        static getDefaultLogLevel(): fm.liveswitch.LogLevel;
        static getHasProviders(): boolean;
        static getLogProviders(): fm.liveswitch.LogProvider[];
        static getTagLogLevel(tag: string): fm.liveswitch.LogLevel;
        static removeLogProvider(provider: fm.liveswitch.LogProvider): boolean;
        static setDefaultLogLevel(value: fm.liveswitch.LogLevel): void;
        static setTagLogLevel(tag: string, logLevel: fm.liveswitch.LogLevel): void;
        /** @hidden */
        private static __fmliveswitchLogConfigurationInitialized;
        /** @hidden */
        private static __fmliveswitchLogConfigurationInitializing;
        /** @hidden */
        static fmliveswitchLogConfigurationInitialize(): void;
    }
}
declare namespace fm.liveswitch {
    class LogLevelWrapper {
        getTypeString(): string;
        /** @hidden */
        private _value;
        constructor(value: fm.liveswitch.LogLevel);
        toString(): string;
    }
}
declare namespace fm.liveswitch {
    /**
    Class to hold a long value passed by reference.
    */
    class LongHolder {
        getTypeString(): string;
        /** @hidden */
        private _value;
        private fmliveswitchLongHolderInit;
        /**
        Initializes a new instance of the [[fm.liveswitch.longHolder]] class.
        */
        constructor();
        /**
        Initializes a new instance of the [[fm.liveswitch.longHolder]] class.
        @param value The value.
        */
        constructor(value: number);
        /**
        Gets the value.
        */
        getValue(): number;
        /**
        Sets the value.
        */
        setValue(value: number): void;
    }
}
declare namespace fm.liveswitch {
    /**
    An implementation of a JSON provider that does nothing.
    */
    class NullJsonProvider extends fm.liveswitch.JsonProvider {
        getTypeString(): string;
        constructor();
        /**
        Deserializes a value from a JSON string.
        @param valueJson The JSON string to deserialize.
        @return
                    The deserialized value.
            
        */
        deserialize<T>(valueJson: string): T;
        /**
        Serializes a value to a JSON string.
        @param value The value to serialize.
        @return
                    The serialized JSON string.
            
        */
        serialize<T>(value: T): string;
    }
}
declare namespace fm.liveswitch {
    /**
    An implementation of a logging provider that does nothing.
    */
    class NullLogProvider extends fm.liveswitch.LogProvider {
        getTypeString(): string;
        constructor();
        /**
        Logs a message at the specified log level.
        @param logEvent The log event details.
        */
        protected doLog(logEvent: fm.liveswitch.LogEvent): void;
    }
}
declare namespace fm.liveswitch {
    /**
    A data buffer pool.
    */
    class DataBufferPool implements fm.liveswitch.IDataBufferPool {
        getTypeString(): string;
        /** @hidden */
        private __blockSize;
        /** @hidden */
        private __pools;
        /** @hidden */
        private __traceStatistics;
        /** @hidden */
        private _disabled;
        /** @hidden */
        private _enableStatistics;
        /** @hidden */
        private _log;
        /** @hidden */
        private _statistics;
        /** @hidden */
        private static fm_liveswitch_DataBufferPool___singleton;
        /** @hidden */
        private static fm_liveswitch_DataBufferPool___singletonLock;
        private fmliveswitchDataBufferPoolInit;
        /**
        Initializes a new instance of the [[fm.liveswitch.dataBufferPool]] class.
        */
        constructor();
        /**
        Initializes a new instance of the [[fm.liveswitch.dataBufferPool]] class.
        @param tag The tag for stats output.
        */
        constructor(tag: string);
        /**
        Gets the singleton instance.
        */
        static getInstance(): fm.liveswitch.DataBufferPool;
        /**
        Gets a value indicating whether DataBuffer pooling is supported on this platform.
        */
        static getIsSupported(): boolean;
        /**
        Get a data buffer pool tracer for a specific tag using the default pool.
        @param tag The tag to log to.
        @return A tracer that will associate stats with the type.
        */
        static getTracer(tag: string): fm.liveswitch.DataBufferPoolTracer;
        /**
        Get a data buffer pool tracer for a specific tag and pool.
        @param tag The tag to log to.
        @param pool The underlying pool.
        @return A tracer that will associate stats with the type.
        */
        static getTracer(tag: string, pool: fm.liveswitch.DataBufferPool): fm.liveswitch.DataBufferPoolTracer;
        /**
        Get a data buffer pool tracer for a specific tag using the default pool. The tag is taken from the class namespace and name.
        @param type The type to use as the tag.
        @return A tracer that will associate stats with the tag.
        */
        static getTracer(type: fm.liveswitch.Type): fm.liveswitch.DataBufferPoolTracer;
        /**
        Get a data buffer pool tracer for a specific tag and pool. The tag is taken from the class namespace and name.
        @param type The type to use as the tag.
        @param pool The underlying pool.
        @return A tracer that will associate stats with the tag.
        */
        static getTracer(type: fm.liveswitch.Type, pool: fm.liveswitch.DataBufferPool): fm.liveswitch.DataBufferPoolTracer;
        /** @hidden */
        private createStack;
        /** @hidden */
        private createTraceStatistics;
        /** @hidden */
        private doTraceTake;
        /**
        Gets the block size.
        */
        getBlockSize(): number;
        /**
        Gets whether the pool is disabled. If disabled, each call to take a buffer will result in a new allocation.
        */
        getDisabled(): boolean;
        /**
        Gets whether to enable statistics.
        */
        getEnableStatistics(): boolean;
        /** @hidden */
        getOrAddTraceStatistics(tag: string): fm.liveswitch.PoolStatistics;
        /**
        Gets the pool usage statistics.
        */
        getStatistics(): fm.liveswitch.PoolStatistics;
        /**
        Gets all tagged pool usage statistics.
        */
        getTraceStatistics(): fm.liveswitch.PoolStatistics[];
        /**
        Gets pool usage statistics for a specific tag.
        @param tag The tag.
        */
        getTraceStatistics(tag: string): fm.liveswitch.PoolStatistics;
        /**
        Gets pool usage statistics for a specific tag.
        @param type The type to use as the tag.
        */
        getTraceStatistics(type: fm.liveswitch.Type): fm.liveswitch.PoolStatistics;
        /** @hidden */
        private padToBlock;
        /** @hidden */
        returnBuffer(buffer: fm.liveswitch.DataBufferPooled, tag: string): void;
        /** @hidden */
        setBlockSize(value: number): void;
        /**
        Sets whether the pool is disabled. If disabled, each call to take a buffer will result in a new allocation.
        */
        setDisabled(value: boolean): void;
        /**
        Sets whether to enable statistics.
        */
        setEnableStatistics(value: boolean): void;
        /** @hidden */
        private setStatistics;
        /**
        Takes a buffer from the pool.
        @param size The number of bytes needed.
        */
        take(size: number): fm.liveswitch.DataBuffer;
        /**
        Takes a buffer from the pool.
        @param size The number of bytes needed.
        @param littleEndian Whether the data buffer should be little-endian.
        */
        take(size: number, littleEndian: boolean): fm.liveswitch.DataBuffer;
        /**
        Takes a buffer from the pool.
        @param size The number of bytes needed.
        @param littleEndian Whether the data buffer should be little-endian.
        @param clearBytes Whether to clear the data buffer.
        */
        take(size: number, littleEndian: boolean, clearBytes: boolean): fm.liveswitch.DataBuffer;
        /** @hidden */
        traceTake(size: number, littleEndian: boolean, clearBytes: boolean, tag: string): fm.liveswitch.DataBuffer;
        /** @hidden */
        traceTake(size: number, littleEndian: boolean, tag: string): fm.liveswitch.DataBuffer;
        /** @hidden */
        traceTake(size: number, tag: string): fm.liveswitch.DataBuffer;
        /** @hidden */
        private static __fmliveswitchDataBufferPoolInitialized;
        /** @hidden */
        private static __fmliveswitchDataBufferPoolInitializing;
        /** @hidden */
        static fmliveswitchDataBufferPoolInitialize(): void;
    }
}
declare namespace fm.liveswitch {
    /**
    Pool statistics.
    */
    class PoolStatistics {
        getTypeString(): string;
        /** @hidden */
        __creates: fm.liveswitch.AtomicLong;
        /** @hidden */
        __hits: fm.liveswitch.AtomicLong;
        /** @hidden */
        __misses: fm.liveswitch.AtomicLong;
        /** @hidden */
        __paddingWasted: fm.liveswitch.AtomicLong;
        /** @hidden */
        __pendingPoolSize: fm.liveswitch.AtomicLong;
        /** @hidden */
        __returnedSize: fm.liveswitch.AtomicLong;
        /** @hidden */
        __takenSize: fm.liveswitch.AtomicLong;
        /** @hidden */
        __totalPoolSize: fm.liveswitch.AtomicLong;
        /** @hidden */
        private _tag;
        /** @hidden */
        constructor(tag: string);
        /**
        Gets the number of pools in use.
        */
        getActivePools(): number;
        /**
        Gets the percentage of cache hits.
        */
        getHitPercentage(): number;
        /**
        Gets the percentage of cache misses.
        */
        getMissPercentage(): number;
        /**
        Gets the amount of buffer padding that is unused for caller's requested buffers.
        */
        getPaddingWasted(): number;
        /**
        Gets the total size of all buffers currently in the pool.
        */
        getPendingPoolSize(): number;
        /**
        Gets the percentage of items returned to the pool.
        */
        getReturnPercentage(): number;
        /**
        Gets the tag.
        */
        getTag(): string;
        /**
        Gets the total calls to obtain a DataBuffer.
        */
        getTotalCalls(): number;
        /**
        Gets the total pools created.
        */
        getTotalPools(): number;
        /**
        Gets the total size of all buffers allocated in the pool.
        */
        getTotalPoolSize(): number;
        /** @hidden */
        private setTag;
        /**
        Overriden ToString
        */
        toString(): string;
    }
}
declare namespace fm.liveswitch {
    class FutureStateWrapper {
        getTypeString(): string;
        /** @hidden */
        private _value;
        constructor(value: fm.liveswitch.FutureState);
        toString(): string;
    }
}
declare namespace fm.liveswitch {
    /**
    Class to hold a short value passed by reference.
    */
    class ShortHolder {
        getTypeString(): string;
        /** @hidden */
        private _value;
        private fmliveswitchShortHolderInit;
        /**
        Initializes a new instance of the [[fm.liveswitch.shortHolder]] class.
        */
        constructor();
        /**
        Initializes a new instance of the [[fm.liveswitch.shortHolder]] class.
        @param value The value.
        */
        constructor(value: number);
        /**
        Gets the value.
        */
        getValue(): number;
        /**
        Sets the value.
        */
        setValue(value: number): void;
    }
}
declare namespace fm.liveswitch {
    /**
    Encapsulates useful sorting utilities.
    */
    class Sort {
        getTypeString(): string;
        constructor();
        /** @hidden */
        private static doQuickSort;
        /** @hidden */
        private static partition;
        /**
        Sorts an array using the in-place quick-sort algorithm.
        @param array The array of elements.
        @param comparer The function used to compare elements in the array -
                    should return less than 0 if item 1 is less than item 2 (item 1 should appear
                    before item 2), 0 if the items are equal, or more than 0 is item 1 is greater
                    than item 2 (item 1 should appear after item 2).
        */
        static quickSort<T>(array: Array<T>, comparer: fm.liveswitch.IFunction2<T, T, fm.liveswitch.CompareResult>): void;
        /** @hidden */
        private static swap;
    }
}
declare namespace fm.liveswitch {
    /**
    Utility class for splitting strings.
    */
    class Splitter {
        getTypeString(): string;
        constructor();
        /**
        Splits a string using a given delimiter.
        @param str The string.
        @param delimiter The delimiter.
        */
        static split(str: string, delimiter: string): string[];
    }
}
declare namespace fm.liveswitch {
    /**
    Contains methods for string manipulation.
    */
    class StringAssistant {
        getTypeString(): string;
        constructor();
        /**

        @param s The s.
        */
        static isNullOrWhiteSpace(s: string): boolean;
        /**
        Creates a subarray from an existing array.
        @param array The source array.
        @param offset The offset into the source array.
        @return The subarray.
        */
        static subArray(array: string[], offset: number): string[];
        /**
        Creates a subarray from an existing array.
        @param array The source array.
        @param offset The offset into the source array.
        @param count The number of elements to copy into the subarray.
        @return The subarray.
        */
        static subArray(array: string[], offset: number, count: number): string[];
    }
}
declare namespace fm.liveswitch {
    /**
    Simple log provider that writes to a local string builder.
    */
    class TextLogProvider extends fm.liveswitch.LogProvider {
        getTypeString(): string;
        /** @hidden */
        private __callback;
        /** @hidden */
        private __text;
        /** @hidden */
        private __textLock;
        /**
        Initializes a new instance of the [[fm.liveswitch.textLogProvider]] class using [[fm.liveswitch.logLevel.Info]].
        */
        constructor();
        /**
        Initializes a new instance of the [[fm.liveswitch.textLogProvider]] class.
        @param level The log level.
        */
        constructor(level: fm.liveswitch.LogLevel);
        /**
        Clears all text from the log and returns the former contents.
        */
        clear(): string;
        /**
        Logs a message at the specified log level.
        @param logEvent The log event details.
        */
        protected doLog(logEvent: fm.liveswitch.LogEvent): void;
        /**
        Gets a callback to invoke whenever text is written to the log.
        */
        getCallback(): fm.liveswitch.IAction1<string>;
        /**
        Gets the logged text.
        */
        getText(): string;
        /**
        Sets a callback to invoke whenever text is written to the log.
        */
        setCallback(value: fm.liveswitch.IAction1<string>): void;
        /** @hidden */
        private writeLine;
    }
}
declare namespace fm.liveswitch {
    /**
    Throws exceptions on a separate thread.
    */
    class Unhandled {
        getTypeString(): string;
        constructor();
        /**
        Logs an unhandled exception.
        @param ex The exception to throw.
        @param source The source of the exception.
        */
        static logException(ex: fm.liveswitch.Exception, source: string): void;
    }
}
declare namespace fm.liveswitch {
    /**
    Arguments for an unhandled exception.
    */
    class UnhandledExceptionArgs {
        getTypeString(): string;
        /** @hidden */
        private __exception;
        /** @hidden */
        private _handled;
        private fmliveswitchUnhandledExceptionArgsInit;
        /**
        Initializes a new instance of the [[fm.liveswitch.unhandledExceptionArgs]] class.
        @param exception The exception.
        */
        constructor(exception: fm.liveswitch.Exception);
        /**
        Gets the unhandled exception.
        */
        getException(): fm.liveswitch.Exception;
        /**
        Gets whether the exception has been appropriately handled. If set to `true`, then the exception will not be thrown.
        */
        getHandled(): boolean;
        /**
        Sets whether the exception has been appropriately handled. If set to `true`, then the exception will not be thrown.
        */
        setHandled(value: boolean): void;
    }
}
declare namespace fm.liveswitch {
    /**
    UTF-8 encoding/decoding utility.
    */
    class Utf8 {
        getTypeString(): string;
        constructor();
        /**
        Decodes a UTF-8 data buffer to a string.
        @param buffer The input byte array.
        */
        static decode(buffer: fm.liveswitch.DataBuffer): string;
        /**
        Decodes a UTF-8 byte array to a string.
        @param input The input byte array.
        */
        static decode(input: Uint8Array): string;
        /**
        Decodes a UTF-8 byte array to a string.
        @param input The input byte array.
        @param index The index to start reading.
        @param length The length.
        */
        static decode(input: Uint8Array, index: number, length: number): string;
        /**
        Encodes a string to a UTF-8 byte array.
        @param input The input string.
        */
        static encode(input: string): Uint8Array;
        /**
        Gets the number of bytes that would be returned by a call to encode.
        @param input The input string.
        */
        static getByteCount(input: string): number;
    }
}
declare namespace fm.liveswitch {
    /** @hidden */
    class WebSocketSendState {
        getTypeString(): string;
        /** @hidden */
        private _requestBytes;
        /** @hidden */
        private _sendArgs;
        constructor();
        getRequestBytes(): Uint8Array;
        getSendArgs(): fm.liveswitch.WebSocketSendArgs;
        setRequestBytes(value: Uint8Array): void;
        setSendArgs(value: fm.liveswitch.WebSocketSendArgs): void;
    }
}
declare namespace fm.liveswitch {
    /**
    Contract for an implementation of the WebSocket protocol v8.
    */
    interface IWebSocket {
        close(): void;
        close(closeArgs: fm.liveswitch.WebSocketCloseArgs): void;
        getBufferedAmount(): number;
        getIsOpen(): boolean;
        getSecure(): boolean;
        open(openArgs: fm.liveswitch.WebSocketOpenArgs): void;
        send(sendArgs: fm.liveswitch.WebSocketSendArgs): void;
    }
}
declare namespace fm.liveswitch {
    /**
    Close arguments for the [[fm.liveswitch.webSocket]] class.
    */
    class WebSocketCloseArgs extends fm.liveswitch.Dynamic {
        getTypeString(): string;
        /** @hidden */
        private _onComplete;
        /** @hidden */
        private _reason;
        /** @hidden */
        private _statusCode;
        /**
        Creates a new instance of [[fm.liveswitch.webSocketCloseArgs]] with default values.
        */
        constructor();
        /**
        Gets the callback to execute when the connection is closed.
        */
        getOnComplete(): fm.liveswitch.IAction1<fm.liveswitch.WebSocketCloseCompleteArgs>;
        /**
        Gets the reason to send with the close frame.
        */
        getReason(): string;
        /**
        Gets the status code to send with the close frame.
        */
        getStatusCode(): fm.liveswitch.WebSocketStatusCode;
        /**
        Sets the callback to execute when the connection is closed.
        */
        setOnComplete(value: fm.liveswitch.IAction1<fm.liveswitch.WebSocketCloseCompleteArgs>): void;
        /**
        Sets the reason to send with the close frame.
        */
        setReason(value: string): void;
        /**
        Sets the status code to send with the close frame.
        */
        setStatusCode(value: fm.liveswitch.WebSocketStatusCode): void;
    }
}
declare namespace fm.liveswitch {
    /**
    Arguments for [[fm.liveswitch.webSocketCloseArgs.onComplete]].
    */
    class WebSocketCloseCompleteArgs extends fm.liveswitch.Dynamic {
        getTypeString(): string;
        /** @hidden */
        private _closeArgs;
        /** @hidden */
        private _reason;
        /** @hidden */
        private _statusCode;
        constructor();
        /**
        Gets the original arguments passed to the close method.
        */
        getCloseArgs(): fm.liveswitch.WebSocketCloseArgs;
        /**
        Gets the reason given for closing the connection.
        */
        getReason(): string;
        /**
        Gets the status code associated with the close operation.
        */
        getStatusCode(): fm.liveswitch.WebSocketStatusCode;
        /**
        Sets the original arguments passed to the close method.
        */
        setCloseArgs(value: fm.liveswitch.WebSocketCloseArgs): void;
        /**
        Sets the reason given for closing the connection.
        */
        setReason(value: string): void;
        /**
        Sets the status code associated with the close operation.
        */
        setStatusCode(value: fm.liveswitch.WebSocketStatusCode): void;
    }
}
declare namespace fm.liveswitch {
    /**
    Open arguments for the [[fm.liveswitch.webSocket]] class.
    */
    class WebSocketOpenArgs extends fm.liveswitch.Dynamic {
        getTypeString(): string;
        /** @hidden */
        private _handshakeTimeout;
        /** @hidden */
        private _headers;
        /** @hidden */
        private _onFailure;
        /** @hidden */
        private _onReceive;
        /** @hidden */
        private _onRequestCreated;
        /** @hidden */
        private _onResponseReceived;
        /** @hidden */
        private _onStreamFailure;
        /** @hidden */
        private _onSuccess;
        /** @hidden */
        private _sender;
        /** @hidden */
        private _streamTimeout;
        private fmliveswitchWebSocketOpenArgsInit;
        /**
        Creates a new instance of
        */
        constructor();
        /**
        Gets the timeout for the handshake (in ms).
        */
        getHandshakeTimeout(): number;
        /**
        Gets headers to send with the handshake request.
        */
        getHeaders(): fm.liveswitch.NameValueCollection;
        /**
        Gets the callback to invoke when a connection could not be established.
        */
        getOnFailure(): fm.liveswitch.IAction1<fm.liveswitch.WebSocketOpenFailureArgs>;
        /**
        Gets the callback to invoke when a message is received.
        */
        getOnReceive(): fm.liveswitch.IAction1<fm.liveswitch.WebSocketReceiveArgs>;
        /**
        Gets the callback to invoke before the handshake request is sent.
        */
        getOnRequestCreated(): fm.liveswitch.IAction1<fm.liveswitch.HttpRequestCreatedArgs>;
        /**
        Gets the callback to invoke after the handshake response is received.
        */
        getOnResponseReceived(): fm.liveswitch.IAction1<fm.liveswitch.HttpResponseReceivedArgs>;
        /**
        Gets the callback to invoke when a successful connection breaks down.
        */
        getOnStreamFailure(): fm.liveswitch.IAction1<fm.liveswitch.WebSocketStreamFailureArgs>;
        /**
        Gets the callback to invoke when a successful connection has been established.
        */
        getOnSuccess(): fm.liveswitch.IAction1<fm.liveswitch.WebSocketOpenSuccessArgs>;
        /**
        Gets the sender of the request.
        */
        getSender(): Object;
        /**
        Gets the timeout for the stream (in ms).
        */
        getStreamTimeout(): number;
        /**
        Sets the timeout for the handshake (in ms).
        */
        setHandshakeTimeout(value: number): void;
        /**
        Sets headers to send with the handshake request.
        */
        setHeaders(value: fm.liveswitch.NameValueCollection): void;
        /**
        Sets the callback to invoke when a connection could not be established.
        */
        setOnFailure(value: fm.liveswitch.IAction1<fm.liveswitch.WebSocketOpenFailureArgs>): void;
        /**
        Sets the callback to invoke when a message is received.
        */
        setOnReceive(value: fm.liveswitch.IAction1<fm.liveswitch.WebSocketReceiveArgs>): void;
        /**
        Sets the callback to invoke before the handshake request is sent.
        */
        setOnRequestCreated(value: fm.liveswitch.IAction1<fm.liveswitch.HttpRequestCreatedArgs>): void;
        /**
        Sets the callback to invoke after the handshake response is received.
        */
        setOnResponseReceived(value: fm.liveswitch.IAction1<fm.liveswitch.HttpResponseReceivedArgs>): void;
        /**
        Sets the callback to invoke when a successful connection breaks down.
        */
        setOnStreamFailure(value: fm.liveswitch.IAction1<fm.liveswitch.WebSocketStreamFailureArgs>): void;
        /**
        Sets the callback to invoke when a successful connection has been established.
        */
        setOnSuccess(value: fm.liveswitch.IAction1<fm.liveswitch.WebSocketOpenSuccessArgs>): void;
        /**
        Sets the sender of the request.
        */
        setSender(value: Object): void;
        /**
        Sets the timeout for the stream (in ms).
        */
        setStreamTimeout(value: number): void;
    }
}
declare namespace fm.liveswitch {
    /**
    Arguments for [[fm.liveswitch.webSocketOpenArgs.onFailure]].
    */
    class WebSocketOpenFailureArgs extends fm.liveswitch.Dynamic {
        getTypeString(): string;
        /** @hidden */
        private _exception;
        /** @hidden */
        private _openArgs;
        /** @hidden */
        private _statusCode;
        constructor();
        /**
        Gets the exception generated while connecting.
        */
        getException(): fm.liveswitch.Exception;
        /**
        Gets the original arguments passed to the open method.
        */
        getOpenArgs(): fm.liveswitch.WebSocketOpenArgs;
        /**
        Gets the status code associated with the failure to connect.
        */
        getStatusCode(): fm.liveswitch.WebSocketStatusCode;
        /**
        Sets the exception generated while connecting.
        */
        setException(value: fm.liveswitch.Exception): void;
        /**
        Sets the original arguments passed to the open method.
        */
        setOpenArgs(value: fm.liveswitch.WebSocketOpenArgs): void;
        /**
        Sets the status code associated with the failure to connect.
        */
        setStatusCode(value: fm.liveswitch.WebSocketStatusCode): void;
    }
}
declare namespace fm.liveswitch {
    /**
    Arguments for [[fm.liveswitch.webSocketOpenArgs.onSuccess]].
    */
    class WebSocketOpenSuccessArgs extends fm.liveswitch.Dynamic {
        getTypeString(): string;
        /** @hidden */
        private _openArgs;
        constructor();
        /**
        Gets the original arguments passed to the open method.
        */
        getOpenArgs(): fm.liveswitch.WebSocketOpenArgs;
        /**
        Sets the original arguments passed to the open method.
        */
        setOpenArgs(value: fm.liveswitch.WebSocketOpenArgs): void;
    }
}
declare namespace fm.liveswitch {
    /**
    Arguments for [[fm.liveswitch.webSocketOpenArgs.onReceive]].
    */
    class WebSocketReceiveArgs extends fm.liveswitch.Dynamic {
        getTypeString(): string;
        /** @hidden */
        private _binaryMessage;
        /** @hidden */
        private _openArgs;
        /** @hidden */
        private _textMessage;
        constructor();
        /**
        Gets the message received from the server as binary data.
        */
        getBinaryMessage(): Uint8Array;
        /**
        Gets whether or not the received message is text.
        */
        getIsText(): boolean;
        /**
        Gets the original arguments passed to the open method.
        */
        getOpenArgs(): fm.liveswitch.WebSocketOpenArgs;
        /**
        Gets the message received from the server as text data.
        */
        getTextMessage(): string;
        /**
        Sets the message received from the server as binary data.
        */
        setBinaryMessage(value: Uint8Array): void;
        /**
        Sets the original arguments passed to the open method.
        */
        setOpenArgs(value: fm.liveswitch.WebSocketOpenArgs): void;
        /**
        Sets the message received from the server as text data.
        */
        setTextMessage(value: string): void;
    }
}
declare namespace fm.liveswitch {
    /** @hidden */
    class WebSocketRequest {
        getTypeString(): string;
        /** @hidden */
        private _args;
        /** @hidden */
        private _callback;
        constructor();
        getArgs(): fm.liveswitch.HttpRequestArgs;
        getCallback(): fm.liveswitch.IAction1<fm.liveswitch.HttpResponseArgs>;
        setArgs(value: fm.liveswitch.HttpRequestArgs): void;
        setCallback(value: fm.liveswitch.IAction1<fm.liveswitch.HttpResponseArgs>): void;
    }
}
declare namespace fm.liveswitch {
    /**
    Send arguments for the [[fm.liveswitch.webSocket]] class.
    */
    class WebSocketSendArgs extends fm.liveswitch.Dynamic {
        getTypeString(): string;
        /** @hidden */
        private _binaryMessage;
        /** @hidden */
        private _textMessage;
        /** @hidden */
        private _timeout;
        private fmliveswitchWebSocketSendArgsInit;
        /**
        Creates a new [[fm.liveswitch.webSocketSendArgs]] instance.
        */
        constructor();
        /**
        Gets the message to send as binary data.
        */
        getBinaryMessage(): Uint8Array;
        /** @hidden */
        getIsText(): boolean;
        /**
        Gets the message to send as text data.
        */
        getTextMessage(): string;
        /**
        Gets the timeout for the request (in ms).
        */
        getTimeout(): number;
        /**
        Sets the message to send as binary data.
        */
        setBinaryMessage(value: Uint8Array): void;
        /**
        Sets the message to send as text data.
        */
        setTextMessage(value: string): void;
        /**
        Sets the timeout for the request (in ms).
        */
        setTimeout(value: number): void;
    }
}
declare namespace fm.liveswitch {
    class WebSocketStatusCodeWrapper {
        getTypeString(): string;
        /** @hidden */
        private _value;
        constructor(value: fm.liveswitch.WebSocketStatusCode);
        toString(): string;
    }
}
declare namespace fm.liveswitch {
    /**
    Arguments for [[fm.liveswitch.webSocketOpenArgs.onStreamFailure]].
    */
    class WebSocketStreamFailureArgs extends fm.liveswitch.Dynamic {
        getTypeString(): string;
        /** @hidden */
        private _exception;
        /** @hidden */
        private _openArgs;
        /** @hidden */
        private _statusCode;
        constructor();
        /**
        Gets the exception generated by the active connection.
        */
        getException(): fm.liveswitch.Exception;
        /**
        Gets the original arguments passed to the open method.
        */
        getOpenArgs(): fm.liveswitch.WebSocketOpenArgs;
        /**
        Gets the status code associated with the stream failure.
        */
        getStatusCode(): fm.liveswitch.WebSocketStatusCode;
        /**
        Sets the exception generated by the active connection.
        */
        setException(value: fm.liveswitch.Exception): void;
        /**
        Sets the original arguments passed to the open method.
        */
        setOpenArgs(value: fm.liveswitch.WebSocketOpenArgs): void;
        /**
        Sets the status code associated with the stream failure.
        */
        setStatusCode(value: fm.liveswitch.WebSocketStatusCode): void;
    }
}
declare namespace fm.liveswitch {
    /**
    Base class that defines methods for transferring content over the WebSocket protocol.
    */
    abstract class WebSocketTransfer {
        getTypeString(): string;
        /** @hidden */
        private __url;
        /** @hidden */
        private _handshakeTimeout;
        /** @hidden */
        private _onOpenFailure;
        /** @hidden */
        private _onOpenSuccess;
        /** @hidden */
        private _onRequestCreated;
        /** @hidden */
        private _onResponseReceived;
        /** @hidden */
        private _onStreamFailure;
        /** @hidden */
        private _sender;
        /** @hidden */
        private _streamTimeout;
        private fmliveswitchWebSocketTransferInit;
        /**
        Initializes a new instance of the [[fm.liveswitch.webSocketTransfer]] class.
        @param url The URL.
        */
        constructor(url: string);
        /**
        Gets the timeout for the initial handshake (in ms).
        */
        getHandshakeTimeout(): number;
        /**
        Gets the callback to invoke if the handshake fails.
        */
        getOnOpenFailure(): fm.liveswitch.IAction1<fm.liveswitch.WebSocketOpenFailureArgs>;
        /**
        Gets the callback to invoke if the handshake succeeds.
        */
        getOnOpenSuccess(): fm.liveswitch.IAction1<fm.liveswitch.WebSocketOpenSuccessArgs>;
        /**
        Gets the callback to invoke when the handshake request is created.
        */
        getOnRequestCreated(): fm.liveswitch.IAction1<fm.liveswitch.HttpRequestCreatedArgs>;
        /**
        Gets the callback to invoke when the handshake response is received.
        */
        getOnResponseReceived(): fm.liveswitch.IAction1<fm.liveswitch.HttpResponseReceivedArgs>;
        /**
        Gets the callback to invoke if the stream errors out.
        */
        getOnStreamFailure(): fm.liveswitch.IAction1<fm.liveswitch.WebSocketStreamFailureArgs>;
        /**
        Gets the sender of the messages.
        */
        getSender(): Object;
        /**
        Gets the timeout for the stream (in ms).
        */
        getStreamTimeout(): number;
        /**
        Gets the URL.
        */
        getUrl(): string;
        /**
        Opens the socket.
        @param headers The headers to pass in with the initial handshake.
        */
        abstract open(headers: fm.liveswitch.NameValueCollection): void;
        /**
        Sends a request synchronously.
        @param requestArgs The request parameters.
        @return The response parameters.
        */
        abstract send(requestArgs: fm.liveswitch.HttpRequestArgs): fm.liveswitch.HttpResponseArgs;
        /**
        Sends a request asynchronously.
        @param requestArgs The request parameters.
        @param callback The callback to execute with the resulting response.
        */
        abstract sendAsync(requestArgs: fm.liveswitch.HttpRequestArgs, callback: fm.liveswitch.IAction1<fm.liveswitch.HttpResponseArgs>): void;
        /**
        Sets the timeout for the initial handshake (in ms).
        */
        setHandshakeTimeout(value: number): void;
        /**
        Sets the callback to invoke if the handshake fails.
        */
        setOnOpenFailure(value: fm.liveswitch.IAction1<fm.liveswitch.WebSocketOpenFailureArgs>): void;
        /**
        Sets the callback to invoke if the handshake succeeds.
        */
        setOnOpenSuccess(value: fm.liveswitch.IAction1<fm.liveswitch.WebSocketOpenSuccessArgs>): void;
        /**
        Sets the callback to invoke when the handshake request is created.
        */
        setOnRequestCreated(value: fm.liveswitch.IAction1<fm.liveswitch.HttpRequestCreatedArgs>): void;
        /**
        Sets the callback to invoke when the handshake response is received.
        */
        setOnResponseReceived(value: fm.liveswitch.IAction1<fm.liveswitch.HttpResponseReceivedArgs>): void;
        /**
        Sets the callback to invoke if the stream errors out.
        */
        setOnStreamFailure(value: fm.liveswitch.IAction1<fm.liveswitch.WebSocketStreamFailureArgs>): void;
        /**
        Sets the sender of the messages.
        */
        setSender(value: Object): void;
        /**
        Sets the timeout for the stream (in ms).
        */
        setStreamTimeout(value: number): void;
        /**
        Sets the URL.
        */
        setUrl(value: string): void;
        /**
        Releases any resources and shuts down.
        */
        abstract shutdown(): void;
    }
}
declare namespace fm.liveswitch {
    /**
    Creates implementations of [[fm.liveswitch.webSocketWebRequestTransfer]].
    */
    class WebSocketTransferFactory {
        getTypeString(): string;
        /** @hidden */
        private static fm_liveswitch_WebSocketTransferFactory__createWebSocketTransfer;
        constructor();
        /** @hidden */
        static defaultCreateWebSocketTransfer(url: string): fm.liveswitch.WebSocketTransfer;
        /**
        Gets the callback that creates a WebSocket-based transfer class.
        */
        static getCreateWebSocketTransfer(): fm.liveswitch.IFunction1<string, fm.liveswitch.WebSocketTransfer>;
        /**
        Gets an instance of the WebSocket-based transfer class.
        */
        static getWebSocketTransfer(url: string): fm.liveswitch.WebSocketTransfer;
        /**
        Sets the callback that creates a WebSocket-based transfer class.
        */
        static setCreateWebSocketTransfer(value: fm.liveswitch.IFunction1<string, fm.liveswitch.WebSocketTransfer>): void;
    }
}
declare namespace fm.liveswitch {
    /**
    Defines methods for transferring messages using the WebSocket protocol.
    */
    class WebSocketWebRequestTransfer extends fm.liveswitch.WebSocketTransfer {
        getTypeString(): string;
        /** @hidden */
        private _activeRequest;
        /** @hidden */
        private _webSocket;
        /**
        Creates a new instance of [[fm.liveswitch.webSocketWebRequestTransfer]].
        @param url The URL.
        */
        constructor(url: string);
        /** @hidden */
        private connectFailure;
        /** @hidden */
        private connectSuccess;
        /** @hidden */
        private getWebSocket;
        /**
        Opens the WebSocket connection.
        */
        open(headers: fm.liveswitch.NameValueCollection): void;
        /** @hidden */
        private receive;
        /**
        Sends a request synchronously.
        @param requestArgs The request parameters.
        @return The response parameters.
        */
        send(requestArgs: fm.liveswitch.HttpRequestArgs): fm.liveswitch.HttpResponseArgs;
        /**
        Sends a request asynchronously.
        @param requestArgs The request parameters.
        @param callback The callback to execute with the resulting response.
        */
        sendAsync(requestArgs: fm.liveswitch.HttpRequestArgs, callback: fm.liveswitch.IAction1<fm.liveswitch.HttpResponseArgs>): void;
        /** @hidden */
        private setWebSocket;
        /**
        Releases any resources and shuts down.
        */
        shutdown(): void;
        /** @hidden */
        private streamFailure;
    }
}
declare namespace fm.liveswitch {
    /**
    A media configuration.
    */
    abstract class MediaConfig<TConfig extends fm.liveswitch.MediaConfig<TConfig>> {
        getTypeString(): string;
        /** @hidden */
        private _clockRate;
        private fmliveswitchMediaConfigInit;
        /**
        Initializes a new instance of the [[fm.liveswitch.mediaConfig]] class.
        @param clockRate The clock rate.
        */
        constructor(clockRate: number);
        /**
        Gets the clock rate.
        */
        getClockRate(): number;
        /**
        Determines whether the specified configuration is equivalent.
        @param config The configuration.
        */
        isEquivalent(config: TConfig): boolean;
        /** @hidden */
        private setClockRate;
    }
}
declare namespace fm.liveswitch {
    /**
    An audio configuration.
    */
    class AudioConfig extends fm.liveswitch.MediaConfig<fm.liveswitch.AudioConfig> {
        getTypeString(): string;
        /** @hidden */
        private _channelCount;
        private fmliveswitchAudioConfigInit;
        /**
        Initializes a new instance of the [[fm.liveswitch.audioConfig]] class.
        @param clockRate The clock rate.
        @param channelCount The channel count.
        */
        constructor(clockRate: number, channelCount: number);
        /**
        Gets the channel count.
        */
        getChannelCount(): number;
        /**
        Determines whether the specified configuration is equivalent.
        @param config The configuration.
        */
        isEquivalent(config: fm.liveswitch.AudioConfig): boolean;
        /** @hidden */
        private setChannelCount;
        /**
        Returns a string that represents this instance.
        */
        toString(): string;
    }
}
declare namespace fm.liveswitch {
    /**
    Base stats.
    */
    abstract class BaseStats {
        getTypeString(): string;
        /** @hidden */
        private _id;
        /** @hidden */
        private _timestamp;
        constructor();
        /**
        Deserializes the properties.
        @param key The key.
        @param valueJson The value in JSON format.
        */
        protected deserializeProperties(key: string, valueJson: string): void;
        /**
        Gets the identifier of the object generating these stats.
        */
        getId(): string;
        /**
        Gets the timestamp when these stats were generated.
        */
        getTimestamp(): fm.liveswitch.DateTime;
        /**
        Serializes the properties.
        @param jsonObject The JSON object.
        */
        protected serializeProperties(jsonObject: fm.liveswitch.Hash<string, string>): void;
        /** @hidden */
        setId(value: string): void;
        /** @hidden */
        setTimestamp(value: fm.liveswitch.DateTime): void;
    }
}
declare namespace fm.liveswitch {
    /**
    A bitrate notification.
    */
    class BitrateNotification {
        getTypeString(): string;
        /** @hidden */
        private _bitrate;
        /** @hidden */
        private _mediaDescriptionId;
        /** @hidden */
        private _rtpStreamId;
        /** @hidden */
        private _synchronizationSource;
        private fmliveswitchBitrateNotificationInit;
        /**
        Initializes a new instance of the [[fm.liveswitch.bitrateNotification]] class.
        */
        constructor();
        /**
        Deserializes an instance from JSON.
        @param bitrateNotificationJson The instance in JSON format.
        @return The instance.
        */
        static fromJson(bitrateNotificationJson: string): fm.liveswitch.BitrateNotification;
        /**
        Deserializes an array from JSON.
        @param bitrateNotificationsJson The array in JSON format.
        @return The array.
        */
        static fromJsonArray(bitrateNotificationsJson: string): fm.liveswitch.BitrateNotification[];
        /**
        Serializes an instance to JSON.
        @param bitrateNotification The instance.
        @return The instance in JSON format.
        */
        static toJson(bitrateNotification: fm.liveswitch.BitrateNotification): string;
        /**
        Serializes an array to JSON.
        @param bitrateNotifications The array.
        @return The array in JSON format.
        */
        static toJsonArray(bitrateNotifications: fm.liveswitch.BitrateNotification[]): string;
        /**
        Deserializes a property from JSON.
        @param key The property key.
        @param valueJson The property value in JSON format.
        */
        protected deserializeProperty(key: string, valueJson: string): void;
        /**
        Gets the bitrate.
        */
        getBitrate(): number;
        /**
        Gets the media description ID.
        */
        getMediaDescriptionId(): string;
        /**
        Gets the RTP stream ID.
        */
        getRtpStreamId(): string;
        /**
        Gets the synchronization source.
        */
        getSynchronizationSource(): number;
        /**
        Serializes properties to JSON.
        @param jsonObject The JSON target.
        */
        protected serializeProperties(jsonObject: fm.liveswitch.Hash<string, string>): void;
        /**
        Sets the bitrate.
        */
        setBitrate(value: number): void;
        /**
        Sets the media description ID.
        */
        setMediaDescriptionId(value: string): void;
        /**
        Sets the RTP stream ID.
        */
        setRtpStreamId(value: string): void;
        /**
        Sets the synchronization source.
        */
        setSynchronizationSource(value: number): void;
        /**
        Serializes this instance to JSON.
        */
        toJson(): string;
    }
}
declare namespace fm.liveswitch {
    /**
    A bitrate request.
    */
    class BitrateRequest {
        getTypeString(): string;
        /** @hidden */
        private _bitrate;
        /** @hidden */
        private _mediaDescriptionId;
        /** @hidden */
        private _rtpStreamId;
        /** @hidden */
        private _senderSynchronizationSource;
        /** @hidden */
        private _synchronizationSource;
        private fmliveswitchBitrateRequestInit;
        /**
        Initializes a new instance of the [[fm.liveswitch.bitrateRequest]] class.
        */
        constructor();
        /**
        Deserializes an instance from JSON.
        @param bitrateRequestJson The instance in JSON format.
        @return The instance.
        */
        static fromJson(bitrateRequestJson: string): fm.liveswitch.BitrateRequest;
        /**
        Deserializes an array from JSON.
        @param bitrateRequestsJson The array in JSON format.
        @return The array.
        */
        static fromJsonArray(bitrateRequestsJson: string): fm.liveswitch.BitrateRequest[];
        /**
        Serializes an instance to JSON.
        @param bitrateRequest The instance.
        @return The instance in JSON format.
        */
        static toJson(bitrateRequest: fm.liveswitch.BitrateRequest): string;
        /**
        Serializes an array to JSON.
        @param bitrateRequests The array.
        @return The array in JSON format.
        */
        static toJsonArray(bitrateRequests: fm.liveswitch.BitrateRequest[]): string;
        /**
        Deserializes a property from JSON.
        @param key The property key.
        @param valueJson The property value in JSON format.
        */
        protected deserializeProperty(key: string, valueJson: string): void;
        /**
        Gets the bitrate.
        */
        getBitrate(): number;
        /**
        Gets the media description ID.
        */
        getMediaDescriptionId(): string;
        /**
        Gets the RTP stream ID.
        */
        getRtpStreamId(): string;
        /**
        Gets the sender synchronization source.
        */
        getSenderSynchronizationSource(): number;
        /**
        Gets the synchronization source.
        */
        getSynchronizationSource(): number;
        /**
        Serializes properties to JSON.
        @param jsonObject The JSON target.
        */
        protected serializeProperties(jsonObject: fm.liveswitch.Hash<string, string>): void;
        /**
        Sets the bitrate.
        */
        setBitrate(value: number): void;
        /**
        Sets the media description ID.
        */
        setMediaDescriptionId(value: string): void;
        /**
        Sets the RTP stream ID.
        */
        setRtpStreamId(value: string): void;
        /**
        Sets the sender synchronization source.
        */
        setSenderSynchronizationSource(value: number): void;
        /**
        Sets the synchronization source.
        */
        setSynchronizationSource(value: number): void;
        /**
        Serializes this instance to JSON.
        */
        toJson(): string;
    }
}
declare namespace fm.liveswitch {
    /**
    Information.
    */
    abstract class Info {
        getTypeString(): string;
        /** @hidden */
        private _id;
        constructor();
        /**
        Processes an array for an info.
        @param newValues The new values.
        @param oldValues The old values.
        @return The new values, if the new values are not equivalent to the old values; otherwise null.
        */
        static processArray<T extends fm.liveswitch.IEquivalent<T>>(newValues: T[], oldValues: T[]): T[];
        /**
        Processes a boolean for an info.
        @param newValue The new value.
        @param oldValue The old value.
        @return The new value, if the new value does not equal the old value; otherwise null.
        */
        static processBoolean(newValue: boolean, oldValue: boolean): boolean;
        /**
        Processes a boolean array for an info.
        @param newValues The new values.
        @param oldValues The old values.
        @return The new values, if the new values do not equal the old values; otherwise null.
        */
        static processBooleanArray(newValues: boolean[], oldValues: boolean[]): boolean[];
        /**
        Processes a double for an info.
        @param newValue The new value.
        @param oldValue The old value.
        @return The new value, if the new value does not equal the old value; otherwise null.
        */
        static processDouble(newValue: number, oldValue: number): number;
        /**
        Processes a float for an info.
        @param newValue The new value.
        @param oldValue The old value.
        @return The new value, if the new value does not equal the old value; otherwise null.
        */
        static processFloat(newValue: number, oldValue: number): number;
        /**
        Processes a float array for an info.
        @param newValues The new values.
        @param oldValues The old values.
        @return The new values, if the new values do not equal the old values; otherwise null.
        */
        static processFloatArray(newValues: number[], oldValues: number[]): number[];
        /**
        Processes an integer for an info.
        @param newValue The new value.
        @param oldValue The old value.
        @return The new value, if the new value does not equal the old value; otherwise null.
        */
        static processInteger(newValue: number, oldValue: number): number;
        /**
        Processes a integer array for an info.
        @param newValues The new values.
        @param oldValues The old values.
        @return The new values, if the new values do not equal the old values; otherwise null.
        */
        static processIntegerArray(newValues: number[], oldValues: number[]): number[];
        /**
        Processes a long for an info.
        @param newValue The new value.
        @param oldValue The old value.
        @return The new value, if the new value does not equal the old value; otherwise null.
        */
        static processLong(newValue: number, oldValue: number): number;
        /**
        Processes a long array for an info.
        @param newValues The new values.
        @param oldValues The old values.
        @return The new values, if the new values do not equal the old values; otherwise null.
        */
        static processLongArray(newValues: number[], oldValues: number[]): number[];
        /**
        Processes an object for an info.
        @param newValue The new value.
        @param oldValue The old value.
        @return The new value, if the new value does not equal the old value; otherwise null.
        */
        static processObject<T extends Object & fm.liveswitch.IEquivalent<T>>(newValue: T, oldValue: T): T;
        /**
        Processes a short for an info.
        @param newValue The new value.
        @param oldValue The old value.
        @return The new value, if the new value does not equal the old value; otherwise null.
        */
        static processShort(newValue: number, oldValue: number): number;
        /**
        Processes a short array for an info.
        @param newValues The new values.
        @param oldValues The old values.
        @return The new values, if the new values do not equal the old values; otherwise null.
        */
        static processShortArray(newValues: number[], oldValues: number[]): number[];
        /**
        Processes a string for an info.
        @param newValue The new value.
        @param oldValue The old value.
        @return The new value, if the new value does not equal the old value; otherwise null.
        */
        static processString(newValue: string, oldValue: string): string;
        /**
        Deserializes the properties.
        @param key The key.
        @param valueJson The value in JSON format.
        */
        protected deserializeProperties(key: string, valueJson: string): void;
        /**
        Gets the identifier.
        */
        getId(): string;
        /**
        Serializes the properties.
        @param jsonObject The JSON object.
        */
        protected serializeProperties(jsonObject: fm.liveswitch.Hash<string, string>): void;
        /**
        Sets the identifier.
        */
        setId(value: string): void;
    }
}
declare namespace fm.liveswitch {
    /**
    Candidate information.
    */
    class CandidateInfo extends fm.liveswitch.Info {
        getTypeString(): string;
        /** @hidden */
        private _ipAddress;
        /** @hidden */
        private _port;
        /** @hidden */
        private _priority;
        /** @hidden */
        private _protocol;
        /** @hidden */
        private _relatedIPAddress;
        /** @hidden */
        private _relatedPort;
        /** @hidden */
        private _relayProtocol;
        /** @hidden */
        private _type;
        private fmliveswitchCandidateInfoInit;
        /**
        Initializes a new instance of the [[fm.liveswitch.candidateInfo]] class.
        */
        constructor();
        constructor(stats: fm.liveswitch.CandidateStats, lastStats: fm.liveswitch.CandidateStats);
        /**
        Deserializes an instance from JSON.
        @param candidateReportJson The JSON.
        @return The deserialized instance.
        */
        static fromJson(candidateReportJson: string): fm.liveswitch.CandidateInfo;
        /**
        Deserializes an array from JSON.
        @param candidateReportsJson The JSON.
        @return The deserialized array.
        */
        static fromJsonArray(candidateReportsJson: string): fm.liveswitch.CandidateInfo[];
        /**
        Serializes an instance to JSON.
        @param candidateReport The instance.
        @return The serialized JSON.
        */
        static toJson(candidateReport: fm.liveswitch.CandidateInfo): string;
        /**
        Serializes an array to JSON.
        @param candidateReports The array.
        @return The serialized JSON.
        */
        static toJsonArray(candidateReports: fm.liveswitch.CandidateInfo[]): string;
        /**
        Deserializes the properties.
        @param key The key.
        @param valueJson The value in JSON format.
        */
        protected deserializeProperties(key: string, valueJson: string): void;
        /**
        Gets the candidate IP address.
        */
        getIPAddress(): string;
        /**
        Gets the candidate port.
        */
        getPort(): number;
        /**
        Gets the candidate priority.
        */
        getPriority(): number;
        /**
        Gets the candidate protocol.
        */
        getProtocol(): string;
        /**
        Gets the candidate related IP address.
        */
        getRelatedIPAddress(): string;
        /**
        Gets the candidate related port.
        */
        getRelatedPort(): number;
        /**
        Gets the candidate relay protocol.
        */
        getRelayProtocol(): string;
        /**
        Gets the candidate type.
        */
        getType(): string;
        /**
        Serializes the properties.
        @param jsonObject The JSON object.
        */
        protected serializeProperties(jsonObject: fm.liveswitch.Hash<string, string>): void;
        /**
        Sets the candidate IP address.
        */
        setIPAddress(value: string): void;
        /**
        Sets the candidate port.
        */
        setPort(value: number): void;
        /**
        Sets the candidate priority.
        */
        setPriority(value: number): void;
        /**
        Sets the candidate protocol.
        */
        setProtocol(value: string): void;
        /**
        Sets the candidate related IP address.
        */
        setRelatedIPAddress(value: string): void;
        /**
        Sets the candidate related port.
        */
        setRelatedPort(value: number): void;
        /**
        Sets the candidate relay protocol.
        */
        setRelayProtocol(value: string): void;
        /**
        Sets the candidate type.
        */
        setType(value: string): void;
        /**
        Serializes this instance to JSON.
        */
        toJson(): string;
    }
}
declare namespace fm.liveswitch {
    /**
    Candidate pair information.
    */
    class CandidatePairInfo extends fm.liveswitch.Info {
        getTypeString(): string;
        /** @hidden */
        private _localCandidateId;
        /** @hidden */
        private _nominated;
        /** @hidden */
        private _priority;
        /** @hidden */
        private _remoteCandidateId;
        /** @hidden */
        private _report;
        /** @hidden */
        private _state;
        private fmliveswitchCandidatePairInfoInit;
        /**
        Initializes a new instance of the [[fm.liveswitch.candidatePairInfo]] class.
        */
        constructor();
        constructor(stats: fm.liveswitch.CandidatePairStats, lastStats: fm.liveswitch.CandidatePairStats);
        /**
        Deserializes an instance from JSON.
        @param instanceJson The instance JSON.
        @return The deserialized instance.
        */
        static fromJson(instanceJson: string): fm.liveswitch.CandidatePairInfo;
        /**
        Derializes an array from JSON.
        @param arrayJson The array JSON.
        @return The deserialized array.
        */
        static fromJsonArray(arrayJson: string): fm.liveswitch.CandidatePairInfo[];
        /**
        Serializes an instance to JSON.
        @param instance The instance.
        @return The serialized instance JSON.
        */
        static toJson(instance: fm.liveswitch.CandidatePairInfo): string;
        /**
        Serializes an array to JSON.
        @param array The array.
        @return The serialized array JSON.
        */
        static toJsonArray(array: fm.liveswitch.CandidatePairInfo[]): string;
        /**
        Deserializes the properties.
        @param key The key.
        @param valueJson The value in JSON format.
        */
        protected deserializeProperties(key: string, valueJson: string): void;
        /**
        Gets the candidate pair's local candidate identifier.
        */
        getLocalCandidateId(): string;
        /**
        Gets whether the candidate pair is nominated.
        */
        getNominated(): boolean;
        /**
        Gets the candidate pair priority.
        */
        getPriority(): number;
        /**
        Gets the candidate pair's remote candidate identifier.
        */
        getRemoteCandidateId(): string;
        /**
        Gets whether the candidate pair report.
        */
        getReport(): fm.liveswitch.CandidatePairReport;
        /**
        Gets the candidate pair state.
        */
        getState(): string;
        /**
        Serializes the properties.
        @param jsonObject The JSON object.
        */
        protected serializeProperties(jsonObject: fm.liveswitch.Hash<string, string>): void;
        /**
        Sets the candidate pair's local candidate identifier.
        */
        setLocalCandidateId(value: string): void;
        /**
        Sets whether the candidate pair is nominated.
        */
        setNominated(value: boolean): void;
        /**
        Sets the candidate pair priority.
        */
        setPriority(value: number): void;
        /**
        Sets the candidate pair's remote candidate identifier.
        */
        setRemoteCandidateId(value: string): void;
        /**
        Sets whether the candidate pair report.
        */
        setReport(value: fm.liveswitch.CandidatePairReport): void;
        /**
        Sets the candidate pair state.
        */
        setState(value: string): void;
        /**
        Serializes this instance to JSON.
        */
        toJson(): string;
    }
}
declare namespace fm.liveswitch {
    class CandidatePairStateWrapper {
        getTypeString(): string;
        /** @hidden */
        private _value;
        constructor(value: fm.liveswitch.CandidatePairState);
        toString(): string;
    }
}
declare namespace fm.liveswitch {
    /**
    Candidate pair stats.
    */
    class CandidatePairStats extends fm.liveswitch.BaseStats implements fm.liveswitch.IEquivalent<fm.liveswitch.CandidatePairStats> {
        getTypeString(): string;
        /** @hidden */
        private _bytesReceived;
        /** @hidden */
        private _bytesSent;
        /** @hidden */
        private _consentRequestsReceived;
        /** @hidden */
        private _consentRequestsSent;
        /** @hidden */
        private _consentResponsesReceived;
        /** @hidden */
        private _consentResponsesSent;
        /** @hidden */
        private _currentRoundTripTime;
        /** @hidden */
        private _localCandidateId;
        /** @hidden */
        private _nominated;
        /** @hidden */
        private _priority;
        /** @hidden */
        private _remoteCandidateId;
        /** @hidden */
        private _requestsReceived;
        /** @hidden */
        private _requestsSent;
        /** @hidden */
        private _responsesReceived;
        /** @hidden */
        private _responsesSent;
        /** @hidden */
        private _state;
        /** @hidden */
        private _totalRoundTripTime;
        /** @hidden */
        private _transportId;
        private fmliveswitchCandidatePairStatsInit;
        /**
        Initializes a new instance of the [[fm.liveswitch.candidatePairStats]] class.
        */
        constructor();
        /**
        Derializes candidate pair stats from JSON.
        @param candidatePairJson The candidate pair's stats JSON.
        */
        static fromJson(candidatePairJson: string): fm.liveswitch.CandidatePairStats;
        /**
        Derializes an array of candidate pair stats from JSON.
        @param candidatePairsJson The candidate pairs' stats JSON.
        */
        static fromJsonArray(candidatePairsJson: string): fm.liveswitch.CandidatePairStats[];
        /**
        Serializes candidate pair stats to JSON.
        @param candidatePair The candidate pair's stats.
        */
        static toJson(candidatePair: fm.liveswitch.CandidatePairStats): string;
        /**
        Serializes an array of candidate pair stats to JSON.
        @param candidatePairs The candidate pairs' stats.
        */
        static toJsonArray(candidatePairs: fm.liveswitch.CandidatePairStats[]): string;
        /**
        Deserializes the properties.
        @param key The key.
        @param valueJson The value in JSON format.
        */
        protected deserializeProperties(key: string, valueJson: string): void;
        /**
        Gets the number of bytes received.
        */
        getBytesReceived(): number;
        /**
        Gets the number of bytes sent.
        */
        getBytesSent(): number;
        /**
        Gets the number of consent requests received.
        */
        getConsentRequestsReceived(): number;
        /**
        Gets the number of consent requests sent.
        */
        getConsentRequestsSent(): number;
        /**
        Gets the number of consent responses received.
        */
        getConsentResponsesReceived(): number;
        /**
        Gets the number of consent responses sent.
        */
        getConsentResponsesSent(): number;
        /**
        Gets the current round trip time in milliseconds.
        */
        getCurrentRoundTripTime(): number;
        /**
        Gets the local candidate identifier.
        */
        getLocalCandidateId(): string;
        /**
        Gets whether the candidate pair is nominated.
        */
        getNominated(): boolean;
        /**
        Gets the priority.
        */
        getPriority(): number;
        /**
        Gets the remote candidate identifier.
        */
        getRemoteCandidateId(): string;
        /**
        Gets the number of requests received.
        */
        getRequestsReceived(): number;
        /**
        Gets the number of requests sent.
        */
        getRequestsSent(): number;
        /**
        Gets the number of responses received.
        */
        getResponsesReceived(): number;
        /**
        Gets the number of responses sent.
        */
        getResponsesSent(): number;
        /**
        Gets the state.
        */
        getState(): fm.liveswitch.CandidatePairState;
        /**
        Gets the total round trip time in milliseconds.
        */
        getTotalRoundTripTime(): number;
        /**
        Gets the transport identifier.
        */
        getTransportId(): string;
        /**
        Checks if a candidate pair is equivalent to this one.
        @param instance The candidate pair.
        */
        isEquivalent(instance: fm.liveswitch.CandidatePairStats): boolean;
        /**
        Serializes the properties.
        @param jsonObject The JSON object.
        */
        protected serializeProperties(jsonObject: fm.liveswitch.Hash<string, string>): void;
        /** @hidden */
        setBytesReceived(value: number): void;
        /** @hidden */
        setBytesSent(value: number): void;
        /** @hidden */
        setConsentRequestsReceived(value: number): void;
        /** @hidden */
        setConsentRequestsSent(value: number): void;
        /** @hidden */
        setConsentResponsesReceived(value: number): void;
        /** @hidden */
        setConsentResponsesSent(value: number): void;
        /** @hidden */
        setCurrentRoundTripTime(value: number): void;
        /** @hidden */
        setLocalCandidateId(value: string): void;
        /** @hidden */
        setNominated(value: boolean): void;
        /** @hidden */
        setPriority(value: number): void;
        /** @hidden */
        setRemoteCandidateId(value: string): void;
        /** @hidden */
        setRequestsReceived(value: number): void;
        /** @hidden */
        setRequestsSent(value: number): void;
        /** @hidden */
        setResponsesReceived(value: number): void;
        /** @hidden */
        setResponsesSent(value: number): void;
        /** @hidden */
        setState(value: fm.liveswitch.CandidatePairState): void;
        /** @hidden */
        setTotalRoundTripTime(value: number): void;
        /** @hidden */
        setTransportId(value: string): void;
        /**
        Serializes this to JSON.
        */
        toJson(): string;
    }
}
declare namespace fm.liveswitch {
    /**
    Candidate stats.
    */
    class CandidateStats extends fm.liveswitch.BaseStats implements fm.liveswitch.IEquivalent<fm.liveswitch.CandidateStats> {
        getTypeString(): string;
        /** @hidden */
        private _ipAddress;
        /** @hidden */
        private _port;
        /** @hidden */
        private _priority;
        /** @hidden */
        private _protocol;
        /** @hidden */
        private _relatedIPAddress;
        /** @hidden */
        private _relatedPort;
        /** @hidden */
        private _relayProtocol;
        /** @hidden */
        private _type;
        private fmliveswitchCandidateStatsInit;
        /**
        Initializes a new instance of the [[fm.liveswitch.candidateStats]] class.
        */
        constructor();
        /**
        Derializes candidate stats from JSON.
        @param candidateJson The candidate's stats JSON.
        */
        static fromJson(candidateJson: string): fm.liveswitch.CandidateStats;
        /**
        Derializes an array of candidate stats from JSON.
        @param candidatesJson The candidates' stats JSON.
        */
        static fromJsonArray(candidatesJson: string): fm.liveswitch.CandidateStats[];
        /**
        Serializes candidate stats to JSON.
        @param candidate The candidate's stats.
        */
        static toJson(candidate: fm.liveswitch.CandidateStats): string;
        /**
        Serializes an array of candidate stats to JSON.
        @param candidates The candidates' stats.
        */
        static toJsonArray(candidates: fm.liveswitch.CandidateStats[]): string;
        /**
        Deserializes the properties.
        @param key The key.
        @param valueJson The value in JSON format.
        */
        protected deserializeProperties(key: string, valueJson: string): void;
        /**
        Gets the IP address.
        */
        getIPAddress(): string;
        /**
        Gets whether the candidate is host/local.
        */
        getIsHost(): boolean;
        /**
        Gets whether the candidate is reflexive.
        */
        getIsReflexive(): boolean;
        /**
        Gets whether the candidate is relayed.
        */
        getIsRelayed(): boolean;
        /**
        Gets the port.
        */
        getPort(): number;
        /**
        Gets the priority.
        */
        getPriority(): number;
        /**
        Gets the protocol.
        */
        getProtocol(): fm.liveswitch.ProtocolType;
        /**
        Gets the related IP address.
        */
        getRelatedIPAddress(): string;
        /**
        Gets the related port.
        */
        getRelatedPort(): number;
        /**
        Gets the relay protocol.
        */
        getRelayProtocol(): fm.liveswitch.ProtocolType;
        /**
        Gets the relay protocol. Obsolete. Alias for [[fm.liveswitch.candidateStats.relayProtocol]].
        */
        getTurnProtocol(): fm.liveswitch.ProtocolType;
        /**
        Gets the type.
        */
        getType(): fm.liveswitch.CandidateType;
        /**
        Checks if a candidate is equivalent to this one.
        @param instance The candidate.
        */
        isEquivalent(instance: fm.liveswitch.CandidateStats): boolean;
        /**
        Serializes the properties.
        @param jsonObject The JSON object.
        */
        protected serializeProperties(jsonObject: fm.liveswitch.Hash<string, string>): void;
        /** @hidden */
        setIPAddress(value: string): void;
        /** @hidden */
        setPort(value: number): void;
        /** @hidden */
        setPriority(value: number): void;
        /** @hidden */
        setProtocol(value: fm.liveswitch.ProtocolType): void;
        /** @hidden */
        setRelatedIPAddress(value: string): void;
        /** @hidden */
        setRelatedPort(value: number): void;
        /** @hidden */
        setRelayProtocol(value: fm.liveswitch.ProtocolType): void;
        /** @hidden */
        setType(value: fm.liveswitch.CandidateType): void;
        /**
        Serializes this to JSON.
        */
        toJson(): string;
    }
}
declare namespace fm.liveswitch {
    class CandidateTypeWrapper {
        getTypeString(): string;
        /** @hidden */
        private _value;
        constructor(value: fm.liveswitch.CandidateType);
        toString(): string;
    }
}
declare namespace fm.liveswitch {
    /**
    Utility functions for candidate and candidate pair.
    */
    class CandidateUtility {
        getTypeString(): string;
        constructor();
        /**
        Convert string to CandidatePairState.
        @param stateString
        */
        static candidatePairStateFromString(stateString: string): fm.liveswitch.CandidatePairState;
        /**
        Convert CandidatePairState to string.
        @param state
        */
        static candidatePairStateToString(state: fm.liveswitch.CandidatePairState): string;
        /**
        Convert string to ProtocolType.
        @param protocolTypeString
        */
        static protocolTypeFromString(protocolTypeString: string): fm.liveswitch.ProtocolType;
        /**
        Convert ProtocolType to string.
        @param protocolType
        */
        static protocolTypeToString(protocolType: fm.liveswitch.ProtocolType): string;
        /**
        Convert string to CandidateType.
        @param typeString
        */
        static typeFromString(typeString: string): fm.liveswitch.CandidateType;
        /**
        Convert CandidateType to string.
        @param type
        */
        static typeToString(type: fm.liveswitch.CandidateType): string;
    }
}
declare namespace fm.liveswitch {
    /**
    Certificate information.
    */
    class CertificateInfo extends fm.liveswitch.Info {
        getTypeString(): string;
        /** @hidden */
        private _base64;
        /** @hidden */
        private _fingerprint;
        /** @hidden */
        private _fingerprintAlgorithm;
        /**
        Initializes a new instance of the [[fm.liveswitch.certificateInfo]] class.
        */
        constructor();
        constructor(stats: fm.liveswitch.CertificateStats, lastStats: fm.liveswitch.CertificateStats);
        /**
        Deserializes an instance from JSON.
        @param instanceJson The instance JSON.
        @return The deserialized instance.
        */
        static fromJson(instanceJson: string): fm.liveswitch.CertificateInfo;
        /**
        Derializes an array from JSON.
        @param arrayJson The array JSON.
        @return The deserialized array.
        */
        static fromJsonArray(arrayJson: string): fm.liveswitch.CertificateInfo[];
        /**
        Serializes an instance to JSON.
        @param instance The instance.
        @return The serialized instance JSON.
        */
        static toJson(instance: fm.liveswitch.CertificateInfo): string;
        /**
        Serializes an array to JSON.
        @param array The array.
        @return The serialized array JSON.
        */
        static toJsonArray(array: fm.liveswitch.CertificateInfo[]): string;
        /**
        Deserializes the properties.
        @param key The key.
        @param valueJson The value in JSON format.
        */
        protected deserializeProperties(key: string, valueJson: string): void;
        /**
        Gets the certificate in Base64 format.
        */
        getBase64(): string;
        /**
        Gets the certificate fingerprint.
        */
        getFingerprint(): string;
        /**
        Gets the certificate fingerprint algorithm.
        */
        getFingerprintAlgorithm(): string;
        /**
        Serializes the properties.
        @param jsonObject The JSON object.
        */
        protected serializeProperties(jsonObject: fm.liveswitch.Hash<string, string>): void;
        /**
        Sets the certificate in Base64 format.
        */
        setBase64(value: string): void;
        /**
        Sets the certificate fingerprint.
        */
        setFingerprint(value: string): void;
        /**
        Sets the certificate fingerprint algorithm.
        */
        setFingerprintAlgorithm(value: string): void;
        /**
        Serializes this instance to JSON.
        */
        toJson(): string;
    }
}
declare namespace fm.liveswitch {
    /**
    Certificate stats.
    */
    class CertificateStats extends fm.liveswitch.BaseStats implements fm.liveswitch.IEquivalent<fm.liveswitch.CertificateStats> {
        getTypeString(): string;
        /** @hidden */
        private _certificateBase64;
        /** @hidden */
        private _fingerprint;
        /** @hidden */
        private _fingerprintAlgorithm;
        constructor();
        /**
        Derializes certificate stats from JSON.
        @param certificateJson The certificate's stats JSON.
        */
        static fromJson(certificateJson: string): fm.liveswitch.CertificateStats;
        /**
        Derializes an array of certificate stats from JSON.
        @param certificatesJson The certificates' stats JSON.
        */
        static fromJsonArray(certificatesJson: string): fm.liveswitch.CertificateStats[];
        /**
        Serializes certificate stats to JSON.
        @param certificate The certificate's stats.
        */
        static toJson(certificate: fm.liveswitch.CertificateStats): string;
        /**
        Serializes an array of certificate stats to JSON.
        @param certificates The certificates' stats.
        */
        static toJsonArray(certificates: fm.liveswitch.CertificateStats[]): string;
        /**
        Deserializes the properties.
        @param key The key.
        @param valueJson The value in JSON format.
        */
        protected deserializeProperties(key: string, valueJson: string): void;
        /**
        Gets the certificate in Base64 format.
        */
        getCertificateBase64(): string;
        /**
        Gets the fingerprint.
        */
        getFingerprint(): string;
        /**
        Gets the fingerprint algorithm.
        */
        getFingerprintAlgorithm(): string;
        /**
        Checks if a certificate is equivalent to this one.
        @param instance The certificate.
        */
        isEquivalent(instance: fm.liveswitch.CertificateStats): boolean;
        /**
        Serializes the properties.
        @param jsonObject The JSON object.
        */
        protected serializeProperties(jsonObject: fm.liveswitch.Hash<string, string>): void;
        /** @hidden */
        setCertificateBase64(value: string): void;
        /** @hidden */
        setFingerprint(value: string): void;
        /** @hidden */
        setFingerprintAlgorithm(value: string): void;
        /**
        Serializes this to JSON.
        */
        toJson(): string;
    }
}
declare namespace fm.liveswitch {
    /**
    Codec information.
    */
    class CodecInfo extends fm.liveswitch.Info {
        getTypeString(): string;
        /** @hidden */
        private _channelCount;
        /** @hidden */
        private _clockRate;
        /** @hidden */
        private _name;
        /** @hidden */
        private _parameters;
        /** @hidden */
        private _payloadType;
        private fmliveswitchCodecInfoInit;
        constructor();
        /**
        Deserializes an instance from JSON.
        @param codecInfoJson The serialized JSON.
        @return The deserialized instance.
        */
        static fromJson(codecInfoJson: string): fm.liveswitch.CodecInfo;
        /**
        Deserializes an array from JSON.
        @param codecInfosJson The serialized JSON.
        @return The deserialized array.
        */
        static fromJsonArray(codecInfosJson: string): fm.liveswitch.CodecInfo[];
        /**
        Serializes an instance to JSON.
        @param codecInfo The instance to serialize.
        @return The serialized JSON.
        */
        static toJson(codecInfo: fm.liveswitch.CodecInfo): string;
        /**
        Serializes an array to JSON.
        @param codecInfos The array to serialize.
        @return The serialized JSON.
        */
        static toJsonArray(codecInfos: fm.liveswitch.CodecInfo[]): string;
        /**
        Deserializes the properties.
        @param key The key.
        @param valueJson The value in JSON format.
        */
        protected deserializeProperties(key: string, valueJson: string): void;
        /**
        Gets the codec channel count.
        */
        getChannelCount(): number;
        /**
        Gets the codec clock rate.
        */
        getClockRate(): number;
        /**
        Gets the codec name.
        */
        getName(): string;
        /**
        Gets the codec parameters.
        */
        getParameters(): string;
        /**
        Gets the codec payload type.
        */
        getPayloadType(): number;
        /**
        Serializes the properties.
        @param jsonObject The JSON object.
        */
        protected serializeProperties(jsonObject: fm.liveswitch.Hash<string, string>): void;
        /**
        Sets the codec channel count.
        */
        setChannelCount(value: number): void;
        /**
        Sets the codec clock rate.
        */
        setClockRate(value: number): void;
        /**
        Sets the codec name.
        */
        setName(value: string): void;
        /**
        Sets the codec parameters.
        */
        setParameters(value: string): void;
        /**
        Sets the codec payload type.
        */
        setPayloadType(value: number): void;
        /**
        Serializes this instance to JSON.
        */
        toJson(): string;
    }
}
declare namespace fm.liveswitch {
    /**
    Codec stats.
    */
    class CodecStats extends fm.liveswitch.BaseStats implements fm.liveswitch.IEquivalent<fm.liveswitch.CodecStats> {
        getTypeString(): string;
        /** @hidden */
        private _channelCount;
        /** @hidden */
        private _clockRate;
        /** @hidden */
        private _codecType;
        /** @hidden */
        private _name;
        /** @hidden */
        private _parameters;
        /** @hidden */
        private _payloadType;
        private fmliveswitchCodecStatsInit;
        constructor();
        /**
        Derializes codec stats from JSON.
        @param codecJson The codec's stats JSON.
        */
        static fromJson(codecJson: string): fm.liveswitch.CodecStats;
        /**
        Serializes codec stats to JSON.
        @param codec The codec's stats.
        */
        static toJson(codec: fm.liveswitch.CodecStats): string;
        /**
        Deserializes the properties.
        @param key The key.
        @param valueJson The value in JSON format.
        */
        protected deserializeProperties(key: string, valueJson: string): void;
        /**
        Gets the channel count.
        */
        getChannelCount(): number;
        /**
        Gets the clock rate.
        */
        getClockRate(): number;
        /**
        Gets the codec type, "encode" or "decode", depending on whether this object represents a media format that the implementation is prepared to encode or decode.
        */
        getCodecType(): fm.liveswitch.CodecType;
        /**
        Gets the name.
        */
        getName(): string;
        /**
        Gets the parameters.
        */
        getParameters(): string;
        /**
        Gets the payload type.
        */
        getPayloadType(): number;
        /**
        Checks if a codec is equivalent to this one.
        @param instance The codec.
        */
        isEquivalent(instance: fm.liveswitch.CodecStats): boolean;
        /**
        Serializes the properties.
        @param jsonObject The JSON object.
        */
        protected serializeProperties(jsonObject: fm.liveswitch.Hash<string, string>): void;
        /** @hidden */
        setChannelCount(value: number): void;
        /** @hidden */
        setClockRate(value: number): void;
        /** @hidden */
        setCodecType(value: fm.liveswitch.CodecType): void;
        /** @hidden */
        setName(value: string): void;
        /** @hidden */
        setParameters(value: string): void;
        /** @hidden */
        setPayloadType(value: number): void;
        /**
        Serializes this to JSON.
        */
        toJson(): string;
    }
}
declare namespace fm.liveswitch {
    class CodecTypeWrapper {
        getTypeString(): string;
        /** @hidden */
        private _value;
        constructor(value: fm.liveswitch.CodecType);
        toString(): string;
    }
}
declare namespace fm.liveswitch {
    class ConnectionStateWrapper {
        getTypeString(): string;
        /** @hidden */
        private _value;
        constructor(value: fm.liveswitch.ConnectionState);
        toString(): string;
    }
}
declare namespace fm.liveswitch {
    /**
    Connection stats.
    */
    class ConnectionStats extends fm.liveswitch.BaseStats {
        getTypeString(): string;
        /** @hidden */
        private _dataStream;
        /** @hidden */
        private _externalId;
        /** @hidden */
        private _mediaStreams;
        /** @hidden */
        private _state;
        constructor();
        /**
        Derializes connection stats from JSON.
        @param connectionJson The connection's stats JSON.
        */
        static fromJson(connectionJson: string): fm.liveswitch.ConnectionStats;
        /**
        Serializes connection stats to JSON.
        @param connection The connection's stats.
        */
        static toJson(connection: fm.liveswitch.ConnectionStats): string;
        /**
        Deserializes the properties.
        @param key The key.
        @param valueJson The value in JSON format.
        */
        protected deserializeProperties(key: string, valueJson: string): void;
        /**
        Gets the first audio stream's stats.
        */
        getAudioStream(): fm.liveswitch.MediaStreamStats;
        /**
        Gets the audio streams' stats.
        */
        getAudioStreams(): fm.liveswitch.MediaStreamStats[];
        /**
        Gets the data stream's stats.
        */
        getDataStream(): fm.liveswitch.DataStreamStats;
        /**
        Gets the external identifier.
        */
        getExternalId(): string;
        /**
        Gets whether any of the streams are using a transport whose active candidate pair has a host candidate.
        */
        getIsHost(): boolean;
        /**
        Gets whether any of the streams are using a transport whose active candidate pair has a reflexive candidate.
        */
        getIsReflexive(): boolean;
        /**
        Gets whether any of the streams are using a transport whose active candidate pair has a relayed candidate.
        */
        getIsRelayed(): boolean;
        /**
        Gets the first media stream's stats.
        */
        getMediaStream(): fm.liveswitch.MediaStreamStats;
        /**
        Gets a media stream by its identifier.
        @param mediaStreamId The media stream identifier.
        */
        getMediaStream(mediaStreamId: string): fm.liveswitch.MediaStreamStats;
        /**
        Gets the media streams' stats.
        */
        getMediaStreams(): fm.liveswitch.MediaStreamStats[];
        /**
        Gets the state.
        */
        getState(): fm.liveswitch.ConnectionState;
        /**
        Gets the streams' stats.
        */
        getStreams(): fm.liveswitch.StreamStats[];
        /**
        Gets the first video stream's stats.
        */
        getVideoStream(): fm.liveswitch.MediaStreamStats;
        /**
        Gets the video streams' stats.
        */
        getVideoStreams(): fm.liveswitch.MediaStreamStats[];
        /**
        Serializes the properties.
        @param jsonObject The JSON object.
        */
        protected serializeProperties(jsonObject: fm.liveswitch.Hash<string, string>): void;
        /** @hidden */
        setDataStream(value: fm.liveswitch.DataStreamStats): void;
        /**
        Sets the external identifier.
        */
        setExternalId(value: string): void;
        /** @hidden */
        setMediaStreams(value: fm.liveswitch.MediaStreamStats[]): void;
        /**
        Sets the state.
        */
        setState(value: fm.liveswitch.ConnectionState): void;
        /** @hidden */
        private stateFromString;
        /** @hidden */
        private stateToString;
        /**
        Serializes this to JSON.
        */
        toJson(): string;
    }
}
declare namespace fm.liveswitch {
    /**
    Data channel information.
    */
    class DataChannelInfo extends fm.liveswitch.Info {
        getTypeString(): string;
        /** @hidden */
        private _label;
        /** @hidden */
        private _ordered;
        /** @hidden */
        private _report;
        /** @hidden */
        private _state;
        /** @hidden */
        private _subprotocol;
        private fmliveswitchDataChannelInfoInit;
        constructor();
        /**
        Deserializes Json to a DataChannelInfo.
        @param dataChannelInfoJson The serialized Json.
        @return The deserialized DataChannelInfo.
        */
        static fromJson(dataChannelInfoJson: string): fm.liveswitch.DataChannelInfo;
        /**
        Deserializes JSON to an array.
        @param dataChannelInfosJson The serialized JSON.
        @return The deserialized array.
        */
        static fromJsonArray(dataChannelInfosJson: string): fm.liveswitch.DataChannelInfo[];
        /**
        Serializes an instance to Json.
        @param dataChannelInfo The instance to serialize.
        @return Serialized Json.
        */
        static toJson(dataChannelInfo: fm.liveswitch.DataChannelInfo): string;
        /**
        Serializes an array to JSON.
        @param dataChannelInfos The array to serialize.
        @return The serialized JSON.
        */
        static toJsonArray(dataChannelInfos: fm.liveswitch.DataChannelInfo[]): string;
        /**
        Deserializes the properties.
        @param key The key.
        @param valueJson The value in JSON format.
        */
        protected deserializeProperties(key: string, valueJson: string): void;
        /**
        Gets the data channel label.
        */
        getLabel(): string;
        /**
        Gets whether the data channel is ordered.
        */
        getOrdered(): boolean;
        /**
        Gets the data channel report.
        */
        getReport(): fm.liveswitch.DataChannelReport;
        /**
        Gets the data channel state.
        */
        getState(): string;
        /**
        Gets the data channel subprotocol.
        */
        getSubprotocol(): string;
        /** @hidden */
        populateReports(stats: fm.liveswitch.DataChannelStats, lastStats: fm.liveswitch.DataChannelStats, eventType: string): void;
        /**
        Serializes the properties.
        @param jsonObject The JSON object.
        */
        protected serializeProperties(jsonObject: fm.liveswitch.Hash<string, string>): void;
        /**
        Sets the data channel label.
        */
        setLabel(value: string): void;
        /**
        Sets whether the data channel is ordered.
        */
        setOrdered(value: boolean): void;
        /**
        Sets the data channel report.
        */
        setReport(value: fm.liveswitch.DataChannelReport): void;
        /**
        Sets the data channel state.
        */
        setState(value: string): void;
        /**
        Sets the data channel subprotocol.
        */
        setSubprotocol(value: string): void;
        /**
        Serializes this instance to Json.
        */
        toJson(): string;
    }
}
declare namespace fm.liveswitch {
    class DataChannelStateWrapper {
        getTypeString(): string;
        /** @hidden */
        private _value;
        constructor(value: fm.liveswitch.DataChannelState);
        toString(): string;
    }
}
declare namespace fm.liveswitch {
    /**
    Data channel stats.
    */
    class DataChannelStats extends fm.liveswitch.BaseStats {
        getTypeString(): string;
        /** @hidden */
        private _bytesReceived;
        /** @hidden */
        private _bytesSent;
        /** @hidden */
        private _label;
        /** @hidden */
        private _messagesReceived;
        /** @hidden */
        private _messagesSent;
        /** @hidden */
        private _ordered;
        /** @hidden */
        private _protocol;
        /** @hidden */
        private _state;
        private fmliveswitchDataChannelStatsInit;
        /**
        Initializes a new instance of [[fm.liveswitch.dataChannelStats]].
        */
        constructor();
        /**
        Derializes data channel stats from JSON.
        @param dataChannelJson The data channel's stats JSON.
        */
        static fromJson(dataChannelJson: string): fm.liveswitch.DataChannelStats;
        /**
        Derializes an array of data channel stats from JSON.
        @param dataChannelsJson The data channels' stats JSON.
        */
        static fromJsonArray(dataChannelsJson: string): fm.liveswitch.DataChannelStats[];
        /**
        Serializes data channel stats to JSON.
        @param dataChannel The data channel's stats.
        */
        static toJson(dataChannel: fm.liveswitch.DataChannelStats): string;
        /**
        Serializes an array of data channel stats to JSON.
        @param dataChannels The data channels' stats.
        */
        static toJsonArray(dataChannels: fm.liveswitch.DataChannelStats[]): string;
        /**
        Deserializes the properties.
        @param key The key.
        @param valueJson The value in JSON format.
        */
        protected deserializeProperties(key: string, valueJson: string): void;
        /**
        Gets the number of bytes received.
        */
        getBytesReceived(): number;
        /**
        Gets the number of bytes sent.
        */
        getBytesSent(): number;
        /**
        Gets the label.
        */
        getLabel(): string;
        /**
        Gets the number of messages received.
        */
        getMessagesReceived(): number;
        /**
        Gets the number of messages sent.
        */
        getMessagesSent(): number;
        /**
        Gets whether the channel is ordered.
        */
        getOrdered(): boolean;
        /**
        Gets the protocol.
        */
        getProtocol(): string;
        /**
        Gets the state.
        */
        getState(): fm.liveswitch.DataChannelState;
        /**
        Serializes the properties.
        @param jsonObject The JSON object.
        */
        protected serializeProperties(jsonObject: fm.liveswitch.Hash<string, string>): void;
        /** @hidden */
        setBytesReceived(value: number): void;
        /** @hidden */
        setBytesSent(value: number): void;
        /** @hidden */
        setLabel(value: string): void;
        /** @hidden */
        setMessagesReceived(value: number): void;
        /** @hidden */
        setMessagesSent(value: number): void;
        /** @hidden */
        setOrdered(value: boolean): void;
        /** @hidden */
        setProtocol(value: string): void;
        /** @hidden */
        setState(value: fm.liveswitch.DataChannelState): void;
        /** @hidden */
        private stateFromString;
        /** @hidden */
        private stateToString;
        /**
        Serializes this to JSON.
        */
        toJson(): string;
    }
}
declare namespace fm.liveswitch {
    /**
    Stream information.
    */
    abstract class StreamInfo extends fm.liveswitch.Info {
        getTypeString(): string;
        /** @hidden */
        private _tag;
        /** @hidden */
        private _transportId;
        constructor();
        /**
        Deserializes the properties.
        @param key The key.
        @param valueJson The value in JSON format.
        */
        protected deserializeProperties(key: string, valueJson: string): void;
        /**
        Gets the tag.
        */
        getTag(): string;
        /**
        Gets the transport id.
        */
        getTransportId(): string;
        /**
        Serializes the properties.
        @param jsonObject The JSON object.
        */
        protected serializeProperties(jsonObject: fm.liveswitch.Hash<string, string>): void;
        /**
        Sets the tag.
        */
        setTag(value: string): void;
        /**
        Sets the transport id.
        */
        setTransportId(value: string): void;
    }
}
declare namespace fm.liveswitch {
    /**
    Data stream information.
    */
    class DataStreamInfo extends fm.liveswitch.StreamInfo {
        getTypeString(): string;
        /** @hidden */
        private _channels;
        /** @hidden */
        private _report;
        constructor();
        /**
        Deserializes Json to a DataStreamInfo.
        @param dataStreamInfoJson The serialized Json.
        @return The deserialized DataStreamInfo.
        */
        static fromJson(dataStreamInfoJson: string): fm.liveswitch.DataStreamInfo;
        /**
        Deserializes JSON to a DataStreamInfo array.
        @param dataStreamInfosJson The serialized JSON.
        @return The deserialized DataStreamInfo array.
        */
        static fromJsonArray(dataStreamInfosJson: string): fm.liveswitch.DataStreamInfo[];
        /**
        Serializes an instance to Json.
        @param dataStreamInfo The instance to serialize.
        @return Serialized Json.
        */
        static toJson(dataStreamInfo: fm.liveswitch.DataStreamInfo): string;
        /**
        Serializes an instance array to JSON.
        @param dataStreamInfos The instance array to serialize.
        @return Serialized Json.
        */
        static toJsonArray(dataStreamInfos: fm.liveswitch.DataStreamInfo[]): string;
        /**
        Deserializes the properties.
        @param key The key.
        @param valueJson The value in JSON format.
        */
        protected deserializeProperties(key: string, valueJson: string): void;
        /**
        Gets the data stream channels.
        */
        getChannels(): fm.liveswitch.DataChannelInfo[];
        /**
        Gets the data stream report.
        */
        getReport(): fm.liveswitch.DataStreamReport;
        /** @hidden */
        populateInfos(stats: fm.liveswitch.DataStreamStats, lastStats: fm.liveswitch.DataStreamStats, eventType: string): void;
        /**
        Serializes the properties.
        @param jsonObject The JSON object.
        */
        protected serializeProperties(jsonObject: fm.liveswitch.Hash<string, string>): void;
        /**
        Sets the data stream channels.
        */
        setChannels(value: fm.liveswitch.DataChannelInfo[]): void;
        /**
        Sets the data stream report.
        */
        setReport(value: fm.liveswitch.DataStreamReport): void;
        /**
        Serializes this instance to Json.
        */
        toJson(): string;
    }
}
declare namespace fm.liveswitch {
    /**
    Stream stats.
    */
    abstract class StreamStats extends fm.liveswitch.BaseStats {
        getTypeString(): string;
        /** @hidden */
        private _transport;
        /** @hidden */
        private _type;
        constructor();
        /**
        Deserializes the properties.
        @param key The key.
        @param valueJson The value in JSON format.
        */
        protected deserializeProperties(key: string, valueJson: string): void;
        /**
        Gets whether the transport's active candidate pair has a host candidate.
        */
        getIsHost(): boolean;
        /**
        Gets whether the transport's active candidate pair has a reflexive candidate.
        */
        getIsReflexive(): boolean;
        /**
        Gets whether the transport's active candidate pair has a relayed candidate.
        */
        getIsRelayed(): boolean;
        /**
        Gets the transport's stats.
        */
        getTransport(): fm.liveswitch.TransportStats;
        /**
        Gets the type.
        */
        getType(): fm.liveswitch.StreamType;
        /**
        Serializes the properties.
        @param jsonObject The JSON object.
        */
        protected serializeProperties(jsonObject: fm.liveswitch.Hash<string, string>): void;
        /** @hidden */
        setTransport(value: fm.liveswitch.TransportStats): void;
        /** @hidden */
        setType(value: fm.liveswitch.StreamType): void;
        /** @hidden */
        private typeFromString;
        /** @hidden */
        private typeToString;
    }
}
declare namespace fm.liveswitch {
    /**
    Data stream stats.
    */
    class DataStreamStats extends fm.liveswitch.StreamStats {
        getTypeString(): string;
        /** @hidden */
        private _bytesReceived;
        /** @hidden */
        private _bytesSent;
        /** @hidden */
        private _channels;
        /** @hidden */
        private _messagesReceived;
        /** @hidden */
        private _messagesSent;
        private fmliveswitchDataStreamStatsInit;
        constructor();
        /**
        Derializes data stream stats from JSON.
        @param dataStreamJson The data stream's stats JSON.
        */
        static fromJson(dataStreamJson: string): fm.liveswitch.DataStreamStats;
        /**
        Derializes an array of data stream stats from JSON.
        @param dataStreamsJson The data streams' stats JSON.
        */
        static fromJsonArray(dataStreamsJson: string): fm.liveswitch.DataStreamStats[];
        /**
        Serializes data stream stats to JSON.
        @param dataStream The data stream's stats.
        */
        static toJson(dataStream: fm.liveswitch.DataStreamStats): string;
        /**
        Serializes an array of data stream stats to JSON.
        @param dataStreams The data streams' stats.
        */
        static toJsonArray(dataStreams: fm.liveswitch.DataStreamStats[]): string;
        /**
        Deserializes the properties.
        @param key The key.
        @param valueJson The value in JSON format.
        */
        protected deserializeProperties(key: string, valueJson: string): void;
        /**
        Gets the number of bytes received.
        */
        getBytesReceived(): number;
        /**
        Gets the number of bytes sent.
        */
        getBytesSent(): number;
        /**
        Gets the first channel's stats.
        */
        getChannel(): fm.liveswitch.DataChannelStats;
        /**
        Gets a channel by its identifier.
        @param channelId The channel identifier.
        */
        getChannel(channelId: string): fm.liveswitch.DataChannelStats;
        /**
        Gets the channels' stats.
        */
        getChannels(): fm.liveswitch.DataChannelStats[];
        /**
        Gets the first channel's stats. Obsolete. Alias for [[fm.liveswitch.dataStreamStats.channel]].
        */
        getDataChannel(): fm.liveswitch.DataChannelStats;
        /**
        Gets a channel by its identifier. Obsolete. Alias for GetChannel.
        @param dataChannelId The channel identifier.
        */
        getDataChannel(dataChannelId: string): fm.liveswitch.DataChannelStats;
        /**
        Gets the channels' stats. Obsolete. Alias for [[fm.liveswitch.dataStreamStats.channels]].
        */
        getDataChannels(): fm.liveswitch.DataChannelStats[];
        /**
        Gets the number of messages received.
        */
        getMessagesReceived(): number;
        /**
        Gets the number of messages sent.
        */
        getMessagesSent(): number;
        /**
        Serializes the properties.
        @param jsonObject The JSON object.
        */
        protected serializeProperties(jsonObject: fm.liveswitch.Hash<string, string>): void;
        /** @hidden */
        setBytesReceived(value: number): void;
        /** @hidden */
        setBytesSent(value: number): void;
        /** @hidden */
        setChannels(value: fm.liveswitch.DataChannelStats[]): void;
        /** @hidden */
        setMessagesReceived(value: number): void;
        /** @hidden */
        setMessagesSent(value: number): void;
        /**
        Serializes this to JSON.
        */
        toJson(): string;
    }
}
declare namespace fm.liveswitch {
    /**
    Encoding configuration.
    */
    abstract class EncodingConfig {
        getTypeString(): string;
        /** @hidden */
        private _bitrate;
        /** @hidden */
        private _deactivated;
        /** @hidden */
        private _rtpStreamId;
        /** @hidden */
        private _synchronizationSource;
        private fmliveswitchEncodingConfigInit;
        /**
        Initializes a new instance of the [[fm.liveswitch.encodingConfig]] class.
        */
        constructor();
        /**
        Initializes a new instance of the [[fm.liveswitch.encodingConfig]] class.
        @param encoding The encoding.
        */
        constructor(encoding: fm.liveswitch.EncodingInfo);
        /**
        Deserializes the properties.
        @param key The key.
        @param valueJson The value in JSON format.
        */
        protected deserializeProperties(key: string, valueJson: string): void;
        /**
        Gets the bitrate, in kbps.
        */
        getBitrate(): number;
        /**
        Gets whether this encoding is deactivated.
        */
        getDeactivated(): boolean;
        /**
        Gets the RTP stream identifier.
        */
        getRtpStreamId(): string;
        /**
        Gets the synchronization source.
        */
        getSynchronizationSource(): number;
        /**
        Serializes the properties.
        @param jsonObject The JSON object.
        */
        protected serializeProperties(jsonObject: fm.liveswitch.Hash<string, string>): void;
        /**
        Sets the bitrate, in kbps.
        */
        setBitrate(value: number): void;
        /**
        Sets whether this encoding is deactivated.
        */
        setDeactivated(value: boolean): void;
        /** @hidden */
        setRtpStreamId(value: string): void;
        /** @hidden */
        setSynchronizationSource(value: number): void;
    }
}
declare namespace fm.liveswitch {
    /**
    Audio encoding configuration.
    */
    class AudioEncodingConfig extends fm.liveswitch.EncodingConfig {
        getTypeString(): string;
        /**
        Initializes a new instance of the [[fm.liveswitch.audioEncodingConfig]] class.
        */
        constructor();
        /**
        Initializes a new instance of the [[fm.liveswitch.audioEncodingConfig]] class.
        @param encoding The encoding.
        */
        constructor(encoding: fm.liveswitch.EncodingInfo);
        /**
        Deserializes an instance from JSON.
        @param encodingConfigJson The serialized JSON.
        @return The deserialized instance.
        */
        static fromJson(encodingConfigJson: string): fm.liveswitch.AudioEncodingConfig;
        /**
        Deserializes an array from JSON.
        @param encodingConfigsJson The serialized JSON.
        @return The deserialized array.
        */
        static fromJsonArray(encodingConfigsJson: string): fm.liveswitch.AudioEncodingConfig[];
        /**
        Serializes an instance to JSON.
        @param encodingConfig The instance to serialize.
        @return The serialized JSON.
        */
        static toJson(encodingConfig: fm.liveswitch.AudioEncodingConfig): string;
        /**
        Serializes an array to JSON.
        @param encodingConfigs The array to serialize.
        @return The serialized JSON.
        */
        static toJsonArray(encodingConfigs: fm.liveswitch.AudioEncodingConfig[]): string;
        /**
        Serializes this instance to JSON.
        */
        toJson(): string;
        /**
        Returns a string that represents this instance.
        @return
                    A string that represents this instance.
            
        */
        toString(): string;
    }
}
declare namespace fm.liveswitch.sdp {
    /**
    An SDP attribute.
    */
    abstract class Attribute {
        getTypeString(): string;
        /** @hidden */
        private _attributeType;
        /** @hidden */
        private _multiplexingCategory;
        /** @hidden */
        private static fm_liveswitch_sdp_Attribute__registeredAttributes;
        /** @hidden */
        private static fm_liveswitch_sdp_Attribute__registeredAttributesLock;
        /** @hidden */
        private static fm_liveswitch_sdp_Attribute__unknownAttributeTypeName;
        constructor();
        /**
        Creates an attribute.
        @param name The name.
        @param value The value.
        */
        static createAttribute(name: string, value: string): fm.liveswitch.sdp.Attribute;
        /** @hidden */
        private static createSDPBundleOnlyAttribute;
        /** @hidden */
        private static createSDPCandidateAttribute;
        /** @hidden */
        private static createSDPCategoryAttribute;
        /** @hidden */
        private static createSDPCharacterSetAttribute;
        /** @hidden */
        private static createSDPConferenceTypeAttribute;
        /** @hidden */
        private static createSDPCryptoAttribute;
        /** @hidden */
        private static createSDPExtMapAttribute;
        /** @hidden */
        private static createSDPFingerprintAttribute;
        /** @hidden */
        private static createSDPFormatParametersAttribute;
        /** @hidden */
        private static createSDPFrameRateAttribute;
        /** @hidden */
        private static createSDPGroupAttribute;
        /** @hidden */
        private static createSDPIceLiteAttribute;
        /** @hidden */
        private static createSDPIceMismatchAttribute;
        /** @hidden */
        private static createSDPIceOptionsAttribute;
        /** @hidden */
        private static createSDPIcePasswordAttribute;
        /** @hidden */
        private static createSDPIceUfragAttribute;
        /** @hidden */
        private static createSDPInactiveAttribute;
        /** @hidden */
        private static createSDPKeywordsAttribute;
        /** @hidden */
        private static createSDPLanguageAttribute;
        /** @hidden */
        private static createSDPMaxPacketTimeAttribute;
        /** @hidden */
        private static createSDPMediaStreamIdAttribute;
        /** @hidden */
        private static createSDPMediaStreamIdSemanticAttribute;
        /** @hidden */
        private static createSDPMutedAttribute;
        /** @hidden */
        private static createSDPOrientationAttribute;
        /** @hidden */
        private static createSDPPacketTimeAttribute;
        /** @hidden */
        private static createSDPQualityAttribute;
        /** @hidden */
        private static createSDPReceiveOnlyAttribute;
        /** @hidden */
        private static createSDPRemoteCandidatesAttribute;
        /** @hidden */
        private static createSDPRidAttribute;
        /** @hidden */
        private static createSDPRtcpAttribute;
        /** @hidden */
        private static createSDPRtcpFeedbackAttribute;
        /** @hidden */
        private static createSDPRtcpMuxAttribute;
        /** @hidden */
        private static createSDPRtpMapAttribute;
        /** @hidden */
        private static createSDPSctpMapAttribute;
        /** @hidden */
        private static createSDPSctpMaxMessageSizeAttribute;
        /** @hidden */
        private static createSDPSctpPortAttribute;
        /** @hidden */
        private static createSDPSdpLanguageAttribute;
        /** @hidden */
        private static createSDPSendOnlyAttribute;
        /** @hidden */
        private static createSDPSendReceiveAttribute;
        /** @hidden */
        private static createSDPSetupAttribute;
        /** @hidden */
        private static createSDPSimulcastAttribute;
        /** @hidden */
        private static createSDPSSRCAttribute;
        /** @hidden */
        private static createSDPSSRCGroupAttribute;
        /** @hidden */
        private static createSDPToolAttribute;
        /**
        Gets the name of the attribute type.
        @param type The attribute type.
        */
        static getTypeName(type: fm.liveswitch.Type): string;
        /**
        Determines whether the type applies to media streams.
        @param type The type.
        */
        static isMediaLevel(type: fm.liveswitch.Type): boolean;
        /**
        Determines whether the type applies to sessions.
        @param type The type.
        */
        static isSessionLevel(type: fm.liveswitch.Type): boolean;
        /**
        Creates an [[fm.liveswitch.sdp.connectionData]] instance from a string.
        @param s The string to parse.
        */
        static parse(s: string): fm.liveswitch.sdp.Attribute;
        /** @hidden */
        private static registerAttribute;
        /** @hidden */
        private static unregisterAttribute;
        /**
        Gets this Attribute's Type.
        */
        getAttributeType(): fm.liveswitch.sdp.AttributeType;
        /**
        Gets the internal value of the attribute.
        */
        protected abstract getAttributeValue(): string;
        /**
        Gets the Multiplexing Category of this Attribute.
        */
        getMultiplexingCategory(): fm.liveswitch.sdp.AttributeCategory;
        /**
        Sets this Attribute's Type.
        */
        setAttributeType(value: fm.liveswitch.sdp.AttributeType): void;
        /**
        Sets the Multiplexing Category of this Attribute.
        */
        protected setMultiplexingCategory(value: fm.liveswitch.sdp.AttributeCategory): void;
        /**
        Converts this instance to a string.
        */
        toString(): string;
        /** @hidden */
        private static __fmliveswitchsdpAttributeInitialized;
        /** @hidden */
        private static __fmliveswitchsdpAttributeInitializing;
        /** @hidden */
        static fmliveswitchsdpAttributeInitialize(): void;
    }
}
declare namespace fm.liveswitch.sdp {
    /**
    Attribute that indicates if the stream track is muted.
    */
    class MutedAttribute extends fm.liveswitch.sdp.Attribute {
        getTypeString(): string;
        /** @hidden */
        private __value;
        private fmliveswitchsdpMutedAttributeInit;
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.mutedAttribute]] class.
        */
        constructor(value: boolean);
        /** @hidden */
        static fromAttributeValue(value: string): fm.liveswitch.sdp.Attribute;
        /**
        Gets the internal value of the attribute.
        */
        protected getAttributeValue(): string;
        /** @hidden */
        private valueToString;
    }
}
declare namespace fm.liveswitch {
    /**
    A stream description.
    */
    class StreamDescription {
        getTypeString(): string;
        /** @hidden */
        private _mediaDescription;
        /**
        Creates a new StreamDescription object.
        @param description SDP MediaDescription of the stream.
        */
        constructor(description: fm.liveswitch.sdp.MediaDescription);
        /**
        Gets the media description associated with this stream.
        */
        getMediaDescription(): fm.liveswitch.sdp.MediaDescription;
        /**
        Gets the mid associated with this stream, if present. Null if not.
        */
        getMediaDescriptionIdentifier(): string;
        /**
        Gets the stream type.
        */
        getStreamType(): fm.liveswitch.StreamType;
        /**
        Sets the media description associated with this stream.
        */
        setMediaDescription(value: fm.liveswitch.sdp.MediaDescription): void;
    }
}
declare namespace fm.liveswitch {
    class VideoDegradationPreferenceWrapper {
        getTypeString(): string;
        /** @hidden */
        private _value;
        constructor(value: fm.liveswitch.VideoDegradationPreference);
        toString(): string;
    }
}
declare namespace fm.liveswitch {
    /**
    Video encoding configuration.
    */
    class VideoEncodingConfig extends fm.liveswitch.EncodingConfig {
        getTypeString(): string;
        /** @hidden */
        private _frameRate;
        /** @hidden */
        private _scale;
        private fmliveswitchVideoEncodingConfigInit;
        /**
        Initializes a new instance of the [[fm.liveswitch.videoEncodingConfig]] class.
        */
        constructor();
        /**
        Initializes a new instance of the [[fm.liveswitch.videoEncodingConfig]] class.
        @param encoding The encoding.
        */
        constructor(encoding: fm.liveswitch.EncodingInfo);
        /**
        Deserializes an instance from JSON.
        @param encodingConfigJson The serialized JSON.
        @return The deserialized instance.
        */
        static fromJson(encodingConfigJson: string): fm.liveswitch.VideoEncodingConfig;
        /**
        Deserializes an array from JSON.
        @param encodingConfigsJson The serialized JSON.
        @return The deserialized array.
        */
        static fromJsonArray(encodingConfigsJson: string): fm.liveswitch.VideoEncodingConfig[];
        /**
        Serializes an instance to JSON.
        @param encodingConfig The instance to serialize.
        @return The serialized JSON.
        */
        static toJson(encodingConfig: fm.liveswitch.VideoEncodingConfig): string;
        /**
        Serializes an array to JSON.
        @param encodingConfigs The array to serialize.
        @return The serialized JSON.
        */
        static toJsonArray(encodingConfigs: fm.liveswitch.VideoEncodingConfig[]): string;
        /**
        Deserializes the properties.
        @param key The key.
        @param valueJson The value in JSON format.
        */
        protected deserializeProperties(key: string, valueJson: string): void;
        /**
        Gets the frame-rate, in fps.
        */
        getFrameRate(): number;
        /**
        Gets the target scale.
        */
        getScale(): number;
        /**
        Serializes the properties.
        @param jsonObject The JSON object.
        */
        protected serializeProperties(jsonObject: fm.liveswitch.Hash<string, string>): void;
        /**
        Sets the frame-rate, in fps.
        */
        setFrameRate(value: number): void;
        /**
        Sets the target scale.
        */
        setScale(value: number): void;
        /**
        Serializes this instance to JSON.
        */
        toJson(): string;
        /**
        Returns a string that represents this instance.
        @return
                    A string that represents this instance.
            
        */
        toString(): string;
    }
}
declare namespace fm.liveswitch {
    class EncryptionModeWrapper {
        getTypeString(): string;
        /** @hidden */
        private _value;
        constructor(value: fm.liveswitch.EncryptionMode);
        toString(): string;
    }
}
declare namespace fm.liveswitch {
    /**
    Format information.
    */
    class FormatInfo implements fm.liveswitch.IEquivalent<fm.liveswitch.FormatInfo> {
        getTypeString(): string;
        /** @hidden */
        private _channelCount;
        /** @hidden */
        private _clockRate;
        /** @hidden */
        private _name;
        private fmliveswitchFormatInfoInit;
        /**
        Creates a new instance of a FormatInfo.
        */
        constructor();
        /**
        Creates an instance of a FormatInfo from an AudioFormat.
        @param audioFormat The audio format.
        */
        constructor(audioFormat: fm.liveswitch.AudioFormat);
        /**
        Creates a new instance of a FormatInfo.
        @param codecName The codec name.
        @param clockRate The clock rate.
        */
        constructor(codecName: string, clockRate: number);
        /**
        Creates a new instance of a FormatInfo.
        @param name The name.
        @param clockRate The clock rate.
        @param channelCount The channel count.
        */
        constructor(name: string, clockRate: number, channelCount: number);
        /**
        Creates an instance of a FormatInfo from a VideoFormat.
        @param videoFormat The video format.
        */
        constructor(videoFormat: fm.liveswitch.VideoFormat);
        /**
        Deserializes Json to a FormatInfo.
        @param formatInfoJson The serialized Json.
        @return The deserialized FormatInfo.
        */
        static fromJson(formatInfoJson: string): fm.liveswitch.FormatInfo;
        /**
        Derializes an array of format infos from JSON.
        @param formatInfosJson The format infos in JSON format.
        */
        static fromJsonArray(formatInfosJson: string): fm.liveswitch.FormatInfo[];
        /**
        Converts the RTP map attributes in an SDP media description to an array of FormatInfo objects.
        @param sdpMediaDescription The SDP media description.
        @return An array of FormatInfo objects.
        */
        static fromSdpMediaDescription(sdpMediaDescription: fm.liveswitch.sdp.MediaDescription): fm.liveswitch.FormatInfo[];
        /**
        Serializes an instance to Json.
        @param formatInfo The instance to serialize.
        @return Serialized Json.
        */
        static toJson(formatInfo: fm.liveswitch.FormatInfo): string;
        /**
        Serializes an array of format infos to JSON.
        @param formatInfos The format infos.
        */
        static toJsonArray(formatInfos: fm.liveswitch.FormatInfo[]): string;
        /**
        Gets the channel count if available. Unused for video codecs.
        */
        getChannelCount(): number;
        /**
        Gets the clock rate.
        */
        getClockRate(): number;
        /**
        Gets the name. Obsolete. Alias for [[fm.liveswitch.formatInfo.name]].
        */
        getCodecName(): string;
        /**
        Gets the name.
        */
        getName(): string;
        /**
        Checks if an instance is equivalent to this one.
        @param instance The instance.
        */
        isEquivalent(instance: fm.liveswitch.FormatInfo): boolean;
        /**
        Tests for equivalency.
        @param channelCount The channel count.
        @param clockRate The clock rate.
        @param name The format name.
        @return `true` if equivalent; otherwise, `false`.
            
        */
        isEquivalent(name: string, clockRate: number, channelCount: number): boolean;
        /**
        Sets the channel count if available. Unused for video codecs.
        */
        setChannelCount(value: number): void;
        /**
        Sets the clock rate.
        */
        setClockRate(value: number): void;
        /**
        Sets the name. Obsolete. Alias for [[fm.liveswitch.formatInfo.name]].
        */
        setCodecName(value: string): void;
        /**
        Sets the name.
        */
        setName(value: string): void;
        /**
        Serializes this instance to Json.
        */
        toJson(): string;
        /**
        Returns a string that represents this instance.
        */
        toString(): string;
    }
}
declare namespace fm.liveswitch {
    /**
    A layout frame definition, including X/Y coordinates and width/height values.
    */
    class LayoutFrame {
        getTypeString(): string;
        /** @hidden */
        private _clientId;
        /** @hidden */
        private _deviceId;
        /** @hidden */
        private _height;
        /** @hidden */
        private _orientation;
        /** @hidden */
        private _userId;
        /** @hidden */
        private _viewId;
        /** @hidden */
        private _width;
        /** @hidden */
        private _x;
        /** @hidden */
        private _y;
        private fmliveswitchLayoutFrameInit;
        constructor();
        /**
        Initializes a new instance of the [[fm.liveswitch.layoutFrame]] class.
        @param x The X coordinate.
        @param y The Y coordinate.
        @param width The width value.
        @param height The height value.
        */
        constructor(x: number, y: number, width: number, height: number);
        /**
        Deserializes a layout frame from JSON.
        @param layoutFrameJson The layout frame JSON.
        */
        static fromJson(layoutFrameJson: string): fm.liveswitch.LayoutFrame;
        /**
        Gets a scaled frame.
        @param scale The scaling algorithm to use.
        @param outerWidth The width of the outer container.
        @param outerHeight The height of the outer container.
        @param innerWidth The width of the inner element.
        @param innerHeight The height of the inner element.
        */
        static getScaledFrame(scale: fm.liveswitch.LayoutScale, outerWidth: number, outerHeight: number, innerWidth: number, innerHeight: number): fm.liveswitch.LayoutFrame;
        /**
        Serializes a layout frame to JSON.
        @param layoutFrame The layout frame.
        */
        static toJson(layoutFrame: fm.liveswitch.LayoutFrame): string;
        /**
        Gets the client identifier.
        */
        getClientId(): string;
        /**
        Gets the device identifier.
        */
        getDeviceId(): string;
        /**
        Gets the height value.
        */
        getHeight(): number;
        /**
        Gets the orientation in degrees.
        */
        getOrientation(): number;
        /**
        Gets the user identifier.
        */
        getUserId(): string;
        /**
        Gets the view ID.
        */
        getViewId(): string;
        /**
        Gets the width value.
        */
        getWidth(): number;
        /**
        Gets the X coordinate.
        */
        getX(): number;
        /**
        Gets the Y coordinate.
        */
        getY(): number;
        /**
        Determines whether the specified layout frame is equivalent.
        @param layoutFrame The layout frame.
        */
        isEquivalent(layoutFrame: fm.liveswitch.LayoutFrame): boolean;
        /**
        Sets the client identifier.
        */
        setClientId(value: string): void;
        /**
        Sets the device identifier.
        */
        setDeviceId(value: string): void;
        /**
        Sets the height value.
        */
        setHeight(value: number): void;
        /**
        Sets the orientation in degrees.
        */
        setOrientation(value: number): void;
        /**
        Sets the user identifier.
        */
        setUserId(value: string): void;
        /**
        Sets the view ID.
        */
        setViewId(value: string): void;
        /**
        Sets the width value.
        */
        setWidth(value: number): void;
        /**
        Sets the X coordinate.
        */
        setX(value: number): void;
        /**
        Sets the Y coordinate.
        */
        setY(value: number): void;
        /**
        Serializes this instance to JSON.
        */
        toJson(): string;
    }
}
declare namespace fm.liveswitch {
    class LayoutScaleWrapper {
        getTypeString(): string;
        /** @hidden */
        private _value;
        constructor(value: fm.liveswitch.LayoutScale);
        toString(): string;
    }
}
declare namespace fm.liveswitch {
    /**
    Media component information.
    */
    class MediaComponentInfo extends fm.liveswitch.Info {
        getTypeString(): string;
        /** @hidden */
        private _codec;
        /** @hidden */
        private _synchronizationSource;
        /** @hidden */
        private _track;
        private fmliveswitchMediaComponentInfoInit;
        /**
        Initializes a new instance of the [[fm.liveswitch.mediaComponentInfo]] class.
        */
        constructor();
        /**
        Initializes a new instance of the [[fm.liveswitch.mediaComponentInfo]] class.
        @param stats
        @param lastStats
        */
        constructor(stats: fm.liveswitch.MediaComponentStats, lastStats: fm.liveswitch.MediaComponentStats);
        /**
        Deserializes the properties.
        @param key The key.
        @param valueJson The value in JSON format.
        */
        protected deserializeProperties(key: string, valueJson: string): void;
        /**
        Gets codec.
        */
        getCodec(): fm.liveswitch.CodecInfo;
        /**
        Gets synchronization source of media track.
        */
        getSynchronizationSource(): number;
        /**
        Gets track.
        */
        getTrack(): fm.liveswitch.MediaTrackInfo;
        /**
        Serializes the properties.
        @param jsonObject The JSON object.
        */
        protected serializeProperties(jsonObject: fm.liveswitch.Hash<string, string>): void;
        /**
        Sets codec.
        */
        setCodec(value: fm.liveswitch.CodecInfo): void;
        /**
        Sets synchronization source of media track.
        */
        setSynchronizationSource(value: number): void;
        /**
        Sets track.
        */
        setTrack(value: fm.liveswitch.MediaTrackInfo): void;
    }
}
declare namespace fm.liveswitch {
    /**
    Media component stats.
    */
    abstract class MediaComponentStats extends fm.liveswitch.BaseStats {
        getTypeString(): string;
        /** @hidden */
        private _codec;
        /** @hidden */
        private _firCount;
        /** @hidden */
        private _lrrCount;
        /** @hidden */
        private _nackCount;
        /** @hidden */
        private _pliCount;
        /** @hidden */
        private _repairedRtpStreamId;
        /** @hidden */
        private _rtpStreamId;
        /** @hidden */
        private _sliCount;
        /** @hidden */
        private _synchronizationSource;
        /** @hidden */
        private _track;
        private fmliveswitchMediaComponentStatsInit;
        constructor();
        /**
        Deserializes the properties.
        @param key The key.
        @param valueJson The value in JSON format.
        */
        protected deserializeProperties(key: string, valueJson: string): void;
        /**
        Gets the codec stats.
        */
        getCodec(): fm.liveswitch.CodecStats;
        /**
        Gets the FIR count.
        */
        getFirCount(): number;
        /**
        Gets the LRR count.
        */
        getLrrCount(): number;
        /**
        Gets the NACK count.
        */
        getNackCount(): number;
        /**
        Gets the PLI count.
        */
        getPliCount(): number;
        /**
        Gets the repaired RTP stream identifier.
        */
        getRepairedRtpStreamId(): string;
        /**
        Gets the RTP stream identifier.
        */
        getRtpStreamId(): string;
        /**
        Gets the SLI count.
        */
        getSliCount(): number;
        /**
        Gets the synchronization source.
        */
        getSynchronizationSource(): number;
        /**
        Gets the track's stats.
        */
        getTrack(): fm.liveswitch.MediaTrackStats;
        /**
        Serializes the properties.
        @param jsonObject The JSON object.
        */
        protected serializeProperties(jsonObject: fm.liveswitch.Hash<string, string>): void;
        /**
        Sets the codec stats.
        */
        setCodec(value: fm.liveswitch.CodecStats): void;
        /**
        Sets the FIR count.
        */
        setFirCount(value: number): void;
        /**
        Sets the LRR count.
        */
        setLrrCount(value: number): void;
        /**
        Sets the NACK count.
        */
        setNackCount(value: number): void;
        /**
        Sets the PLI count.
        */
        setPliCount(value: number): void;
        /**
        Sets the repaired RTP stream identifier.
        */
        setRepairedRtpStreamId(value: string): void;
        /**
        Sets the RTP stream identifier.
        */
        setRtpStreamId(value: string): void;
        /**
        Sets the SLI count.
        */
        setSliCount(value: number): void;
        /**
        Sets the synchronization source.
        */
        setSynchronizationSource(value: number): void;
        /**
        Sets the track's stats.
        */
        setTrack(value: fm.liveswitch.MediaTrackStats): void;
    }
}
declare namespace fm.liveswitch {
    /**
    Media receiver information.
    */
    class MediaReceiverInfo extends fm.liveswitch.MediaComponentInfo {
        getTypeString(): string;
        /** @hidden */
        private _report;
        /** @hidden */
        private _sink;
        /**
        Initializes a new instance of the [[fm.liveswitch.mediaReceiverInfo]] class.
        */
        constructor();
        constructor(stats: fm.liveswitch.MediaReceiverStats, lastStats: fm.liveswitch.MediaReceiverStats);
        /**
        Deserializes an instance from JSON.
        @param mediaReceiverJson The serialized JSON.
        @return The deserialized instance.
        */
        static fromJson(mediaReceiverJson: string): fm.liveswitch.MediaReceiverInfo;
        /**
        Deserializes an array from JSON.
        @param mediaReceiversJson The serialized JSON.
        @return The deserialized array.
        */
        static fromJsonArray(mediaReceiversJson: string): fm.liveswitch.MediaReceiverInfo[];
        /**
        Serializes an instance to JSON.
        @param mediaReceiver The instance to serialize.
        @return The serialized JSON.
        */
        static toJson(mediaReceiver: fm.liveswitch.MediaReceiverInfo): string;
        /**
        Serializes an array to JSON.
        @param mediaReceivers The array to serialize.
        @return The serialized JSON.
        */
        static toJsonArray(mediaReceivers: fm.liveswitch.MediaReceiverInfo[]): string;
        /**
        Deserializes the properties.
        @param key The key.
        @param valueJson The value in JSON format.
        */
        protected deserializeProperties(key: string, valueJson: string): void;
        /**
        Gets report.
        */
        getReport(): fm.liveswitch.MediaReceiverReport;
        /**
        Gets sink.
        */
        getSink(): fm.liveswitch.MediaSinkInfo;
        /**
        Serializes the properties.
        @param jsonObject The JSON object.
        */
        protected serializeProperties(jsonObject: fm.liveswitch.Hash<string, string>): void;
        /**
        Sets report.
        */
        setReport(value: fm.liveswitch.MediaReceiverReport): void;
        /**
        Sets sink.
        */
        setSink(value: fm.liveswitch.MediaSinkInfo): void;
        /**
        Serializes this instance to JSON.
        */
        toJson(): string;
    }
}
declare namespace fm.liveswitch {
    /**
    Media receiver stats.
    */
    class MediaReceiverStats extends fm.liveswitch.MediaComponentStats implements fm.liveswitch.IEquivalent<fm.liveswitch.MediaReceiverStats> {
        getTypeString(): string;
        /** @hidden */
        private _bytesReceived;
        /** @hidden */
        private _jitter;
        /** @hidden */
        private _packetsDiscarded;
        /** @hidden */
        private _packetsDuplicated;
        /** @hidden */
        private _packetsLost;
        /** @hidden */
        private _packetsReceived;
        /** @hidden */
        private _packetsRepaired;
        /** @hidden */
        private _sink;
        private fmliveswitchMediaReceiverStatsInit;
        constructor();
        /**
        Derializes media receiver stats from JSON.
        @param mediaReceiverJson The media receiver's stats JSON.
        */
        static fromJson(mediaReceiverJson: string): fm.liveswitch.MediaReceiverStats;
        /**
        Derializes media receiver stats array from JSON.
        @param mediaReceiversJson The media receivers' stats JSON.
        */
        static fromJsonArray(mediaReceiversJson: string): fm.liveswitch.MediaReceiverStats[];
        /**
        Serializes media receiver stats to JSON.
        @param mediaReceiver The media receiver's stats.
        */
        static toJson(mediaReceiver: fm.liveswitch.MediaReceiverStats): string;
        /**
        Serializes media receiver stats array to JSON.
        @param mediaReceivers The media receivers' stats.
        */
        static toJsonArray(mediaReceivers: fm.liveswitch.MediaReceiverStats[]): string;
        /**
        Deserializes the properties.
        @param key The key.
        @param valueJson The value in JSON format.
        */
        protected deserializeProperties(key: string, valueJson: string): void;
        /**
        Gets the number of bytes received.
        */
        getBytesReceived(): number;
        /**
        Gets the jitter in milliseconds.
        */
        getJitter(): number;
        /**
        Gets the number of packets discarded.
        */
        getPacketsDiscarded(): number;
        /**
        Gets the number of packets duplicated.
        */
        getPacketsDuplicated(): number;
        /**
        Gets the number of packets lost.
        */
        getPacketsLost(): number;
        /**
        Gets the number of packets received.
        */
        getPacketsReceived(): number;
        /**
        Gets the number of packets repaired.
        */
        getPacketsRepaired(): number;
        /**
        Gets the sink stats.
        */
        getSink(): fm.liveswitch.MediaSinkStats;
        /**
        Checks if a media receiver is equivalent to this one.
        @param instance The media receiver.
        */
        isEquivalent(instance: fm.liveswitch.MediaReceiverStats): boolean;
        /**
        Serializes the properties.
        @param jsonObject The JSON object.
        */
        protected serializeProperties(jsonObject: fm.liveswitch.Hash<string, string>): void;
        /** @hidden */
        setBytesReceived(value: number): void;
        /** @hidden */
        setJitter(value: number): void;
        /** @hidden */
        setPacketsDiscarded(value: number): void;
        /** @hidden */
        setPacketsDuplicated(value: number): void;
        /** @hidden */
        setPacketsLost(value: number): void;
        /** @hidden */
        setPacketsReceived(value: number): void;
        /** @hidden */
        setPacketsRepaired(value: number): void;
        /** @hidden */
        setSink(value: fm.liveswitch.MediaSinkStats): void;
        /**
        Serializes this to JSON.
        */
        toJson(): string;
    }
}
declare namespace fm.liveswitch {
    /**
    Media sender information.
    */
    class MediaSenderInfo extends fm.liveswitch.MediaComponentInfo {
        getTypeString(): string;
        /** @hidden */
        private _report;
        /** @hidden */
        private _source;
        /**
        Initializes a new instance of the [[fm.liveswitch.mediaSenderInfo]] class.
        */
        constructor();
        constructor(stats: fm.liveswitch.MediaSenderStats, lastStats: fm.liveswitch.MediaSenderStats);
        /**
        Deserializes an instance from JSON.
        @param mediaSenderJson The serialized JSON.
        @return The deserialized instance.
        */
        static fromJson(mediaSenderJson: string): fm.liveswitch.MediaSenderInfo;
        /**
        Deserializes an array from JSON.
        @param mediaSendersJson The serialized JSON.
        @return The deserialized array.
        */
        static fromJsonArray(mediaSendersJson: string): fm.liveswitch.MediaSenderInfo[];
        /**
        Serializes an instance to JSON.
        @param mediaSender The instance to serialize.
        @return The serialized JSON.
        */
        static toJson(mediaSender: fm.liveswitch.MediaSenderInfo): string;
        /**
        Serializes an array to JSON.
        @param mediaSenders The array to serialize.
        @return The serialized JSON.
        */
        static toJsonArray(mediaSenders: fm.liveswitch.MediaSenderInfo[]): string;
        /**
        Deserializes the properties.
        @param key The key.
        @param valueJson The value in JSON format.
        */
        protected deserializeProperties(key: string, valueJson: string): void;
        /**
        Gets report.
        */
        getReport(): fm.liveswitch.MediaSenderReport;
        /**
        Gets source.
        */
        getSource(): fm.liveswitch.MediaSourceInfo;
        /**
        Serializes the properties.
        @param jsonObject The JSON object.
        */
        protected serializeProperties(jsonObject: fm.liveswitch.Hash<string, string>): void;
        /**
        Sets report.
        */
        setReport(value: fm.liveswitch.MediaSenderReport): void;
        /**
        Sets source.
        */
        setSource(value: fm.liveswitch.MediaSourceInfo): void;
        /**
        Serializes this instance to JSON.
        */
        toJson(): string;
    }
}
declare namespace fm.liveswitch {
    /**
    Media sender stats.
    */
    class MediaSenderStats extends fm.liveswitch.MediaComponentStats implements fm.liveswitch.IEquivalent<fm.liveswitch.MediaSenderStats> {
        getTypeString(): string;
        /** @hidden */
        private _bytesSent;
        /** @hidden */
        private _packetsSent;
        /** @hidden */
        private _roundTripTime;
        /** @hidden */
        private _source;
        private fmliveswitchMediaSenderStatsInit;
        constructor();
        /**
        Derializes media sender stats from JSON.
        @param mediaSenderJson The media sender's stats JSON.
        */
        static fromJson(mediaSenderJson: string): fm.liveswitch.MediaSenderStats;
        /**
        Derializes a media sender stats array from JSON.
        @param mediaSendersJson The media senders' stats JSON.
        */
        static fromJsonArray(mediaSendersJson: string): fm.liveswitch.MediaSenderStats[];
        /**
        Serializes media sender stats to JSON.
        @param mediaSender The media sender's stats.
        */
        static toJson(mediaSender: fm.liveswitch.MediaSenderStats): string;
        /**
        Serializes a media sender stats array to JSON.
        @param mediaSenders The media senders' stats.
        */
        static toJsonArray(mediaSenders: fm.liveswitch.MediaSenderStats[]): string;
        /**
        Deserializes the properties.
        @param key The key.
        @param valueJson The value in JSON format.
        */
        protected deserializeProperties(key: string, valueJson: string): void;
        /**
        Gets the number of bytes sent.
        */
        getBytesSent(): number;
        /**
        Gets the number of packets sent.
        */
        getPacketsSent(): number;
        /**
        Gets the round trip time in milliseconds.
        */
        getRoundTripTime(): number;
        /**
        Gets the source stats.
        */
        getSource(): fm.liveswitch.MediaSourceStats;
        /**
        Checks if a media sender is equivalent to this one.
        @param instance The media sender.
        */
        isEquivalent(instance: fm.liveswitch.MediaSenderStats): boolean;
        /**
        Serializes the properties.
        @param jsonObject The JSON object.
        */
        protected serializeProperties(jsonObject: fm.liveswitch.Hash<string, string>): void;
        /** @hidden */
        setBytesSent(value: number): void;
        /** @hidden */
        setPacketsSent(value: number): void;
        /** @hidden */
        setRoundTripTime(value: number): void;
        /** @hidden */
        setSource(value: fm.liveswitch.MediaSourceStats): void;
        /**
        Serializes this to JSON.
        */
        toJson(): string;
    }
}
declare namespace fm.liveswitch {
    /**
    Media sink information.
    */
    class MediaSinkInfo extends fm.liveswitch.Info {
        getTypeString(): string;
        /** @hidden */
        private _inputFormat;
        /** @hidden */
        private _label;
        /** @hidden */
        private _outputId;
        /** @hidden */
        private _outputName;
        /** @hidden */
        private _tag;
        /**
        Initializes a new instance of the [[fm.liveswitch.mediaSinkInfo]] class.
        */
        constructor();
        constructor(stats: fm.liveswitch.MediaSinkStats, lastStats: fm.liveswitch.MediaSinkStats);
        /**
        Deserializes an instance from JSON.
        @param mediaSinkInfoJson The serialized JSON.
        @return The deserialized instance.
        */
        static fromJson(mediaSinkInfoJson: string): fm.liveswitch.MediaSinkInfo;
        /**
        Deserializes an array from JSON.
        @param mediaSinkInfosJson The serialized JSON.
        @return The deserialized array.
        */
        static fromJsonArray(mediaSinkInfosJson: string): fm.liveswitch.MediaSinkInfo[];
        /**
        Serializes an instance to JSON.
        @param mediaSinkInfo The instance to serialize.
        @return The serialized JSON.
        */
        static toJson(mediaSinkInfo: fm.liveswitch.MediaSinkInfo): string;
        /**
        Serializes an array to JSON.
        @param mediaSinkInfos The array to serialize.
        @return The serialized JSON.
        */
        static toJsonArray(mediaSinkInfos: fm.liveswitch.MediaSinkInfo[]): string;
        /**
        Deserializes the properties.
        @param key The key.
        @param valueJson The value in JSON format.
        */
        protected deserializeProperties(key: string, valueJson: string): void;
        /**
        Gets the media sink input format.
        */
        getInputFormat(): fm.liveswitch.FormatInfo;
        /**
        Gets the media sink label.
        */
        getLabel(): string;
        /**
        Gets the media sink output id.
        */
        getOutputId(): string;
        /**
        Gets the media sink output name.
        */
        getOutputName(): string;
        /**
        Gets the media sink tag.
        */
        getTag(): string;
        /**
        Serializes the properties.
        @param jsonObject The JSON object.
        */
        protected serializeProperties(jsonObject: fm.liveswitch.Hash<string, string>): void;
        /**
        Sets the media sink input format.
        */
        setInputFormat(value: fm.liveswitch.FormatInfo): void;
        /**
        Sets the media sink label.
        */
        setLabel(value: string): void;
        /**
        Sets the media sink output id.
        */
        setOutputId(value: string): void;
        /**
        Sets the media sink output name.
        */
        setOutputName(value: string): void;
        /**
        Sets the media sink tag.
        */
        setTag(value: string): void;
        /**
        Serializes this instance to JSON.
        */
        toJson(): string;
    }
}
declare namespace fm.liveswitch {
    /**
    Media sink stats.
    */
    class MediaSinkStats extends fm.liveswitch.BaseStats implements fm.liveswitch.IEquivalent<fm.liveswitch.MediaSinkStats> {
        getTypeString(): string;
        /** @hidden */
        private _inputFormat;
        /** @hidden */
        private _label;
        /** @hidden */
        private _muted;
        /** @hidden */
        private _outputId;
        /** @hidden */
        private _outputName;
        /** @hidden */
        private _tag;
        private fmliveswitchMediaSinkStatsInit;
        constructor();
        /**
        Deserializes an instance from JSON.
        @param instanceJson The serialized JSON.
        @return The deserialized instance.
        */
        static fromJson(instanceJson: string): fm.liveswitch.MediaSinkStats;
        /**
        Deserializes an array from JSON.
        @param arrayJson The serialized JSON.
        @return The deserialized array.
        */
        static fromJsonArray(arrayJson: string): fm.liveswitch.MediaSinkStats[];
        /**
        Serializes an instance to JSON.
        @param instance The instance to serialize.
        @return Serialized JSON.
        */
        static toJson(instance: fm.liveswitch.MediaSinkStats): string;
        /**
        Serializes an array to JSON.
        @param array The array to serialize.
        @return The serialized JSON.
        */
        static toJsonArray(array: fm.liveswitch.MediaSinkStats[]): string;
        /**
        Deserializes the properties.
        @param key The key.
        @param valueJson The value in JSON format.
        */
        protected deserializeProperties(key: string, valueJson: string): void;
        /**
        Gets the input format.
        */
        getInputFormat(): fm.liveswitch.FormatInfo;
        /**
        Gets the label.
        */
        getLabel(): string;
        /**
        Gets the muted flag.
        */
        getMuted(): boolean;
        /**
        Gets the output identifier.
        */
        getOutputId(): string;
        /**
        Gets the output name.
        */
        getOutputName(): string;
        /**
        Gets the tag.
        */
        getTag(): string;
        /**
        Checks if a source is equivalent to this one.
        @param instance The source.
        */
        isEquivalent(instance: fm.liveswitch.MediaSinkStats): boolean;
        /**
        Serializes the properties.
        @param jsonObject The JSON object.
        */
        protected serializeProperties(jsonObject: fm.liveswitch.Hash<string, string>): void;
        /**
        Sets the input format.
        */
        setInputFormat(value: fm.liveswitch.FormatInfo): void;
        /**
        Sets the label.
        */
        setLabel(value: string): void;
        /**
        Sets the muted flag.
        */
        setMuted(value: boolean): void;
        /**
        Sets the output identifier.
        */
        setOutputId(value: string): void;
        /**
        Sets the output name.
        */
        setOutputName(value: string): void;
        /**
        Sets the tag.
        */
        setTag(value: string): void;
        /**
        Serializes this instance to JSON.
        */
        toJson(): string;
    }
}
declare namespace fm.liveswitch {
    /**
    Media source stats.
    */
    class MediaSourceStats extends fm.liveswitch.BaseStats implements fm.liveswitch.IEquivalent<fm.liveswitch.MediaSourceStats> {
        getTypeString(): string;
        /** @hidden */
        private _inputId;
        /** @hidden */
        private _inputName;
        /** @hidden */
        private _label;
        /** @hidden */
        private _muted;
        /** @hidden */
        private _outputFormat;
        /** @hidden */
        private _tag;
        private fmliveswitchMediaSourceStatsInit;
        constructor();
        /**
        Deserializes an instance from JSON.
        @param instanceJson The serialized Json.
        @return The deserialized VideoSourceInfo.
        */
        static fromJson(instanceJson: string): fm.liveswitch.MediaSourceStats;
        /**
        Serializes an instance to JSON.
        @param instance The instance to serialize.
        @return Serialized Json.
        */
        static toJson(instance: fm.liveswitch.MediaSourceStats): string;
        /**
        Deserializes the properties.
        @param key The key.
        @param valueJson The value in JSON format.
        */
        protected deserializeProperties(key: string, valueJson: string): void;
        /**
        Gets the input identifier.
        */
        getInputId(): string;
        /**
        Gets the input name.
        */
        getInputName(): string;
        /**
        Gets the label.
        */
        getLabel(): string;
        /**
        Gets the muted flag.
        */
        getMuted(): boolean;
        /**
        Gets the output format.
        */
        getOutputFormat(): fm.liveswitch.FormatInfo;
        /**
        Gets the tag.
        */
        getTag(): string;
        /**
        Checks if a source is equivalent to this one.
        @param instance The source.
        */
        isEquivalent(instance: fm.liveswitch.MediaSourceStats): boolean;
        /**
        Serializes the properties.
        @param jsonObject The JSON object.
        */
        protected serializeProperties(jsonObject: fm.liveswitch.Hash<string, string>): void;
        /**
        Sets the input identifier.
        */
        setInputId(value: string): void;
        /**
        Sets the input name.
        */
        setInputName(value: string): void;
        /**
        Sets the label.
        */
        setLabel(value: string): void;
        /**
        Sets the muted flag.
        */
        setMuted(value: boolean): void;
        /**
        Sets the output format.
        */
        setOutputFormat(value: fm.liveswitch.FormatInfo): void;
        /**
        Sets the tag.
        */
        setTag(value: string): void;
        /**
        Serializes this instance to JSON.
        */
        toJson(): string;
    }
}
declare namespace fm.liveswitch {
    /**
    Media stats.
    */
    class MediaStats extends fm.liveswitch.BaseStats {
        getTypeString(): string;
        /** @hidden */
        private _tracks;
        constructor();
        /**
        Derializes media stats from JSON.
        @param mediaJson The media's stats JSON.
        */
        static fromJson(mediaJson: string): fm.liveswitch.MediaStats;
        /**
        Serializes media stats to JSON.
        @param media The media's stats.
        */
        static toJson(media: fm.liveswitch.MediaStats): string;
        /**
        Deserializes the properties.
        @param key The key.
        @param valueJson The value in JSON format.
        */
        protected deserializeProperties(key: string, valueJson: string): void;
        /**
        Gets the first track's stats.
        */
        getTrack(): fm.liveswitch.MediaTrackStats;
        /**
        Gets a track by its identifier.
        @param trackId The track identifier.
        */
        getTrack(trackId: string): fm.liveswitch.MediaTrackStats;
        /**
        Gets the tracks' stats.
        */
        getTracks(): fm.liveswitch.MediaTrackStats[];
        /**
        Serializes the properties.
        @param jsonObject The JSON object.
        */
        protected serializeProperties(jsonObject: fm.liveswitch.Hash<string, string>): void;
        /** @hidden */
        setTracks(value: fm.liveswitch.MediaTrackStats[]): void;
        /**
        Serializes this to JSON.
        */
        toJson(): string;
    }
}
declare namespace fm.liveswitch {
    /**
    Encoding information.
    */
    class EncodingInfo extends fm.liveswitch.Info {
        getTypeString(): string;
        /** @hidden */
        private __bitrate;
        /** @hidden */
        private __frameRate;
        /** @hidden */
        private __scale;
        /** @hidden */
        private __synchronizationSource;
        /** @hidden */
        private _deactivated;
        /** @hidden */
        private _rtpStreamId;
        /** @hidden */
        private _size;
        /** @hidden */
        private static fm_liveswitch_EncodingInfo___pausedKey;
        private fmliveswitchEncodingInfoInit;
        constructor();
        /** @hidden */
        private static findEncoding;
        /**
        Deserializes an instance from JSON.
        @param encodingInfoJson The serialized JSON.
        @return The deserialized instance.
        */
        static fromJson(encodingInfoJson: string): fm.liveswitch.EncodingInfo;
        /**
        Deserializes an array from JSON.
        @param encodingInfosJson The serialized JSON.
        @return The deserialized array.
        */
        static fromJsonArray(encodingInfosJson: string): fm.liveswitch.EncodingInfo[];
        /**
        Converts an SDP RID attribute into an instance.
        @param ridAttribute The SDP RID attribute.
        */
        static fromSdpRidAttribute(ridAttribute: fm.liveswitch.sdp.rtp.RidAttribute): fm.liveswitch.EncodingInfo;
        /**
        Determines whether the two encodings are equivalent.
        @param encoding1 The first encoding.
        @param encoding2 The second encoding.
        */
        static isEquivalent(encoding1: fm.liveswitch.EncodingInfo, encoding2: fm.liveswitch.EncodingInfo): boolean;
        /**
        Determines whether the two encodings are equivalent.
        @param encoding1 The first encoding.
        @param encoding2 The second encoding.
        @param restrictionsOnly Whether to check restrictions only.
        */
        static isEquivalent(encoding1: fm.liveswitch.EncodingInfo, encoding2: fm.liveswitch.EncodingInfo, restrictionsOnly: boolean): boolean;
        /** @hidden */
        private static isEquivalentNoCheck;
        /**
        Returns a new encoding with each value being the maximum of two input encodings.
        @param encoding1 The first encoding.
        @param encoding2 The second encoding.
        @return A new encoding.
        */
        static max(encoding1: fm.liveswitch.EncodingInfo, encoding2: fm.liveswitch.EncodingInfo): fm.liveswitch.EncodingInfo;
        /** @hidden */
        private static maxDouble;
        /** @hidden */
        private static maxInteger;
        /** @hidden */
        private static maxSize;
        /** @hidden */
        static merge(encodings: fm.liveswitch.EncodingInfo[]): fm.liveswitch.EncodingInfo[];
        /**
        Returns a new encoding with each value being the minimum of two input encodings.
        @param encoding1 The first encoding.
        @param encoding2 The second encoding.
        @return A new encoding.
        */
        static min(encoding1: fm.liveswitch.EncodingInfo, encoding2: fm.liveswitch.EncodingInfo): fm.liveswitch.EncodingInfo;
        /** @hidden */
        private static minDouble;
        /** @hidden */
        private static minInteger;
        /** @hidden */
        private static minSize;
        /**
        Serializes an instance to JSON.
        @param encodingInfo The instance to serialize.
        @return The serialized JSON.
        */
        static toJson(encodingInfo: fm.liveswitch.EncodingInfo): string;
        /**
        Serializes an array to JSON.
        @param encodingInfos The array to serialize.
        @return The serialized JSON.
        */
        static toJsonArray(encodingInfos: fm.liveswitch.EncodingInfo[]): string;
        /**
        Converts an instance into an SDP RID attribute.
        @param encoding The encoding.
        @param direction The direction.
        */
        static toSdpRidAttribute(encoding: fm.liveswitch.EncodingInfo, direction: string): fm.liveswitch.sdp.rtp.RidAttribute;
        /**
        Converts an instance into an SDP RID attribute.
        @param encoding The encoding.
        @param direction The direction.
        @param includeRestrictions Whether to include restrictions.
        */
        static toSdpRidAttribute(encoding: fm.liveswitch.EncodingInfo, direction: string, includeRestrictions: boolean): fm.liveswitch.sdp.rtp.RidAttribute;
        /**
        Deserializes the properties.
        @param key The key.
        @param valueJson The value in JSON format.
        */
        protected deserializeProperties(key: string, valueJson: string): void;
        /** @hidden */
        extend(encoding: fm.liveswitch.EncodingInfo): fm.liveswitch.EncodingInfo;
        /**
        Gets the bitrate, in kbps.
        */
        getBitrate(): number;
        /**
        Gets whether this encoding is deactivated.
        */
        getDeactivated(): boolean;
        /**
        Gets the frame-rate, in fps.
        */
        getFrameRate(): number;
        /**
        Gets the height.
        */
        getHeight(): number;
        /**
        Gets whether this encoding is empty.
        */
        getIsEmpty(): boolean;
        /** @hidden */
        private getRidRestrictionValue;
        /**
        Gets the RTP stream identifier.
        */
        getRtpStreamId(): string;
        /**
        Gets the target scale.
        */
        getScale(): number;
        /**
        Gets the scaled height.
        */
        getScaledHeight(): number;
        /**
        Gets the scaled size.
        */
        getScaledSize(): fm.liveswitch.Size;
        /**
        Gets the scaled width.
        */
        getScaledWidth(): number;
        /** @hidden */
        getSdpRidRestrictions(): fm.liveswitch.sdp.rtp.RidRestriction[];
        /** @hidden */
        getSdpSimulcastStream(): fm.liveswitch.sdp.rtp.SimulcastStream;
        /** @hidden */
        getSdpSimulcastStreamId(): fm.liveswitch.sdp.rtp.SimulcastStreamId;
        /** @hidden */
        getSdpSsrcRestrictionAttributes(): fm.liveswitch.sdp.rtp.SsrcAttribute[];
        /**
        Gets the size.
        */
        getSize(): fm.liveswitch.Size;
        /** @hidden */
        private getSsrcRestrictionAttributeValue;
        /**
        Gets the synchronization source.
        */
        getSynchronizationSource(): number;
        /**
        Gets the width.
        */
        getWidth(): number;
        /**
        Determines whether the specified encoding is equivalent.
        @param encoding The encoding.
        */
        isEquivalent(encoding: fm.liveswitch.EncodingInfo): boolean;
        /**
        Determines whether the specified encoding is equivalent.
        @param encoding The encoding.
        @param restrictionsOnly Whether to check restrictions only.
        */
        isEquivalent(encoding: fm.liveswitch.EncodingInfo, restrictionsOnly: boolean): boolean;
        /** @hidden */
        private parseBitrate;
        /** @hidden */
        private parseDeactivated;
        /** @hidden */
        private parseFrameRate;
        /** @hidden */
        private parseSize;
        /**
        Serializes the properties.
        @param jsonObject The JSON object.
        */
        protected serializeProperties(jsonObject: fm.liveswitch.Hash<string, string>): void;
        /**
        Sets the bitrate, in kbps.
        */
        setBitrate(value: number): void;
        /**
        Sets whether this encoding is deactivated.
        */
        setDeactivated(value: boolean): void;
        /**
        Sets the frame-rate, in fps.
        */
        setFrameRate(value: number): void;
        /**
        Sets the RTP stream identifier.
        */
        setRtpStreamId(value: string): void;
        /**
        Sets the target scale.
        */
        setScale(value: number): void;
        /** @hidden */
        setSdpRidRestrictions(value: fm.liveswitch.sdp.rtp.RidRestriction[]): void;
        /** @hidden */
        setSdpSimulcastStreamId(value: fm.liveswitch.sdp.rtp.SimulcastStreamId): void;
        /** @hidden */
        setSdpSsrcRestrictionAttributes(value: fm.liveswitch.sdp.rtp.SsrcAttribute[]): void;
        /**
        Sets the size.
        */
        setSize(value: fm.liveswitch.Size): void;
        /**
        Sets the synchronization source.
        */
        setSynchronizationSource(value: number): void;
        /**
        Serializes this instance to JSON.
        */
        toJson(): string;
        /**
        Converts this instance into an SDP RID attribute.
        @param direction The direction.
        */
        toSdpRidAttribute(direction: string): fm.liveswitch.sdp.rtp.RidAttribute;
        /**
        Converts this instance into an SDP RID attribute.
        @param direction The direction.
        @param includeRestrictions Whether to include restrictions.
        */
        toSdpRidAttribute(direction: string, includeRestrictions: boolean): fm.liveswitch.sdp.rtp.RidAttribute;
        /**
        Returns a string that represents this instance.
        @return
                    A string that represents this instance.
            
        */
        toString(): string;
        /** @hidden */
        private static __fmliveswitchEncodingInfoInitialized;
        /** @hidden */
        private static __fmliveswitchEncodingInfoInitializing;
        /** @hidden */
        static fmliveswitchEncodingInfoInitialize(): void;
    }
}
declare namespace fm.liveswitch {
    /**
    Media stream information.
    */
    class MediaStreamInfo extends fm.liveswitch.StreamInfo {
        getTypeString(): string;
        /** @hidden */
        private __localBandwidth;
        /** @hidden */
        private __remoteBandwidth;
        /** @hidden */
        private _controlTransportId;
        /** @hidden */
        private _maxFrameHeight;
        /** @hidden */
        private _maxFrameWidth;
        /** @hidden */
        private _receiveDisabled;
        /** @hidden */
        private _receiveEncodings;
        /** @hidden */
        private _receiveFormats;
        /** @hidden */
        private _receivers;
        /** @hidden */
        private _sendDisabled;
        /** @hidden */
        private _sendEncodings;
        /** @hidden */
        private _senders;
        /** @hidden */
        private _sendFormats;
        /** @hidden */
        private _sendMuted;
        private fmliveswitchMediaStreamInfoInit;
        constructor();
        /**
        Deserializes an instance from JSON.
        @param mediaStreamInfoJson The serialized JSON.
        @return The deserialized instance.
        */
        static fromJson(mediaStreamInfoJson: string): fm.liveswitch.MediaStreamInfo;
        /**
        Deserializes an array from JSON.
        @param mediaStreamInfosJson The serialized JSON.
        @return The deserialized array.
        */
        static fromJsonArray(mediaStreamInfosJson: string): fm.liveswitch.MediaStreamInfo[];
        /**
        Serializes an instance to JSON.
        @param mediaStreamInfo The instance to serialize.
        @return The serialized JSON.
        */
        static toJson(mediaStreamInfo: fm.liveswitch.MediaStreamInfo): string;
        /**
        Serializes an array to JSON.
        @param mediaStreamInfos The array to serialize.
        @return The serialized JSON.
        */
        static toJsonArray(mediaStreamInfos: fm.liveswitch.MediaStreamInfo[]): string;
        /**
        Deserializes the properties.
        @param key The key.
        @param valueJson The value in JSON format.
        */
        protected deserializeProperties(key: string, valueJson: string): void;
        /** @hidden */
        private findMatchingReceiver;
        /** @hidden */
        private findMatchingSender;
        /**
        Gets the control transport id. This will be `null` if BUNDLE is active.
        */
        getControlTransportId(): string;
        /**
        Gets the media stream direction.
        */
        getDirection(): string;
        /**
        Gets the media stream's local bandwidth.
        */
        getLocalBandwidth(): number;
        /**
        Gets the media stream's maximum frame height.
        */
        getMaxFrameHeight(): number;
        /**
        Gets the media stream's maximum frame width.
        */
        getMaxFrameWidth(): number;
        /**
        Gets whether the media stream has the receive direction disabled.
        */
        getReceiveDisabled(): boolean;
        /**
        Gets the media stream receive encodings.
        */
        getReceiveEncodings(): fm.liveswitch.EncodingInfo[];
        /**
        Gets the media stream receive formats.
        */
        getReceiveFormats(): fm.liveswitch.FormatInfo[];
        /**
        Gets the first media stream receiver information.
        */
        getReceiver(): fm.liveswitch.MediaReceiverInfo;
        /**
        Gets the media stream receivers information.
        */
        getReceivers(): fm.liveswitch.MediaReceiverInfo[];
        /**
        Gets the media stream's remote bandwidth.
        */
        getRemoteBandwidth(): number;
        /**
        Gets whether the media stream has the send direction disabled.
        */
        getSendDisabled(): boolean;
        /**
        Gets the media stream send encodings.
        */
        getSendEncodings(): fm.liveswitch.EncodingInfo[];
        /**
        Gets the first media stream sender information.
        */
        getSender(): fm.liveswitch.MediaSenderInfo;
        /**
        Gets the media stream senders information.
        */
        getSenders(): fm.liveswitch.MediaSenderInfo[];
        /**
        Gets the media stream send formats.
        */
        getSendFormats(): fm.liveswitch.FormatInfo[];
        /**
        Gets whether the media stream has muted sending.
        */
        getSendMuted(): boolean;
        /** @hidden */
        populateInfos(stats: fm.liveswitch.MediaStreamStats, lastStats: fm.liveswitch.MediaStreamStats): void;
        /**
        Serializes the properties.
        @param jsonObject The JSON object.
        */
        protected serializeProperties(jsonObject: fm.liveswitch.Hash<string, string>): void;
        /**
        Sets the control transport id. This will be `null` if BUNDLE is active.
        */
        setControlTransportId(value: string): void;
        /**
        Sets the media stream direction.
        */
        setDirection(value: string): void;
        /**
        Sets the media stream's local bandwidth.
        */
        setLocalBandwidth(value: number): void;
        /**
        Sets the media stream's maximum frame height.
        */
        setMaxFrameHeight(value: number): void;
        /**
        Sets the media stream's maximum frame width.
        */
        setMaxFrameWidth(value: number): void;
        /**
        Sets whether the media stream has the receive direction disabled.
        */
        setReceiveDisabled(value: boolean): void;
        /**
        Sets the media stream receive encodings.
        */
        setReceiveEncodings(value: fm.liveswitch.EncodingInfo[]): void;
        /**
        Sets the media stream receive formats.
        */
        setReceiveFormats(value: fm.liveswitch.FormatInfo[]): void;
        /**
        Sets the media stream receivers information.
        */
        setReceivers(value: fm.liveswitch.MediaReceiverInfo[]): void;
        /**
        Sets the media stream's remote bandwidth.
        */
        setRemoteBandwidth(value: number): void;
        /**
        Sets whether the media stream has the send direction disabled.
        */
        setSendDisabled(value: boolean): void;
        /**
        Sets the media stream send encodings.
        */
        setSendEncodings(value: fm.liveswitch.EncodingInfo[]): void;
        /**
        Sets the media stream senders information.
        */
        setSenders(value: fm.liveswitch.MediaSenderInfo[]): void;
        /**
        Sets the media stream send formats.
        */
        setSendFormats(value: fm.liveswitch.FormatInfo[]): void;
        /**
        Sets whether the media stream has muted sending.
        */
        setSendMuted(value: boolean): void;
        /**
        Serializes this instance to JSON.
        */
        toJson(): string;
    }
}
declare namespace fm.liveswitch {
    /**
    Media stream stats.
    */
    class MediaStreamStats extends fm.liveswitch.StreamStats {
        getTypeString(): string;
        /** @hidden */
        private _direction;
        /** @hidden */
        private _maxReceiveBitrate;
        /** @hidden */
        private _maxSendBitrate;
        /** @hidden */
        private _receivers;
        /** @hidden */
        private _senders;
        private fmliveswitchMediaStreamStatsInit;
        constructor();
        /**
        Derializes media stream stats from JSON.
        @param mediaStreamJson The media stream's stats JSON.
        */
        static fromJson(mediaStreamJson: string): fm.liveswitch.MediaStreamStats;
        /**
        Derializes an array of media stream stats from JSON.
        @param mediaStreamsJson The media streams' stats JSON.
        */
        static fromJsonArray(mediaStreamsJson: string): fm.liveswitch.MediaStreamStats[];
        /**
        Serializes media stream stats to JSON.
        @param mediaStream The media stream's stats.
        */
        static toJson(mediaStream: fm.liveswitch.MediaStreamStats): string;
        /**
        Serializes an array of media stream stats to JSON.
        @param mediaStreams The media streams' stats.
        */
        static toJsonArray(mediaStreams: fm.liveswitch.MediaStreamStats[]): string;
        /**
        Deserializes the properties.
        @param key The key.
        @param valueJson The value in JSON format.
        */
        protected deserializeProperties(key: string, valueJson: string): void;
        /**
        Gets the direction.
        */
        getDirection(): fm.liveswitch.StreamDirection;
        /**
        Gets the max receive bitrate.
        */
        getMaxReceiveBitrate(): number;
        /**
        Gets the max send bitrate.
        */
        getMaxSendBitrate(): number;
        /**
        Gets the first receiver's stats.
        */
        getReceiver(): fm.liveswitch.MediaReceiverStats;
        /**
        Gets the receivers' stats.
        */
        getReceivers(): fm.liveswitch.MediaReceiverStats[];
        /**
        Gets the first sender's stats.
        */
        getSender(): fm.liveswitch.MediaSenderStats;
        /**
        Gets the senders' stats.
        */
        getSenders(): fm.liveswitch.MediaSenderStats[];
        /**
        Serializes the properties.
        @param jsonObject The JSON object.
        */
        protected serializeProperties(jsonObject: fm.liveswitch.Hash<string, string>): void;
        /** @hidden */
        setDirection(value: fm.liveswitch.StreamDirection): void;
        /** @hidden */
        setMaxReceiveBitrate(value: number): void;
        /** @hidden */
        setMaxSendBitrate(value: number): void;
        /** @hidden */
        setReceivers(value: fm.liveswitch.MediaReceiverStats[]): void;
        /** @hidden */
        setSenders(value: fm.liveswitch.MediaSenderStats[]): void;
        /**
        Serializes this to JSON.
        */
        toJson(): string;
    }
}
declare namespace fm.liveswitch {
    /**
    Media track information
    */
    class MediaTrackInfo extends fm.liveswitch.Info {
        getTypeString(): string;
        /** @hidden */
        private _detached;
        /** @hidden */
        private _muted;
        /** @hidden */
        private _report;
        /** @hidden */
        private _stopped;
        private fmliveswitchMediaTrackInfoInit;
        /**
        Create MediaTrackInfo instance.
        */
        constructor();
        /**
        Create MediaTrackInfo instance.
        @param stats
        @param lastStats
        */
        constructor(stats: fm.liveswitch.MediaTrackStats, lastStats: fm.liveswitch.MediaTrackStats);
        /**
        Deserializes an instance from JSON.
        @param mediaTrackInfoJson The serialized JSON.
        @return The deserialized instance.
        */
        static fromJson(mediaTrackInfoJson: string): fm.liveswitch.MediaTrackInfo;
        /**
        Deserializes an array from JSON.
        @param mediaTrackInfosJson The serialized JSON.
        @return The deserialized array.
        */
        static fromJsonArray(mediaTrackInfosJson: string): fm.liveswitch.MediaTrackInfo[];
        /**
        Serializes an instance to JSON.
        @param mediaTrackInfo The instance to serialize.
        @return The serialized JSON.
        */
        static toJson(mediaTrackInfo: fm.liveswitch.MediaTrackInfo): string;
        /**
        Serializes an array to JSON.
        @param mediaTrackInfos The array to serialize.
        @return The serialized JSON.
        */
        static toJsonArray(mediaTrackInfos: fm.liveswitch.MediaTrackInfo[]): string;
        /**
        Deserializes the properties.
        @param key The key.
        @param valueJson The value in JSON format.
        */
        protected deserializeProperties(key: string, valueJson: string): void;
        /**
        Gets the whether the media track is detached.
        */
        getDetached(): boolean;
        /**
        Gets the whether the media track is muted.
        */
        getMuted(): boolean;
        /**
        Gets the data stream report.
        */
        getReport(): fm.liveswitch.MediaTrackReport;
        /**
        Gets the whether the media track is stopped.
        */
        getStopped(): boolean;
        /**
        Serializes the properties.
        @param jsonObject The JSON object.
        */
        protected serializeProperties(jsonObject: fm.liveswitch.Hash<string, string>): void;
        /**
        Sets the whether the media track is detached.
        */
        setDetached(value: boolean): void;
        /**
        Sets the whether the media track is muted.
        */
        setMuted(value: boolean): void;
        /**
        Sets the data stream report.
        */
        setReport(value: fm.liveswitch.MediaTrackReport): void;
        /**
        Sets the whether the media track is stopped.
        */
        setStopped(value: boolean): void;
        /**
        Serializes this instance to JSON.
        */
        toJson(): string;
    }
}
declare namespace fm.liveswitch {
    /**
    Media track stats.
    */
    class MediaTrackStats extends fm.liveswitch.BaseStats implements fm.liveswitch.IEquivalent<fm.liveswitch.MediaTrackStats> {
        getTypeString(): string;
        /** @hidden */
        private _bitrate;
        /** @hidden */
        private _detached;
        /** @hidden */
        private _frameHeight;
        /** @hidden */
        private _frameRate;
        /** @hidden */
        private _framesCorrupted;
        /** @hidden */
        private _framesDecoded;
        /** @hidden */
        private _framesDropped;
        /** @hidden */
        private _framesEncoded;
        /** @hidden */
        private _framesReceived;
        /** @hidden */
        private _framesSent;
        /** @hidden */
        private _frameWidth;
        /** @hidden */
        private _maxBitrate;
        /** @hidden */
        private _minBitrate;
        /** @hidden */
        private _muted;
        /** @hidden */
        private _repairedRtpStreamIds;
        /** @hidden */
        private _rtpStreamIds;
        /** @hidden */
        private _stopped;
        /** @hidden */
        private _synchronizationSources;
        private fmliveswitchMediaTrackStatsInit;
        constructor();
        /**
        Derializes media track stats from JSON.
        @param mediaTrackJson The media track's stats JSON.
        */
        static fromJson(mediaTrackJson: string): fm.liveswitch.MediaTrackStats;
        /**
        Derializes an array of media track stats from JSON.
        @param mediaTracksJson The media tracks' stats JSON.
        */
        static fromJsonArray(mediaTracksJson: string): fm.liveswitch.MediaTrackStats[];
        /**
        Serializes media track stats to JSON.
        @param mediaTrack The media track's stats.
        */
        static toJson(mediaTrack: fm.liveswitch.MediaTrackStats): string;
        /**
        Serializes an array of media track stats to JSON.
        @param mediaTracks The media tracks' stats.
        */
        static toJsonArray(mediaTracks: fm.liveswitch.MediaTrackStats[]): string;
        /**
        Deserializes the properties.
        @param key The key.
        @param valueJson The value in JSON format.
        */
        protected deserializeProperties(key: string, valueJson: string): void;
        /**
        Gets the bitrate. Set by the encoder.
        */
        getBitrate(): number;
        /**
        Gets whether the track is detached.
        */
        getDetached(): boolean;
        /**
        Gets the frame height. Video-only. Set by encoder or decoder.
        */
        getFrameHeight(): number;
        /**
        Gets the frame rate. Video-only. Set by encoder or decoder.
        */
        getFrameRate(): number;
        /**
        Gets the number of corrupted frames. Video-only. Set by depacketizer.
        */
        getFramesCorrupted(): number;
        /**
        Gets the number of frames decoded. Set by decoder.
        */
        getFramesDecoded(): number;
        /**
        Gets the number of frames dropped. Video-only. Set by depacketizer.
        */
        getFramesDropped(): number;
        /**
        Gets the number of frames encoded. Set by encoder.
        */
        getFramesEncoded(): number;
        /**
        Gets the number of frames received. Set by depacketizer.
        */
        getFramesReceived(): number;
        /**
        Gets the number of frames sent. Set by packetizer.
        */
        getFramesSent(): number;
        /**
        Gets the frame width. Video-only. Set by encoder or decoder.
        */
        getFrameWidth(): number;
        /**
        Gets the maximum bitrate. Set by the encoder.
        */
        getMaxBitrate(): number;
        /**
        Gets the minimum bitrate. Set by the encoder.
        */
        getMinBitrate(): number;
        /**
        Gets whether the track is muted.
        */
        getMuted(): boolean;
        /**
        Gets the first repaired RTP stream identifier.
        */
        getRepairedRtpStreamId(): string;
        /**
        Gets the repaired RTP stream identifiers.
        */
        getRepairedRtpStreamIds(): string[];
        /**
        Gets the first RTP stream identifier.
        */
        getRtpStreamId(): string;
        /**
        Gets the RTP stream identifiers.
        */
        getRtpStreamIds(): string[];
        /**
        Gets whether the track is stopped. Set by source.
        */
        getStopped(): boolean;
        /**
        Gets the first synchronization source.
        */
        getSynchronizationSource(): number;
        /**
        Gets the synchronization sources.
        */
        getSynchronizationSources(): number[];
        /**
        Checks if a track is equivalent to this one.
        @param instance The track.
        */
        isEquivalent(instance: fm.liveswitch.MediaTrackStats): boolean;
        /**
        Serializes the properties.
        @param jsonObject The JSON object.
        */
        protected serializeProperties(jsonObject: fm.liveswitch.Hash<string, string>): void;
        /** @hidden */
        setBitrate(value: number): void;
        /** @hidden */
        setDetached(value: boolean): void;
        /** @hidden */
        setFrameHeight(value: number): void;
        /** @hidden */
        setFrameRate(value: number): void;
        /** @hidden */
        setFramesCorrupted(value: number): void;
        /** @hidden */
        setFramesDecoded(value: number): void;
        /** @hidden */
        setFramesDropped(value: number): void;
        /** @hidden */
        setFramesEncoded(value: number): void;
        /** @hidden */
        setFramesReceived(value: number): void;
        /** @hidden */
        setFramesSent(value: number): void;
        /** @hidden */
        setFrameWidth(value: number): void;
        /** @hidden */
        setMaxBitrate(value: number): void;
        /** @hidden */
        setMinBitrate(value: number): void;
        /** @hidden */
        setMuted(value: boolean): void;
        /** @hidden */
        setRepairedRtpStreamIds(value: string[]): void;
        /** @hidden */
        setRtpStreamIds(value: string[]): void;
        /** @hidden */
        setStopped(value: boolean): void;
        /** @hidden */
        setSynchronizationSources(value: number[]): void;
        /**
        Serializes this to JSON.
        */
        toJson(): string;
    }
}
declare namespace fm.liveswitch {
    /**
    Media source information.
    */
    class MediaSourceInfo extends fm.liveswitch.Info {
        getTypeString(): string;
        /** @hidden */
        private _inputId;
        /** @hidden */
        private _inputName;
        /** @hidden */
        private _label;
        /** @hidden */
        private _muted;
        /** @hidden */
        private _outputFormat;
        /** @hidden */
        private _tag;
        private fmliveswitchMediaSourceInfoInit;
        /**
        Initializes a new instance of the [[fm.liveswitch.mediaSourceInfo]] class.
        */
        constructor();
        constructor(stats: fm.liveswitch.MediaSourceStats, lastStats: fm.liveswitch.MediaSourceStats);
        /**
        Deserializes an instance from JSON.
        @param mediaSourceInfoJson The serialized JSON.
        @return The deserialized instance.
        */
        static fromJson(mediaSourceInfoJson: string): fm.liveswitch.MediaSourceInfo;
        /**
        Deserializes an array from JSON.
        @param mediaSourceInfosJson The serialized JSON.
        @return The deserialized array.
        */
        static fromJsonArray(mediaSourceInfosJson: string): fm.liveswitch.MediaSourceInfo[];
        /**
        Serializes an instance to JSON.
        @param mediaSourceInfo The instance to serialize.
        @return The serialized JSON.
        */
        static toJson(mediaSourceInfo: fm.liveswitch.MediaSourceInfo): string;
        /**
        Serializes an array to JSON.
        @param mediaSourceInfos The array to serialize.
        @return The serialized JSON.
        */
        static toJsonArray(mediaSourceInfos: fm.liveswitch.MediaSourceInfo[]): string;
        /**
        Deserializes the properties.
        @param key The key.
        @param valueJson The value in JSON format.
        */
        protected deserializeProperties(key: string, valueJson: string): void;
        /**
        Gets the media source input identifier.
        */
        getInputId(): string;
        /**
        Gets the media source input name.
        */
        getInputName(): string;
        /**
        Gets the media source label.
        */
        getLabel(): string;
        /**
        Gets the whether the media source is muted.
        */
        getMuted(): boolean;
        /**
        Gets the media source output format.
        */
        getOutputFormat(): fm.liveswitch.FormatInfo;
        /**
        Gets the media source tag.
        */
        getTag(): string;
        /**
        Serializes the properties.
        @param jsonObject The JSON object.
        */
        protected serializeProperties(jsonObject: fm.liveswitch.Hash<string, string>): void;
        /**
        Sets the media source input identifier.
        */
        setInputId(value: string): void;
        /**
        Sets the media source input name.
        */
        setInputName(value: string): void;
        /**
        Sets the media source label.
        */
        setLabel(value: string): void;
        /**
        Sets the whether the media source is muted.
        */
        setMuted(value: boolean): void;
        /**
        Sets the media source output format.
        */
        setOutputFormat(value: fm.liveswitch.FormatInfo): void;
        /**
        Sets the media source tag.
        */
        setTag(value: string): void;
        /**
        Serializes this instance to JSON.
        */
        toJson(): string;
    }
}
declare namespace fm.liveswitch {
    /**
    A point (x and y coordinates).
    */
    class Point {
        getTypeString(): string;
        /** @hidden */
        private __x;
        /** @hidden */
        private __y;
        /** @hidden */
        private static fm_liveswitch_Point___empty;
        private fmliveswitchPointInit;
        /**
        Initializes a new instance of the [[fm.liveswitch.point]] class.
        */
        constructor();
        /**
        Initializes a new instance of the [[fm.liveswitch.point]] class.
        @param x The X coordinate.
        @param y The Y coordinate.
        */
        constructor(x: number, y: number);
        /**
        Deserializes an instance from JSON.
        @param pointJson The JSON to deserialize.
        @return The deserialized point.
        */
        static fromJson(pointJson: string): fm.liveswitch.Point;
        /**
        Gets the empty point (0,0).
        */
        static getEmpty(): fm.liveswitch.Point;
        /**
        Determines whether the two points are equivalent.
        @param point1 The first point.
        @param point2 The second point.
        */
        static isEquivalent(point1: fm.liveswitch.Point, point2: fm.liveswitch.Point): boolean;
        /** @hidden */
        private static isEquivalentNoCheck;
        /**
        Serializes an instance to JSON.
        @param point The point.
        @return
                    The serialized JSON.
            
        */
        static toJson(point: fm.liveswitch.Point): string;
        /**
        Gets the X coordinate.
        */
        getX(): number;
        /**
        Gets the Y coordinate.
        */
        getY(): number;
        /**
        Determines whether the specified point is equivalent.
        @param point The point.
        */
        isEquivalent(point: fm.liveswitch.Point): boolean;
        /**
        Sets the X coordinate.
        */
        setX(value: number): void;
        /**
        Sets the Y coordinate.
        */
        setY(value: number): void;
        /**
        Serializes this instance to JSON.
        @return
                    The serialized JSON.
            
        */
        toJson(): string;
        /**
        Returns a string that represents this instance using format "{x},{y}".
        */
        toString(): string;
    }
}
declare namespace fm.liveswitch {
    /**
    A rectangle (size and origin).
    */
    class Rectangle {
        getTypeString(): string;
        /** @hidden */
        private __origin;
        /** @hidden */
        private __size;
        /** @hidden */
        private static fm_liveswitch_Rectangle___empty;
        /**
        Initializes a new instance of the [[fm.liveswitch.rectangle]] class.
        */
        constructor();
        /**
        Initializes a new instance of the [[fm.liveswitch.rectangle]] class.
        @param origin The origin.
        @param size The size.
        */
        constructor(origin: fm.liveswitch.Point, size: fm.liveswitch.Size);
        /**
        Deserializes an instance from JSON.
        @param rectangleJson The JSON to deserialize.
        @return The deserialized rectangle.
        */
        static fromJson(rectangleJson: string): fm.liveswitch.Rectangle;
        /**
        Gets the empty rectangle (0,0/0x0).
        */
        static getEmpty(): fm.liveswitch.Rectangle;
        /**
        Determines whether the two rectangles are equivalent.
        @param rectangle1 The first rectangle.
        @param rectangle2 The second rectangle.
        */
        static isEquivalent(rectangle1: fm.liveswitch.Rectangle, rectangle2: fm.liveswitch.Rectangle): boolean;
        /** @hidden */
        private static isEquivalentNoCheck;
        /**
        Serializes an instance to JSON.
        @param rectangle The rectangle.
        @return
                    The serialized JSON.
            
        */
        static toJson(rectangle: fm.liveswitch.Rectangle): string;
        /**
        Gets the size height.
        */
        getHeight(): number;
        /**
        Gets the origin.
        */
        getOrigin(): fm.liveswitch.Point;
        /**
        Gets the size.
        */
        getSize(): fm.liveswitch.Size;
        /**
        Gets the size width.
        */
        getWidth(): number;
        /**
        Gets the origin X coordinate.
        */
        getX(): number;
        /**
        Gets the origin Y coordinate.
        */
        getY(): number;
        /**
        Determines whether the specified rectangle is equivalent.
        @param rectangle The rectangle.
        */
        isEquivalent(rectangle: fm.liveswitch.Rectangle): boolean;
        /**
        Sets the origin.
        */
        setOrigin(value: fm.liveswitch.Point): void;
        /**
        Sets the size.
        */
        setSize(value: fm.liveswitch.Size): void;
        /**
        Serializes this instance to JSON.
        @return
                    The serialized JSON.
            
        */
        toJson(): string;
        /**
        Returns a string that represents this instance using format "{origin}/{size}".
        */
        toString(): string;
    }
}
declare namespace fm.liveswitch.sdp {
    /**
    Defines valid SDP address types.
    */
    abstract class AddressType {
        getTypeString(): string;
        /**
        Gets the SDP address type for the specified IP address.
        @param ipAddress The IP address.
        */
        static getAddressTypeForAddress(ipAddress: string): string;
        /**
        Gets the SDP address type meaning "IP version 4".
        */
        static getIP4(): string;
        /**
        Gets the SDP address type meaning "IP version 6".
        */
        static getIP6(): string;
    }
}
declare namespace fm.liveswitch.sdp {
    class AttributeCategoryWrapper {
        getTypeString(): string;
        /** @hidden */
        private _value;
        constructor(value: fm.liveswitch.sdp.AttributeCategory);
        toString(): string;
    }
}
declare namespace fm.liveswitch.sdp {
    /** @hidden */
    class AttributeCollection {
        getTypeString(): string;
        /** @hidden */
        private __attributes;
        constructor();
        addAttribute(attribute: fm.liveswitch.sdp.Attribute): void;
        remove(attribute: fm.liveswitch.sdp.Attribute): boolean;
        remove(attributeType: fm.liveswitch.sdp.AttributeType): boolean;
        replaceAttribute(attribute: fm.liveswitch.sdp.Attribute): void;
        toArray(): fm.liveswitch.sdp.Attribute[];
        tryGetAttribute(type: fm.liveswitch.sdp.AttributeType, attribute: fm.liveswitch.Holder<fm.liveswitch.sdp.Attribute>): boolean;
        tryGetAttributes(type: fm.liveswitch.sdp.AttributeType, attributes: fm.liveswitch.Holder<fm.liveswitch.sdp.Attribute[]>): boolean;
    }
}
declare namespace fm.liveswitch.sdp {
    /** @hidden */
    class AttributeCreationArgs {
        getTypeString(): string;
        /** @hidden */
        private _value;
        constructor(value: string);
        getValue(): string;
        /** @hidden */
        private setValue;
    }
}
declare namespace fm.liveswitch.sdp {
    /** @hidden */
    class AttributeRegistration {
        getTypeString(): string;
        /** @hidden */
        private _creationDelegate;
        /** @hidden */
        private _mediaLevel;
        /** @hidden */
        private _name;
        /** @hidden */
        private _sessionLevel;
        private fmliveswitchsdpAttributeRegistrationInit;
        constructor(name: string, sessionLevel: boolean, mediaLevel: boolean, creationDelegate: fm.liveswitch.IFunction1<fm.liveswitch.sdp.AttributeCreationArgs, fm.liveswitch.sdp.Attribute>);
        getCreationDelegate(): fm.liveswitch.IFunction1<fm.liveswitch.sdp.AttributeCreationArgs, fm.liveswitch.sdp.Attribute>;
        getMediaLevel(): boolean;
        getName(): string;
        getSessionLevel(): boolean;
        setCreationDelegate(value: fm.liveswitch.IFunction1<fm.liveswitch.sdp.AttributeCreationArgs, fm.liveswitch.sdp.Attribute>): void;
        setMediaLevel(value: boolean): void;
        setName(value: string): void;
        setSessionLevel(value: boolean): void;
    }
}
declare namespace fm.liveswitch.sdp {
    class AttributeTypeWrapper {
        getTypeString(): string;
        /** @hidden */
        private _value;
        constructor(value: fm.liveswitch.sdp.AttributeType);
        toString(): string;
    }
}
declare namespace fm.liveswitch.sdp {
    /**
    An SDP bandwidth element.
    */
    class Bandwidth {
        getTypeString(): string;
        /** @hidden */
        private _bandwidthType;
        /** @hidden */
        private _value;
        private fmliveswitchsdpBandwidthInit;
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.bandwidth]] class.
        @param bandwidthType The type of bandwidth. See [[fm.liveswitch.sdp.bandwidth.bandwidthType]] for possible values.
        @param value The bandwidth, typically in kilobits per second.
        */
        constructor(bandwidthType: string, value: number);
        /**
        Creates an [[fm.liveswitch.sdp.bandwidth]] instance from a string.
        @param s The string to parse.
        */
        static parse(s: string): fm.liveswitch.sdp.Bandwidth;
        /**
        Gets the type of bandwidth. See [[fm.liveswitch.sdp.bandwidth.bandwidthType]] for possible values.
        */
        getBandwidthType(): string;
        /**
        Gets the bandwidth, typically in kilobits per second.
        */
        getValue(): number;
        /** @hidden */
        private setBandwidthType;
        /** @hidden */
        private setValue;
        /**
        Converts this instance to a string.
        */
        toString(): string;
    }
}
declare namespace fm.liveswitch.sdp {
    /**
    Defines valid SDP bandwidth types.
    */
    abstract class BandwidthType {
        getTypeString(): string;
        /**
        Gets the SDP bandwidth type meaning "Application Specific".
        */
        static getApplicationSpecific(): string;
        /**
        Gets the SDP bandwidth type meaning "Conference Total".
        */
        static getConferenceTotal(): string;
        /**
        Gets the SDP bandwidth type meaning "RTCP Receivers".
        */
        static getRtcpReceivers(): string;
        /**
        Gets the SDP bandwidth type meaning "RTCP Senders".
        */
        static getRtcpSenders(): string;
        /**
        Gets the SDP bandwidth type meaning "Transport Independent Application Specific Maximum".
        */
        static getTransportIndependentApplicationSpecificMaximum(): string;
    }
}
declare namespace fm.liveswitch.sdp {
    /**
    An SDP encryption key element.
    */
    abstract class EncryptionKey {
        getTypeString(): string;
        constructor();
        /**
        Creates an [[fm.liveswitch.sdp.encryptionKey]] instance from a string.
        @param s The string to parse.
        */
        static parse(s: string): fm.liveswitch.sdp.EncryptionKey;
        /** @hidden */
        abstract getMethodAndValue(): string;
        /**
        Converts this instance to a string.
        */
        toString(): string;
    }
}
declare namespace fm.liveswitch.sdp {
    /**
    An SDP encryption key with a method of "base64".
    */
    class Base64EncryptionKey extends fm.liveswitch.sdp.EncryptionKey {
        getTypeString(): string;
        /** @hidden */
        private _encodedEncryptionKey;
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.base64EncryptionKey]] class.
        @param encodedEncryptionKey The base64-encoded encryption key.
        */
        constructor(encodedEncryptionKey: string);
        /**
        Gets the base64-encoded encryption key.
        */
        getEncodedEncryptionKey(): string;
        /** @hidden */
        getMethodAndValue(): string;
        /** @hidden */
        private setEncodedEncryptionKey;
    }
}
declare namespace fm.liveswitch.sdp {
    /**
    Defined in draft-ietf-mmusic-sdp-bundle-negotiation. Attribute is used to identify that a gioven media description can only be used  in bundled group. Its formatting in SDP is described by the following BNF: Name: bundle-only  Value: N/A  Usage Level: media  Charset Dependent: no  Example:  a=bundle-only
    */
    class BundleOnlyAttribute extends fm.liveswitch.sdp.Attribute {
        getTypeString(): string;
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.bundleOnlyAttribute]] class.
        */
        constructor();
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.groupAttribute]] class.
        @param value The attribute value.
        */
        static fromAttributeValue(value: string): fm.liveswitch.sdp.BundleOnlyAttribute;
        /**
        Gets the internal value of the attribute.
        */
        protected getAttributeValue(): string;
    }
}
declare namespace fm.liveswitch.sdp {
    /**
    This attribute gives the dot-separated hierarchical category of the session.  This is to enable a receiver to filter unwanted sessions by category.  There is no central registry of categories.  It is a session-level attribute, and it is not dependent on charset.
    */
    class CategoryAttribute extends fm.liveswitch.sdp.Attribute {
        getTypeString(): string;
        /** @hidden */
        private _category;
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.categoryAttribute]] class.
        @param category The dot-separated hierarchical category of the session.
        */
        constructor(category: string);
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.categoryAttribute]] class.
        @param value The attribute value.
        */
        static fromAttributeValue(value: string): fm.liveswitch.sdp.CategoryAttribute;
        /**
        Gets the internal value of the attribute.
        */
        protected getAttributeValue(): string;
        /**
        Gets the dot-separated hierarchical category of the session.
        */
        getCategory(): string;
        /** @hidden */
        private setCategory;
    }
}
declare namespace fm.liveswitch.sdp {
    /**
    This specifies the character set to be used to display the session name and information data.  By default, the ISO-10646 character set in UTF-8 encoding is used.  If a more compact representation is required, other character sets may be used. For example, the ISO 8859-1 is specified with the following SDP attribute:  a=charset:ISO-8859-1
    */
    class CharacterSetAttribute extends fm.liveswitch.sdp.Attribute {
        getTypeString(): string;
        /** @hidden */
        private _characterSet;
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.characterSetAttribute]] class.
        @param characterSet The character set to be used to display the session name and information data.
        */
        constructor(characterSet: string);
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.characterSetAttribute]] class.
        @param value The attribute value.
        */
        static fromAttributeValue(value: string): fm.liveswitch.sdp.CharacterSetAttribute;
        /**
        Gets the internal value of the attribute.
        */
        protected getAttributeValue(): string;
        /**
        Gets the character set to be used to display the session name and information data.
        */
        getCharacterSet(): string;
        /** @hidden */
        private setCharacterSet;
    }
}
declare namespace fm.liveswitch.sdp {
    /**
    An SDP encryption key with a method of "clear".
    */
    class ClearEncryptionKey extends fm.liveswitch.sdp.EncryptionKey {
        getTypeString(): string;
        /** @hidden */
        private _encryptionKey;
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.clearEncryptionKey]] class.
        @param encryptionKey The untransformed encryption key.
        */
        constructor(encryptionKey: string);
        /**
        Gets the untransformed encryption key.
        */
        getEncryptionKey(): string;
        /** @hidden */
        getMethodAndValue(): string;
        /** @hidden */
        private setEncryptionKey;
    }
}
declare namespace fm.liveswitch.sdp {
    /**
    Defines valid SDP conference types.
    */
    abstract class ConferenceType {
        getTypeString(): string;
        /**
        Gets the SDP conference type meaning "Broadcast", which should imply receive-only.
        */
        static getBroadcast(): string;
        /**
        Gets the SDP conference type meaning "H332", which should imply receive-only and indicate that this loosely coupled session is part of an H.332 session.
        */
        static getH332(): string;
        /**
        Gets the SDP conference type meaning "Meeting", which should imply send-receive.
        */
        static getMeeting(): string;
        /**
        Gets the SDP conference type meaning "Moderated", which should indicate the use of a floor control tool and that the media tools are started so as to mute new sites joining the conference.
        */
        static getModerated(): string;
        /**
        Gets the SDP conference type meaning "Test", which should imply that unless explicitly requested otherwise, receivers can safely avoid displaying this session description to users.
        */
        static getTest(): string;
    }
}
declare namespace fm.liveswitch.sdp {
    /**
    This specifies the type of the conference.  Suggested values are "broadcast", "meeting", "moderated", "test", and "H332". "recvonly" should be the default for "type:broadcast" sessions, "type:meeting" should imply "sendrecv", and "type:moderated" should indicate the use of a floor control tool and that the media tools are started so as to mute new sites joining the conference.
    */
    class ConferenceTypeAttribute extends fm.liveswitch.sdp.Attribute {
        getTypeString(): string;
        /** @hidden */
        private _conferenceType;
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.conferenceTypeAttribute]] class.
        @param conferenceType The type of the conference. See [[fm.liveswitch.sdp.conferenceTypeAttribute.conferenceType]] for possible values.
        */
        constructor(conferenceType: string);
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.conferenceTypeAttribute]] class.
        @param value The attribute value.
        */
        static fromAttributeValue(value: string): fm.liveswitch.sdp.ConferenceTypeAttribute;
        /**
        Gets the internal value of the attribute.
        */
        protected getAttributeValue(): string;
        /**
        Gets the type of the conference. See [[fm.liveswitch.sdp.conferenceTypeAttribute.conferenceType]] for possible values.
        */
        getConferenceType(): string;
        /** @hidden */
        private setConferenceType;
    }
}
declare namespace fm.liveswitch.sdp {
    /**
    An SDP connection data element.
    */
    class ConnectionData {
        getTypeString(): string;
        /** @hidden */
        private _addressType;
        /** @hidden */
        private _connectionAddress;
        /** @hidden */
        private _networkType;
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.connectionData]] class.
        @param connectionAddress The connection address.
        */
        constructor(connectionAddress: string);
        /**
        Creates an [[fm.liveswitch.sdp.connectionData]] instance from a string.
        @param s The string to parse.
        */
        static parse(s: string): fm.liveswitch.sdp.ConnectionData;
        /**
        Gets the type of the address. See [[fm.liveswitch.sdp.connectionData.addressType]] for possible values.
        */
        getAddressType(): string;
        /**
        Gets the connection address.
        */
        getConnectionAddress(): string;
        /**
        Gets the type of network. See [[fm.liveswitch.sdp.connectionData.networkType]] for possible values.
        */
        getNetworkType(): string;
        /**
        Sets the type of the address. See [[fm.liveswitch.sdp.connectionData.addressType]] for possible values.
        */
        setAddressType(value: string): void;
        /**
        Sets the connection address.
        */
        setConnectionAddress(value: string): void;
        /**
        Sets the type of network. See [[fm.liveswitch.sdp.connectionData.networkType]] for possible values.
        */
        setNetworkType(value: string): void;
        /**
        Converts this instance to a string.
        */
        toString(): string;
        /**
        Updates the connection address.
        @param connectionAddress The connection address.
        */
        update(connectionAddress: string): void;
    }
}
declare namespace fm.liveswitch.sdp {
    /**
    This gives the maximum amount of media that can be encapsulated in each packet, expressed as time in milliseconds.  The time SHALL be calculated as the sum of the time the media present in the packet represents.  For frame-based codecs, the time SHOULD be an integer multiple of the frame size.  This attribute is probably only meaningful for audio data, but may be used with other media types if it makes sense.  It is a media-level attribute, and it is not dependent on charset.  Note that this attribute was introduced after RFC 2327, and non-updated implementations will ignore this attribute.
    */
    class CryptoAttribute extends fm.liveswitch.sdp.Attribute {
        getTypeString(): string;
        /** @hidden */
        private _cryptoSuite;
        /** @hidden */
        private _keyParams;
        /** @hidden */
        private _sessionParams;
        /** @hidden */
        private _tag;
        private fmliveswitchsdpCryptoAttributeInit;
        constructor();
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.cryptoAttribute]] class.
        @param tag The tag.
        @param cryptoSuite The crypto suite.
        */
        constructor(tag: number, cryptoSuite: string);
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.cryptoAttribute]] class.
        @param value The attribute value.
        */
        static fromAttributeValue(value: string): fm.liveswitch.sdp.CryptoAttribute;
        /**
        Gets the internal value of the attribute.
        */
        protected getAttributeValue(): string;
        /**
        Gets the crypto suite. See [[fm.liveswitch.sdp.cryptoAttribute.cryptoSuite]] for possible values.
        */
        getCryptoSuite(): string;
        /**
        Gets the key from the "inline" key parameter.
        */
        getKey(): fm.liveswitch.DataBuffer;
        /**
        Gets the key parameters.
        */
        getKeyParams(): fm.liveswitch.Hash<string, string>;
        /**
        Gets the salt from the "inline" key parameter.
        */
        getSalt(): fm.liveswitch.DataBuffer;
        /**
        Gets the session parameters.
        */
        getSessionParams(): Array<string>;
        /**
        Gets the tag.
        */
        getTag(): number;
        /** @hidden */
        private setCryptoSuite;
        /** @hidden */
        private setKeyParams;
        /**
        Sets the key and salt for the "inline" key parameter.
        @param key The key.
        @param salt The salt.
        */
        setKeySalt(key: Uint8Array, salt: Uint8Array): fm.liveswitch.sdp.CryptoAttribute;
        /** @hidden */
        private setSessionParams;
        /**
        Sets the tag.
        */
        setTag(value: number): void;
    }
}
declare namespace fm.liveswitch.sdp {
    /**
    Defines valid SDP crypto key methods.
    */
    abstract class CryptoKeyMethod {
        getTypeString(): string;
        /**
        Gets the SDP crypto key method meaning "inline".
        */
        static getInline(): string;
    }
}
declare namespace fm.liveswitch.sdp {
    /**
    Defines valid SDP crypto session parameters.
    */
    abstract class CryptoSessionParam {
        getTypeString(): string;
        /**
        Gets the SDP crypto session parameter meaning "unauthenticated SRTP".
        */
        static getUnauthenticatedSRTP(): string;
        /**
        Gets the SDP crypto session parameter meaning "unencrypted SRTCP".
        */
        static getUnencryptedSRTCP(): string;
        /**
        Gets the SDP crypto session parameter meaning "unencrypted SRTP".
        */
        static getUnencryptedSRTP(): string;
    }
}
declare namespace fm.liveswitch.sdp {
    /**
    Defines valid SDP crypto suites.
    */
    abstract class CryptoSuite {
        getTypeString(): string;
        /**
        Gets the SDP crypto suite meaning "AES-CM 128-bit cipher and HMAC-SHA1 message authentication with a 32-bit authentication tag".
        */
        static getAesCm128HmacSha132(): string;
        /**
        Gets the SDP crypto suite meaning "AES-CM 128-bit cipher and HMAC-SHA1 message authentication with an 80-bit authentication tag".
        */
        static getAesCM128HmacSha180(): string;
        /**
        Converts an EncryptionMode enum to a crypto-suite string.
        @param encryptionMode The EncryptionMode enum.
        @return The crypto-suite string.
        */
        static getCryptoSuite(encryptionMode: fm.liveswitch.EncryptionMode): string;
        /**
        Converts a crypto-suite string to an EncryptionMode enum.
        @param cryptoSuite The crypto-suite string.
        @return The EncryptionMode enum.
        */
        static getEncryptionMode(cryptoSuite: string): fm.liveswitch.EncryptionMode;
        /**
        Gets the SDP crypto suite meaning "NULL cipher and HMAC-SHA1 message authentication with a 32-bit authentication tag".
        */
        static getNullHmacSha132(): string;
        /**
        Gets the SDP crypto suite meaning "NULL cipher and HMAC-SHA1 message authentication with an 80-bit authentication tag".
        */
        static getNullHmacSha180(): string;
    }
}
declare namespace fm.liveswitch.sdp {
    /**
    This specifies the mode in which tools should be started.
    */
    abstract class DirectionAttribute extends fm.liveswitch.sdp.Attribute {
        getTypeString(): string;
        constructor();
        /**
        Creates a DirectionAttribute for a required direction.
        @param direction Direction.
        */
        static generateDirectionAttribute(direction: fm.liveswitch.StreamDirection): fm.liveswitch.sdp.DirectionAttribute;
        /**
        Gets the stream direction.
        */
        abstract getStreamDirection(): fm.liveswitch.StreamDirection;
    }
}
declare namespace fm.liveswitch.sdp {
    /**
    This attribute allows parameters that are specific to a particular format to be conveyed in a way that SDP does not have to understand them.  The format must be one of the formats specified for the media.  Format-specific parameters may be any set of parameters required to be conveyed by SDP and given unchanged to the media tool that will use this format.  At most one instance of this attribute is allowed for each format.
    */
    class FormatParametersAttribute extends fm.liveswitch.sdp.Attribute {
        getTypeString(): string;
        /** @hidden */
        private _format;
        /** @hidden */
        private _formatSpecificParameters;
        private fmliveswitchsdpFormatParametersAttributeInit;
        constructor();
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.formatParametersAttribute]] class.
        @param format The format.
        */
        constructor(format: number);
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.formatParametersAttribute]] class.
        @param format The format.
        @param formatSpecificParameters The format-specific parameters.
        */
        constructor(format: number, formatSpecificParameters: string);
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.formatParametersAttribute]] class.
        @param value The attribute value.
        */
        static fromAttributeValue(value: string): fm.liveswitch.sdp.FormatParametersAttribute;
        /**
        Creates a dictionary map from the format specific parameters.
        */
        deserializeFormatSpecificParameters(): fm.liveswitch.Hash<string, string>;
        /**
        Gets the internal value of the attribute.
        */
        protected getAttributeValue(): string;
        /**
        Gets the format.
        */
        getFormat(): number;
        /**
        Gets a format specific parameter.
        @param key The key.
        */
        getFormatSpecificParameter(key: string): string;
        /**
        Gets the format-specific parameters.
        */
        getFormatSpecificParameters(): string;
        /**
        Updates the format specific parameters based on a dictionary map.
        @param map The map.
        */
        serializeFormatSpecificParameters(map: fm.liveswitch.Hash<string, string>): void;
        /**
        Sets the format.
        */
        setFormat(value: number): void;
        /**
        Sets a format specific parameter.
        @param key The key.
        @param value The value.
        */
        setFormatSpecificParameter(key: string, value: string): void;
        /** @hidden */
        private setFormatSpecificParameters;
        /**
        Tries to get a format specific parameter.
        @param key The key.
        @param value The value.
        */
        tryGetFormatSpecificParameter(key: string, value: fm.liveswitch.Holder<string>): boolean;
        /**
        Unsets a format specific parameter.
        @param key The key.
        */
        unsetFormatSpecificParameter(key: string): boolean;
    }
}
declare namespace fm.liveswitch.sdp {
    /**
    This gives the maximum video frame rate in frames/sec.  It is intended as a recommendation for the encoding of video data. Decimal representations of fractional values using the notation "integer.fraction" are allowed.  It is a media-level attribute, defined only for video media, and it is not dependent on charset.
    */
    class FrameRateAttribute extends fm.liveswitch.sdp.Attribute {
        getTypeString(): string;
        /** @hidden */
        private _frameRate;
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.frameRateAttribute]] class.
        @param frameRate The maximum video frame rate in frames/second.
        */
        constructor(frameRate: string);
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.frameRateAttribute]] class.
        @param value The attribute value.
        */
        static fromAttributeValue(value: string): fm.liveswitch.sdp.FrameRateAttribute;
        /**
        Gets the internal value of the attribute.
        */
        protected getAttributeValue(): string;
        /**
        Gets the maximum video frame rate in frames/second.
        */
        getFrameRate(): string;
        /** @hidden */
        private setFrameRate;
    }
}
declare namespace fm.liveswitch.sdp {
    /**
    A bundle group of SDP Media Description elements.
    */
    class BundleGroup {
        getTypeString(): string;
        /** @hidden */
        private __mediaDescriptions;
        /** @hidden */
        private __mids;
        /** @hidden */
        private _bundleOnly;
        /** @hidden */
        private _groupType;
        /** @hidden */
        private _taggedMSection;
        private fmliveswitchsdpBundleGroupInit;
        /**
        Creates a BundleGroup object.
        @param groupType
        */
        constructor(groupType: fm.liveswitch.sdp.GroupSemanticsType);
        /**
        Adds a media description to this bundle group.
        @param mediaDescription
        */
        addMediaDescription(mediaDescription: fm.liveswitch.sdp.MediaDescription): void;
        /**
        Gets a value indicating whether this group contains Bundle-only elements.
        */
        getBundleOnly(): boolean;
        /**
        Gets the semntic type of this group.
        */
        getGroupType(): fm.liveswitch.sdp.GroupSemanticsType;
        /**
        Gets the mecia descriptions in this bundle group.
        */
        getMediaDescriptions(): fm.liveswitch.sdp.MediaDescription[];
        /**
        Gets media description identifiers associated with this bundle group.
        */
        getMids(): string[];
        /**
        Gets the tagged m-section of this bundle group.
        */
        getTaggedMSection(): fm.liveswitch.sdp.MediaDescription;
        /** @hidden */
        private setBundleOnly;
        /** @hidden */
        private setGroupType;
        /**
        Sets the tagged m-section of this bundle group.
        */
        setTaggedMSection(value: fm.liveswitch.sdp.MediaDescription): void;
    }
}
declare namespace fm.liveswitch.sdp {
    /**
    Defined in RFC 3388. Attribute is used for grouping together different media streams. Its formatting in SDP is described by the following BNF: group-attribute    = "a=group:" semantics * (space identification-tag) semantics          = "LS" | "FID" | "BUNDLE"
    */
    class GroupAttribute extends fm.liveswitch.sdp.Attribute {
        getTypeString(): string;
        /** @hidden */
        private _ids;
        /** @hidden */
        private _semantics;
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.groupAttribute]] class.
        @param type The semantics type.
        @param ids Group identification ID tags.
        */
        constructor(type: fm.liveswitch.sdp.GroupSemanticsType, ids: string[]);
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.groupAttribute]] class.
        @param value The attribute value.
        */
        static fromAttributeValue(value: string): fm.liveswitch.sdp.GroupAttribute;
        /**
        Gets the internal value of the attribute.
        */
        protected getAttributeValue(): string;
        /**
        Gets the group identification tags.
        */
        getIds(): string[];
        /**
        Gets the semantics.
        */
        getSemantics(): fm.liveswitch.sdp.GroupSemanticsType;
        /** @hidden */
        private setIds;
        /** @hidden */
        private setSemantics;
    }
}
declare namespace fm.liveswitch.sdp {
    class GroupSemanticsTypeWrapper {
        getTypeString(): string;
        /** @hidden */
        private _value;
        constructor(value: fm.liveswitch.sdp.GroupSemanticsType);
        toString(): string;
    }
}
declare namespace fm.liveswitch.sdp.ice {
    /**
    The candidate attribute is a media-level attribute only.  It contains a transport address for a candidate that can be used for connectivity checks.
    */
    class CandidateAttribute extends fm.liveswitch.sdp.Attribute {
        getTypeString(): string;
        /** @hidden */
        private __candidateType;
        /** @hidden */
        private __connectionAddress;
        /** @hidden */
        private __foundation;
        /** @hidden */
        private _componentId;
        /** @hidden */
        private _extensions;
        /** @hidden */
        private _port;
        /** @hidden */
        private _priority;
        /** @hidden */
        private _protocol;
        /** @hidden */
        private _relatedAddress;
        /** @hidden */
        private _relatedPort;
        private fmliveswitchsdpiceCandidateAttributeInit;
        constructor();
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.ice.candidateAttribute]] class.
        @param foundation The candidate's foundation.
        @param priority The priority of the candidate.
        @param connectionAddress The IP address of the candidate.
        @param port The port of the candidate.
        @param candidateType The type of the candidate. See [[fm.liveswitch.sdp.ice.candidateAttribute.candidateType]] for possible values.
        @param componentId The component identifier.
        */
        constructor(foundation: string, priority: number, connectionAddress: string, port: number, candidateType: string, componentId: number);
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.ice.candidateAttribute]] class.
        @param foundation The candidate's foundation.
        @param priority The priority of the candidate.
        @param connectionAddress The IP address of the candidate.
        @param port The port of the candidate.
        @param candidateType The type of the candidate. See [[fm.liveswitch.sdp.ice.candidateAttribute.candidateType]] for possible values.
        @param relatedAddress The IP address related to the candidate.
        @param relatedPort The port related to the candidate.
        @param protocol The protocol.
        @param componentId The ID of the component for which this is a candidate.
        */
        constructor(foundation: string, priority: number, connectionAddress: string, port: number, candidateType: string, relatedAddress: string, relatedPort: number, protocol: string, componentId: number);
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.ice.candidateAttribute]] class.
        @param value The attribute as a string.
        */
        static fromAttributeValue(value: string): fm.liveswitch.sdp.ice.CandidateAttribute;
        /**
        Gets the value of the attribute.
        */
        protected getAttributeValue(): string;
        /**
        Gets the type of the candidate. See [[fm.liveswitch.sdp.ice.candidateAttribute.candidateType]] for possible values.
        */
        getCandidateType(): string;
        /**
        Gets the ID of the component for which this is a candidate.
        */
        getComponentId(): number;
        /**
        Gets the IP address of the candidate.
        */
        getConnectionAddress(): string;
        /**
        Gets the extensions.
        */
        getExtensions(): fm.liveswitch.Hash<string, string>;
        /**
        Gets the candidate's foundation.
        */
        getFoundation(): string;
        /**
        Gets the port of the candidate.
        */
        getPort(): number;
        /**
        Gets the priority of the candidate.
        */
        getPriority(): number;
        /**
        Gets the protocol of this candidate.
        */
        getProtocol(): string;
        /**
        Gets the IP address related to the candidate.
        */
        getRelatedAddress(): string;
        /**
        Gets the port related to the candidate.
        */
        getRelatedPort(): number;
        /**
        Sets the type of the candidate. See [[fm.liveswitch.sdp.ice.candidateAttribute.candidateType]] for possible values.
        */
        setCandidateType(value: string): void;
        /**
        Sets the ID of the component for which this is a candidate.
        */
        setComponentId(value: number): void;
        /**
        Sets the IP address of the candidate.
        */
        setConnectionAddress(value: string): void;
        /** @hidden */
        private setExtensions;
        /**
        Sets the candidate's foundation.
        */
        setFoundation(value: string): void;
        /**
        Sets the port of the candidate.
        */
        setPort(value: number): void;
        /**
        Sets the priority of the candidate.
        */
        setPriority(value: number): void;
        /**
        Sets the protocol of this candidate.
        */
        setProtocol(value: string): void;
        /**
        Sets the IP address related to the candidate.
        */
        setRelatedAddress(value: string): void;
        /**
        Sets the port related to the candidate.
        */
        setRelatedPort(value: number): void;
    }
}
declare namespace fm.liveswitch.sdp.ice {
    /**
    Defines valid SDP candidate types.
    */
    abstract class CandidateType {
        getTypeString(): string;
        /**
        Gets the SDP candidate type meaning "Host".
        */
        static getHost(): string;
        /**
        Gets the SDP candidate type meaning "Peer Reflexive".
        */
        static getPeerReflexive(): string;
        /**
        Gets the SDP candidate type meaning "Relayed".
        */
        static getRelayed(): string;
        /**
        Gets the SDP candidate type meaning "Server Reflexive".
        */
        static getServerReflexive(): string;
    }
}
declare namespace fm.liveswitch.sdp.ice {
    /**
    The SDP session attribute "fingerprint" provides an encryption certificate fingerprint to a remote peer for use with DTLS.
    */
    class FingerprintAttribute extends fm.liveswitch.sdp.Attribute {
        getTypeString(): string;
        /** @hidden */
        private _fingerprint;
        /** @hidden */
        private _hashFunction;
        constructor();
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.ice.fingerprintAttribute]] class.
        @param hashFunction The hash function.
        @param fingerprint The fingerprint.
        */
        constructor(hashFunction: string, fingerprint: string);
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.ice.fingerprintAttribute]] class.
        @param value The attribute as a string.
        */
        static fromAttributeValue(value: string): fm.liveswitch.sdp.ice.FingerprintAttribute;
        /**
        Gets the value of the attribute.
        */
        protected getAttributeValue(): string;
        /**
        Gets the fingerprint.
        */
        getFingerprint(): string;
        /**
        Gets the hash function (i.e. sha-256).
        */
        getHashFunction(): string;
        /** @hidden */
        private setFingerprint;
        /** @hidden */
        private setHashFunction;
    }
}
declare namespace fm.liveswitch.sdp.ice {
    /**
    "ice-lite" is a session-level attribute only, and indicates that an agent is a lite implementation.
    */
    class LiteAttribute extends fm.liveswitch.sdp.Attribute {
        getTypeString(): string;
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.ice.liteAttribute]] class.
        */
        constructor();
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.ice.liteAttribute]] class.
        @param value The attribute value.
        */
        static fromAttributeValue(value: string): fm.liveswitch.sdp.ice.LiteAttribute;
        /**
        Gets the value of the attribute.
        */
        protected getAttributeValue(): string;
    }
}
declare namespace fm.liveswitch.sdp.ice {
    /**
    "ice-mismatch" is a media-level attribute only, and when present in an answer, indicates that the offer arrived with a default destination for a media component that didn't have a corresponding candidate attribute.
    */
    class MismatchAttribute extends fm.liveswitch.sdp.Attribute {
        getTypeString(): string;
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.ice.mismatchAttribute]] class.
        */
        constructor();
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.ice.mismatchAttribute]] class.
        @param value The attribute value.
        */
        static fromAttributeValue(value: string): fm.liveswitch.sdp.ice.MismatchAttribute;
        /**
        Gets the value of the attribute.
        */
        protected getAttributeValue(): string;
    }
}
declare namespace fm.liveswitch.sdp.ice {
    /**
    The "ice-options" attribute is a session-level attribute.  It contains a series of tokens that identify the options supported by the agent.
    */
    class OptionsAttribute extends fm.liveswitch.sdp.Attribute {
        getTypeString(): string;
        /** @hidden */
        private __tags;
        constructor();
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.ice.optionsAttribute]] class.
        @param tags The tokens that identify options supported by the agent.
        */
        constructor(tags: Array<fm.liveswitch.sdp.ice.OptionTag>);
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.ice.optionsAttribute]] class.
        @param value The attribute value.
        */
        static fromAttributeValue(value: string): fm.liveswitch.sdp.ice.OptionsAttribute;
        /**
        Gets the value of the attribute.
        */
        protected getAttributeValue(): string;
        /**
        Gets the tokens that identify options supported by the agent.
        */
        getTags(): Array<fm.liveswitch.sdp.ice.OptionTag>;
        /**
        Gets a value indicating whether trickle-ice is supported.
        */
        getTrickleOptionSet(): boolean;
        /**
        Sets the tokens that identify options supported by the agent.
        */
        setTags(value: Array<fm.liveswitch.sdp.ice.OptionTag>): void;
        /**
        Sets a value indicating whether trickle-ice is supported.
        */
        setTrickleOptionSet(value: boolean): void;
    }
}
declare namespace fm.liveswitch.sdp.ice {
    /**
    A tag for an [[fm.liveswitch.sdp.ice.optionsAttribute]].
    */
    abstract class OptionTag {
        getTypeString(): string;
        /** @hidden */
        private _type;
        constructor();
        /**
        Gets the "trickle" option string.
        */
        static getTrickle(): string;
        /**
        Generates a tag object from a string.
        @param tagString The tag string.
        */
        static parse(tagString: string): fm.liveswitch.sdp.ice.OptionTag;
        /**
        Gets the type of this tag.
        */
        getType(): fm.liveswitch.sdp.ice.OptionTagType;
        /**
        Sets the type of this tag.
        */
        protected setType(value: fm.liveswitch.sdp.ice.OptionTagType): void;
        /**
        Gets the string representation of this tag.
        */
        abstract toString(): string;
    }
}
declare namespace fm.liveswitch.sdp.ice {
    class OptionTagTypeWrapper {
        getTypeString(): string;
        /** @hidden */
        private _value;
        constructor(value: fm.liveswitch.sdp.ice.OptionTagType);
        toString(): string;
    }
}
declare namespace fm.liveswitch.sdp.ice {
    /**
    The "ice-pwd" attribute conveys the password used by ICE for message integrity.
    */
    class PasswordAttribute extends fm.liveswitch.sdp.Attribute {
        getTypeString(): string;
        /** @hidden */
        private _password;
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.ice.passwordAttribute]] class.
        */
        constructor();
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.ice.passwordAttribute]] class.
        @param password The password used by ICE for message integrity.
        */
        constructor(password: string);
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.ice.passwordAttribute]] class.
        @param value The attribute value.
        */
        static fromAttributeValue(value: string): fm.liveswitch.sdp.ice.PasswordAttribute;
        /**
        Generates a random password.
        */
        static generatePassword(): string;
        /**
        Gets the value of the attribute.
        */
        protected getAttributeValue(): string;
        /**
        Gets the password used by ICE for message integrity.
        */
        getPassword(): string;
        /** @hidden */
        private setPassword;
    }
}
declare namespace fm.liveswitch.sdp.ice {
    /**
    An SDP remote candidate element.
    */
    class RemoteCandidate {
        getTypeString(): string;
        /** @hidden */
        private _componentId;
        /** @hidden */
        private _connectionAddress;
        /** @hidden */
        private _port;
        private fmliveswitchsdpiceRemoteCandidateInit;
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.ice.remoteCandidate]] class.
        @param componentId The ID of the component for which this is a remote candidate.
        @param connectionAddress The IP address of the remote candidate.
        @param port The port of the remote candidate.
        */
        constructor(componentId: number, connectionAddress: string, port: number);
        /**
        Creates an [[fm.liveswitch.sdp.ice.remoteCandidate]] instance from a string.
        @param s The string to parse.
        */
        static parse(s: string): fm.liveswitch.sdp.ice.RemoteCandidate;
        /**
        Gets the ID of the component for which this is a remote candidate.
        */
        getComponentId(): number;
        /**
        Gets the IP address of the remote candidate.
        */
        getConnectionAddress(): string;
        /**
        Gets the port of the remote candidate.
        */
        getPort(): number;
        /** @hidden */
        private setComponentId;
        /** @hidden */
        private setConnectionAddress;
        /** @hidden */
        private setPort;
        /**
        Converts this instance to a string.
        */
        toString(): string;
    }
}
declare namespace fm.liveswitch.sdp.ice {
    /**
    The attribute contains a connection-address and port for each component.  The ordering of components is irrelevant.  However, a value MUST be present for each component of a media stream.  This attribute MUST be included in an offer by a controlling agent for a media stream that is Completed, and MUST NOT be included in any other case.
    */
    class RemoteCandidatesAttribute extends fm.liveswitch.sdp.Attribute {
        getTypeString(): string;
        /** @hidden */
        private _candidates;
        constructor();
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.ice.remoteCandidatesAttribute]] class.
        @param candidates The array of remote candidates.
        */
        constructor(candidates: fm.liveswitch.sdp.ice.RemoteCandidate[]);
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.ice.remoteCandidatesAttribute]] class.
        @param value The attribute value.
        */
        static fromAttributeValue(value: string): fm.liveswitch.sdp.ice.RemoteCandidatesAttribute;
        /**
        Gets the value of the attribute.
        */
        protected getAttributeValue(): string;
        /**
        Gets the array of remote candidates.
        */
        getCandidates(): fm.liveswitch.sdp.ice.RemoteCandidate[];
        /** @hidden */
        private setCandidates;
    }
}
declare namespace fm.liveswitch.sdp.ice {
    /**
    Defines valid SDP transport protocols.
    */
    abstract class TransportProtocol {
        getTypeString(): string;
        /**
        Gets the SDP transport protocol meaning "tcp".
        */
        static getTcp(): string;
        /**
        Gets the SDP transport protocol meaning "udp".
        */
        static getUdp(): string;
    }
}
declare namespace fm.liveswitch.sdp.ice {
    /**
    A trickle-ice tag for an [[fm.liveswitch.sdp.ice.optionsAttribute]]
    */
    class TrickleIceOptionTag extends fm.liveswitch.sdp.ice.OptionTag {
        getTypeString(): string;
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.ice.trickleIceOptionTag]] class.
        */
        constructor();
        /**
        Gets the string representation of this tag
        */
        toString(): string;
    }
}
declare namespace fm.liveswitch.sdp.ice {
    /**
    The "ice-ufrag" attribute conveys the username fragment used by ICE for message integrity.
    */
    class UfragAttribute extends fm.liveswitch.sdp.Attribute {
        getTypeString(): string;
        /** @hidden */
        private _ufrag;
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.ice.ufragAttribute]] class.
        */
        constructor();
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.ice.ufragAttribute]] class.
        @param ufrag The username fragment used by ICE for message integrity.
        */
        constructor(ufrag: string);
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.ice.ufragAttribute]] class.
        @param value The attribute value.
        */
        static fromAttributeValue(value: string): fm.liveswitch.sdp.ice.UfragAttribute;
        /**
        Generates a username fragment.
        */
        static generateUfrag(): string;
        /**
        Gets the value of the attribute.
        */
        protected getAttributeValue(): string;
        /**
        Gets the username fragment used by ICE for message integrity.
        */
        getUfrag(): string;
        /** @hidden */
        private setUfrag;
    }
}
declare namespace fm.liveswitch.sdp.ice {
    /**
    An unknown tag for an [[fm.liveswitch.sdp.ice.optionsAttribute]]
    */
    class UnknownIceOptionTag extends fm.liveswitch.sdp.ice.OptionTag {
        getTypeString(): string;
        /** @hidden */
        private _tagString;
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.ice.unknownIceOptionTag]] class.
        */
        constructor(tagString: string);
        /**
        Gets the tag string.
        */
        getTagString(): string;
        /** @hidden */
        private setTagString;
        /**
        Gets the string representation of this tag.
        */
        toString(): string;
    }
}
declare namespace fm.liveswitch.sdp {
    /**
    This specifies that the tools should be started in inactive mode.  This is necessary for interactive conferences where users can put other users on hold.  No media is sent over an inactive media stream.  Note that an RTP-based system SHOULD still send RTCP, even if started inactive.  It can be either a session or media-level attribute, and it is not dependent on charset.
    */
    class InactiveAttribute extends fm.liveswitch.sdp.DirectionAttribute {
        getTypeString(): string;
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.inactiveAttribute]] class.
        */
        constructor();
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.inactiveAttribute]] class.
        @param value The attribute value.
        */
        static fromAttributeValue(value: string): fm.liveswitch.sdp.InactiveAttribute;
        /**
        Gets the internal value of the attribute.
        */
        protected getAttributeValue(): string;
        /**
        Gets the stream direction.
        */
        getStreamDirection(): fm.liveswitch.StreamDirection;
    }
}
declare namespace fm.liveswitch.sdp {
    /**
    Like the cat attribute, this is to assist identifying wanted sessions at the receiver.  This allows a receiver to select interesting session based on keywords describing the purpose of the session; there is no central registry of keywords.  It is a session-level attribute.  It is a charset-dependent attribute, meaning that its value should be interpreted in the charset specified for the session description if one is specified, or by default in ISO 10646/UTF-8.
    */
    class KeywordsAttribute extends fm.liveswitch.sdp.Attribute {
        getTypeString(): string;
        /** @hidden */
        private _keywords;
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.keywordsAttribute]] class.
        @param keywords The keywords describing the purpose of the session.
        */
        constructor(keywords: string);
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.keywordsAttribute]] class.
        @param value The attribute value.
        */
        static fromAttributeValue(value: string): fm.liveswitch.sdp.KeywordsAttribute;
        /**
        Gets the internal value of the attribute.
        */
        protected getAttributeValue(): string;
        /**
        Gets the keywords describing the purpose of the session.
        */
        getKeywords(): string;
        /** @hidden */
        private setKeywords;
    }
}
declare namespace fm.liveswitch.sdp {
    /**
    This can be a session-level attribute or a media-level attribute.  As a session-level attribute, it specifies the default language for the session being described.  As a media- level attribute, it specifies the language for that media, overriding any session-level language specified.  Multiple lang attributes can be provided either at session or media level if the session description or media use multiple languages, in which case the order of the attributes indicates the order of importance of the various languages in the session or media from most important to least important.
    */
    class LanguageAttribute extends fm.liveswitch.sdp.Attribute {
        getTypeString(): string;
        /** @hidden */
        private _languageTag;
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.languageAttribute]] class.
        @param languageTag The default language for the session being described
                    (if used as a session-level attribute) or the language for a media
                    stream (if used as a media-level attribute).
        */
        constructor(languageTag: string);
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.languageAttribute]] class.
        @param value The attribute value.
        */
        static fromAttributeValue(value: string): fm.liveswitch.sdp.LanguageAttribute;
        /**
        Gets the internal value of the attribute.
        */
        protected getAttributeValue(): string;
        /**
        Gets the default language for the session being described (if used as a session-level attribute) or the language for a media stream (if used as a media-level attribute).
        */
        getLanguageTag(): string;
        /** @hidden */
        private setLanguageTag;
    }
}
declare namespace fm.liveswitch.sdp {
    /**
    This gives the maximum amount of media that can be encapsulated in each packet, expressed as time in milliseconds.  The time SHALL be calculated as the sum of the time the media present in the packet represents.  For frame-based codecs, the time SHOULD be an integer multiple of the frame size.  This attribute is probably only meaningful for audio data, but may be used with other media types if it makes sense.  It is a media-level attribute, and it is not dependent on charset.  Note that this attribute was introduced after RFC 2327, and non-updated implementations will ignore this attribute.
    */
    class MaxPacketTimeAttribute extends fm.liveswitch.sdp.Attribute {
        getTypeString(): string;
        /** @hidden */
        private _maxPacketTime;
        private fmliveswitchsdpMaxPacketTimeAttributeInit;
        constructor();
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.maxPacketTimeAttribute]] class.
        @param maxPacketTime The maximum amount of media that can be encapsulated,
                    in each packet, expressed as time in milliseconds.
        */
        constructor(maxPacketTime: number);
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.maxPacketTimeAttribute]] class.
        @param value The attribute value.
        */
        static fromAttributeValue(value: string): fm.liveswitch.sdp.MaxPacketTimeAttribute;
        /**
        Gets the internal value of the attribute.
        */
        protected getAttributeValue(): string;
        /**
        Gets the maximum amount of media that can be encapsulated, in each packet, expressed as time in milliseconds.
        */
        getMaxPacketTime(): number;
        /** @hidden */
        private setMaxPacketTime;
    }
}
declare namespace fm.liveswitch.sdp {
    /**
    An SDP media element.
    */
    class Media {
        getTypeString(): string;
        /** @hidden */
        private _formatDescription;
        /** @hidden */
        private _mediaType;
        /** @hidden */
        private _numberOfPorts;
        /** @hidden */
        private _transportPort;
        /** @hidden */
        private _transportProtocol;
        /** @hidden */
        private static fm_liveswitch_sdp_Media__defaultNumberOfPorts;
        private fmliveswitchsdpMediaInit;
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.media]] class.
        */
        constructor();
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.media]] class.
        @param mediaType The media type. See [[fm.liveswitch.sdp.media.mediaType]] for possible values.
        @param transportPort The transport port.
        @param transportProtocol The transport protocol.
        */
        constructor(mediaType: string, transportPort: number, transportProtocol: string);
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.media]] class.
        @param mediaType The media type. See [[fm.liveswitch.sdp.media.mediaType]] for possible values.
        @param transportPort The transport port.
        @param transportProtocol The transport protocol.
        @param formatDescription The format description.
        */
        constructor(mediaType: string, transportPort: number, transportProtocol: string, formatDescription: string);
        /**
        Creates an [[fm.liveswitch.sdp.media]] instance from a string.
        @param s The string to parse.
        */
        static parse(s: string): fm.liveswitch.sdp.Media;
        /**
        Gets the format description.
        */
        getFormatDescription(): string;
        /**
        Gets the media type. See [[fm.liveswitch.sdp.media.mediaType]] for possible values.
        */
        getMediaType(): string;
        /**
        Gets the number of ports.
        */
        getNumberOfPorts(): number;
        /**
        Gets the transport port.
        */
        getTransportPort(): number;
        /**
        Gets the transport protocol.
        */
        getTransportProtocol(): string;
        /**
        Sets the format description.
        */
        setFormatDescription(value: string): void;
        /**
        Sets the media type. See [[fm.liveswitch.sdp.media.mediaType]] for possible values.
        */
        setMediaType(value: string): void;
        /**
        Sets the number of ports.
        */
        setNumberOfPorts(value: number): void;
        /**
        Sets the transport port.
        */
        setTransportPort(value: number): void;
        /**
        Sets the transport protocol.
        */
        setTransportProtocol(value: string): void;
        /**
        Converts this instance to a string.
        */
        toString(): string;
        /** @hidden */
        private static __fmliveswitchsdpMediaInitialized;
        /** @hidden */
        private static __fmliveswitchsdpMediaInitializing;
        /** @hidden */
        static fmliveswitchsdpMediaInitialize(): void;
    }
}
declare namespace fm.liveswitch.sdp {
    /**
    An SDP media description element.
    */
    class MediaDescription {
        getTypeString(): string;
        /** @hidden */
        private __bandwidths;
        /** @hidden */
        private __mediaAttributes;
        /** @hidden */
        private __orphanedAttributes;
        /** @hidden */
        private _connectionData;
        /** @hidden */
        private _encryptionKey;
        /** @hidden */
        private _media;
        /** @hidden */
        private _mediaTitle;
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.mediaDescription]] class.
        @param media The media name and transport address.
        */
        constructor(media: fm.liveswitch.sdp.Media);
        /** @hidden */
        static getBundleOnlyAttributeFromCollection(attributes: fm.liveswitch.sdp.AttributeCollection): fm.liveswitch.sdp.Attribute;
        /** @hidden */
        static getBundlingSupportFromCollection(attributes: fm.liveswitch.sdp.AttributeCollection): boolean;
        /** @hidden */
        static getCryptoAttributesFromCollection(attributes: fm.liveswitch.sdp.AttributeCollection): fm.liveswitch.sdp.CryptoAttribute[];
        /** @hidden */
        static getFingerprintAttributeFromCollection(attributes: fm.liveswitch.sdp.AttributeCollection): fm.liveswitch.sdp.ice.FingerprintAttribute;
        /** @hidden */
        static getGroupAttributesFromCollection(collection: fm.liveswitch.sdp.AttributeCollection): fm.liveswitch.sdp.GroupAttribute[];
        /** @hidden */
        static getIceOptionAttributesFromCollection(attributes: fm.liveswitch.sdp.AttributeCollection): fm.liveswitch.sdp.Attribute[];
        /** @hidden */
        static getIcePasswordAttributeFromCollection(attributes: fm.liveswitch.sdp.AttributeCollection): fm.liveswitch.sdp.ice.PasswordAttribute;
        /** @hidden */
        static getIceUfragAttributeFromCollection(attributes: fm.liveswitch.sdp.AttributeCollection): fm.liveswitch.sdp.ice.UfragAttribute;
        /** @hidden */
        static getIsMutedFromCollection(attributes: fm.liveswitch.sdp.AttributeCollection): boolean;
        /** @hidden */
        static getQualityAttributeFromCollection(attributes: fm.liveswitch.sdp.AttributeCollection): fm.liveswitch.sdp.QualityAttribute;
        /** @hidden */
        static getRtcpMultiplexingSupportFromCollection(attributes: fm.liveswitch.sdp.AttributeCollection): boolean;
        /** @hidden */
        static getRtpExtMapAttributesFromCollection(attributes: fm.liveswitch.sdp.AttributeCollection): fm.liveswitch.sdp.Attribute[];
        /** @hidden */
        static getSetupAttributeFromCollection(attributes: fm.liveswitch.sdp.AttributeCollection): fm.liveswitch.sdp.SetupAttribute;
        /** @hidden */
        static getStreamDirectionFromCollection(attributes: fm.liveswitch.sdp.AttributeCollection): fm.liveswitch.StreamDirection;
        /** @hidden */
        static getSupportsIceFromCollection(attributes: fm.liveswitch.sdp.AttributeCollection): boolean;
        /**
        Creates an [[fm.liveswitch.sdp.mediaDescription]] instance from a string.
        @param s The string to parse.
        */
        static parse(s: string): fm.liveswitch.sdp.MediaDescription;
        /**
        Adds a proposed bandwidth.
        @param bandwidth The proposed bandwidth to add.
        */
        addBandwidth(bandwidth: fm.liveswitch.sdp.Bandwidth): void;
        /**
        Adds a media-level attribute.
        @param attribute The session-level attribute to add.
        */
        addMediaAttribute(attribute: fm.liveswitch.sdp.Attribute): void;
        /**
        Gets the array of proposed bandwidths to be used by the media.
        */
        getBandwidths(): fm.liveswitch.sdp.Bandwidth[];
        /**
        Gets a value indicating whether this media description has been marked as bundle-only.
        */
        getBundleOnly(): boolean;
        /**
        Obtains Ice Candidate attributes associated with this media description.
        */
        getCandidateAttributes(): fm.liveswitch.sdp.Attribute[];
        /** @hidden */
        private getCategoryAttributes;
        /**
        Gets the RTCP "ccm fir" feedback attribute for the given payload type.
        @param payloadType The payload type.
        */
        getCcmFirFeedbackAttribute(payloadType: number): fm.liveswitch.sdp.rtcp.FeedbackAttribute;
        /**
        Gets the RTCP "ccm lrr" feedback attribute for the given payload type.
        @param payloadType The payload type.
        */
        getCcmLrrFeedbackAttribute(payloadType: number): fm.liveswitch.sdp.rtcp.FeedbackAttribute;
        /**
        Gets media-level connection data.
        */
        getConnectionData(): fm.liveswitch.sdp.ConnectionData;
        /**
        Gets CryptoAttributes associated with this MediaDescription.
        */
        getCryptoAttributes(): fm.liveswitch.sdp.CryptoAttribute[];
        /**
        Gets the media-level encryption key.
        */
        getEncryptionKey(): fm.liveswitch.sdp.EncryptionKey;
        /**
        Gets the Fingerprint Attribute from this MediaDescription
        */
        getFingerprintAttribute(): fm.liveswitch.sdp.ice.FingerprintAttribute;
        /**
        Gets the format parameters attribute for the given payload type.
        @param payloadType The payload type.
        */
        getFormatParametersAttribute(payloadType: number): fm.liveswitch.sdp.FormatParametersAttribute;
        /**
        Sets a format parameter value.
        */
        getFormatParameterValue(payloadType: number, formatParameterName: string): string;
        /**
        Obtains Ice Options attributes associated with this media description.
        */
        getIceOptionAttributes(): fm.liveswitch.sdp.Attribute[];
        /**
        Gets the IcePasswordAttribute associated with this MediaDescription
        */
        getIcePasswordAttribute(): fm.liveswitch.sdp.ice.PasswordAttribute;
        /**
        Gets the IceUfragAttribute associated with this MediaDescription
        */
        getIceUfragAttribute(): fm.liveswitch.sdp.ice.UfragAttribute;
        /**
        Gets the attributes with Identical Multiplexing Category present in this description.
        @return Attributes with Identical Multiplexing Category present in this description.
        */
        getIdenticalCategoryAttributes(): fm.liveswitch.sdp.Attribute[];
        /**
        Gets whether this media description represents an application stream (media type == "application").
        */
        getIsApplication(): boolean;
        /**
        Gets whether this media description represents an audio stream (media type == "audio").
        */
        getIsAudio(): boolean;
        /**
        Gets whether this media description represents a message stream (media type == "message").
        */
        getIsMessage(): boolean;
        /**
        Gets a value indicating whether this stream is muted. Applies to only media streams.
        */
        getIsMuted(): boolean;
        /**
        Gets whether this media description represents a text stream (media type == "text").
        */
        getIsText(): boolean;
        /**
        Gets whether this media description represents a video stream (media type == "video").
        */
        getIsVideo(): boolean;
        /**
        Obtains the maximum packet time attribute.
        */
        getMaxPacketTimeAttribute(): fm.liveswitch.sdp.MaxPacketTimeAttribute;
        /**
        Gets the media name and transport address.
        */
        getMedia(): fm.liveswitch.sdp.Media;
        /**
        Gets the array of media-level attributes.
        */
        getMediaAttributes(): fm.liveswitch.sdp.Attribute[];
        /**
        Obtains the media stream identifier attribute.
        */
        getMediaStreamIdentifierAttribute(): fm.liveswitch.sdp.MediaStreamIdAttribute;
        /**
        Gets the media title.
        */
        getMediaTitle(): string;
        /**
        Gets the RTCP "nack" feedback attribute for the given payload type.
        @param payloadType The payload type.
        */
        getNackFeedbackAttribute(payloadType: number): fm.liveswitch.sdp.rtcp.FeedbackAttribute;
        /**
        Gets the RTCP "nack pli" feedback attribute for the given payload type.
        @param payloadType The payload type.
        */
        getNackPliFeedbackAttribute(payloadType: number): fm.liveswitch.sdp.rtcp.FeedbackAttribute;
        /**
        Gets the RTCP "nack rpsi" feedback attribute for the given payload type.
        @param payloadType The payload type.
        */
        getNackRpsiFeedbackAttribute(payloadType: number): fm.liveswitch.sdp.rtcp.FeedbackAttribute;
        /**
        Gets the RTCP "nack sli" feedback attribute for the given payload type.
        @param payloadType The payload type.
        */
        getNackSliFeedbackAttribute(payloadType: number): fm.liveswitch.sdp.rtcp.FeedbackAttribute;
        /**
        Obtains the packet time attribute.
        */
        getPacketTimeAttribute(): fm.liveswitch.sdp.PacketTimeAttribute;
        /**
        Obtains the RTP map attributes in preference order.
        */
        getPreferredRtpMapAttributes(): fm.liveswitch.sdp.rtp.MapAttribute[];
        /**
        Gets the QualityAttribute associated with this MediaDescription.
        */
        getQualityAttribute(): fm.liveswitch.sdp.QualityAttribute;
        /**
        Obtains an RID attribute by its RID.
        */
        getRidAttribute(rid: string): fm.liveswitch.sdp.rtp.RidAttribute;
        /**
        Obtains the RID attributes.
        */
        getRidAttributes(): fm.liveswitch.sdp.rtp.RidAttribute[];
        /**
        Obtains the RID attributes.
        @param direction The RID attribute direction.
        */
        getRidAttributes(direction: string): fm.liveswitch.sdp.rtp.RidAttribute[];
        /**
        Gets Rtcp Attributes associated with this media description.
        */
        getRtcpAttribute(): fm.liveswitch.sdp.rtcp.Attribute;
        /**
        Gets the RTCP feedback attribute for the given payload type.
        @param payloadType The payload type.
        @param type The type.
        @param subType The sub-type.
        */
        getRtcpFeedbackAttribute(payloadType: number, type: string, subType: string): fm.liveswitch.sdp.rtcp.FeedbackAttribute;
        /**
        Gets a value indicating support for RTCP Multiplexing.
        */
        getRtcpMultiplexingSupported(): boolean;
        /** @hidden */
        getRtcpMuxAttribute(): fm.liveswitch.sdp.Attribute;
        /**
        Obtains the RTP ext-map attributes.
        */
        getRtpExtMapAttributes(): fm.liveswitch.sdp.Attribute[];
        /**
        Obtains the RTP map attribute for a given format.
        @param formatName Format name.
        @param clockRate Clock rate.
        */
        getRtpMapAttribute(formatName: string, clockRate: number): fm.liveswitch.sdp.rtp.MapAttribute;
        /**
        Obtains the RTP map attribute for a given format.
        @param formatName Format name.
        @param clockRate Clock rate.
        @param formatParameters Format parameters.
        */
        getRtpMapAttribute(formatName: string, clockRate: number, formatParameters: string): fm.liveswitch.sdp.rtp.MapAttribute;
        /**
        Obtains the RTP map attribute for a given format.
        @param formatName Format name.
        @param clockRate Clock rate.
        @param formatParameters Format parameters.
        @param rtpMapAttributeIndex The index of the [[fm.liveswitch.sdp.rtp.mapAttribute]].
        */
        getRtpMapAttribute(formatName: string, clockRate: number, formatParameters: string, rtpMapAttributeIndex: fm.liveswitch.Holder<number>): fm.liveswitch.sdp.rtp.MapAttribute;
        /**
        Obtains the RTP map attribute for a given payload type.
        @param payloadType The payload type.
        */
        getRtpMapAttribute(payloadType: number): fm.liveswitch.sdp.rtp.MapAttribute;
        /**
        Obtains the RTP map attribute for a given payload type.
        @param payloadType The payload type.
        @param rtpMapAttributeIndex The index of the [[fm.liveswitch.sdp.rtp.mapAttribute]].
        */
        getRtpMapAttribute(payloadType: number, rtpMapAttributeIndex: fm.liveswitch.Holder<number>): fm.liveswitch.sdp.rtp.MapAttribute;
        /**
        Obtains the RTP map attributes.
        */
        getRtpMapAttributes(): fm.liveswitch.sdp.rtp.MapAttribute[];
        /**
        Obtains the RTP map attributes for a given format.
        @param formatName Format name.
        @param clockRate Clock rate.
        @param formatParameters Format parameters.
        */
        getRtpMapAttributes(formatName: string, clockRate: number, formatParameters: string): fm.liveswitch.sdp.rtp.MapAttribute[];
        /**
        Obtains the RTP map attributes for a given format.
        @param formatName Format name.
        @param clockRate Clock rate.
        @param formatParameters Format parameters.
        @param rtpMapAttributeIndices The indeces of the [[fm.liveswitch.sdp.rtp.mapAttribute]].
        */
        getRtpMapAttributes(formatName: string, clockRate: number, formatParameters: string, rtpMapAttributeIndices: fm.liveswitch.Holder<number[]>): fm.liveswitch.sdp.rtp.MapAttribute[];
        /**
        Gets the Sctp Map Attribute, if it is present in the Media Description.
        */
        getSctpMapAttribute(): fm.liveswitch.sdp.sctp.MapAttribute;
        /**
        Gets the Sctp Max Message Size Attribute, if it is present in the Media Description.
        */
        getSctpMaxMessageSizeAttribute(): fm.liveswitch.sdp.sctp.MaxMessageSizeAttribute;
        /**
        Gets the Sctp Port Attribute, if it is present in the Media Description.
        */
        getSctpPortAttribute(): fm.liveswitch.sdp.sctp.PortAttribute;
        /**
        Gets the SetupAttribute associated with this MediaDescription.
        */
        getSetupAttribute(): fm.liveswitch.sdp.SetupAttribute;
        /**
        Obtains the simulcast attribute.
        */
        getSimulcastAttribute(): fm.liveswitch.sdp.rtp.SimulcastAttribute;
        /**
        Obtains the first SSRC attribute matching a given synchronization source and name.
        @param ssrc The synchronization source.
        @param name The attribute name.
        */
        getSsrcAttribute(ssrc: number, name: string): fm.liveswitch.sdp.rtp.SsrcAttribute;
        /**
        Obtains the SSRC attribute matching a given synchronization source, name, and value.
        @param ssrc The synchronization source.
        @param name The attribute name.
        @param value The attribute value.
        */
        getSsrcAttribute(ssrc: number, name: string, value: string): fm.liveswitch.sdp.rtp.SsrcAttribute;
        /**
        Obtains the SSRC attributes.
        */
        getSsrcAttributes(): fm.liveswitch.sdp.rtp.SsrcAttribute[];
        /**
        Obtains the SSRC attributes.
        @param name The SSRC attribute name.
        */
        getSsrcAttributes(name: string): fm.liveswitch.sdp.rtp.SsrcAttribute[];
        /**
        Obtains the SSRC attributes matching a given synchronization source.
        @param ssrc The synchronization source.
        */
        getSsrcAttributes(ssrc: number): fm.liveswitch.sdp.rtp.SsrcAttribute[];
        /**
        Obtains the SSRC attributes matching a given synchronization source and name.
        @param ssrc The synchronization source.
        @param name The attribute name.
        */
        getSsrcAttributes(ssrc: number, name: string): fm.liveswitch.sdp.rtp.SsrcAttribute[];
        /**
        Obtains the SSRC Group attributes.
        */
        getSsrcGroupAttributes(): fm.liveswitch.sdp.rtp.SsrcGroupAttribute[];
        /**
        Obtains the SSRCS from the first SSRC Group with matching semantics.
        */
        getSsrcGroupSsrcs(semantics: string): number[];
        /**
        Gets the stream direction indicated in Media Description. Getter returns StreamDirection if DirectionAttribute is present; otherwise, returns StreamDirection.Unset.
        */
        getStreamDirection(): fm.liveswitch.StreamDirection;
        /**
        Gets a value indicating whether this SDP MediaDescription suggests support for ICE.
        */
        getSupportsIce(): boolean;
        /**
        Gets the attributes with Transport Multiplexing Category present in this description.
        @return Attributes with Transport Multiplexing Category present in this description.
        */
        getTransportCategoryAttributes(): fm.liveswitch.sdp.Attribute[];
        /**
        DEPRECATED: Use AddMediaAttribute instead. Inserts a media-level attribute at the given index.
        @param attribute The session-level attribute to add.
        @param index The index.
        */
        insertMediaAttribute(attribute: fm.liveswitch.sdp.Attribute, index: number): void;
        /** @hidden */
        private isMediaType;
        /**
        Orders the formats in preference order.
        @param names The format names.
        @return `false` if a media element does not exist; otherwise `true`.
        */
        orderFormats(names: string[]): boolean;
        /**
        Removes a format by name.
        @param name The format name.
        @return `true` if the format was found and removed; otherwise, `false`
        */
        purgeFormat(name: string): boolean;
        /**
        Removes a format by name and clock rate.
        @param name The format name.
        @param clockRate The clock rate.
        @return `true` if the format was found and removed; otherwise, `false`
        */
        purgeFormat(name: string, clockRate: number): boolean;
        /**
        Removes a format by name, clock rate, and channel count.
        @param name The format name.
        @param clockRate The clock rate.
        @param channelCount The channel count.
        @return `true` if the format was found and removed; otherwise, `false`
        */
        purgeFormat(name: string, clockRate: number, channelCount: number): boolean;
        /** @hidden */
        private purgeRtpMapAttribute;
        /**
        Removes a proposed bandwidth.
        @param bandwidth The proposed bandwidth to remove.
        */
        removeBandwidth(bandwidth: fm.liveswitch.sdp.Bandwidth): boolean;
        /**
        Removes Bundle (i.e. Transport and Identical) Category Attributes.
        */
        removeBundleCategoryAttributes(): void;
        /** @hidden */
        removeIdenticalCategoryAttributes(): void;
        /**
        Removes a media-level attribute.
        @param attribute The session-level attribute to remove.
        */
        removeMediaAttribute(attribute: fm.liveswitch.sdp.Attribute): boolean;
        /** @hidden */
        removeTransportCategoryAttributes(): void;
        /**
        Sets media-level connection data.
        */
        setConnectionData(value: fm.liveswitch.sdp.ConnectionData): void;
        /**
        Sets the media-level encryption key.
        */
        setEncryptionKey(value: fm.liveswitch.sdp.EncryptionKey): void;
        /**
        Sets a format parameter value.
        */
        setFormatParameterValue(payloadType: number, formatParameterName: string, formatParameterValue: string): boolean;
        /**
        Sets a value indicating whether this stream is muted. Applies to only media streams.
        */
        setIsMuted(value: boolean): void;
        /** @hidden */
        private setMedia;
        /**
        Sets the media title.
        */
        setMediaTitle(value: string): void;
        /**
        Sets the QualityAttribute associated with this MediaDescription.
        */
        setQualityAttribute(value: fm.liveswitch.sdp.QualityAttribute): void;
        /**
        Sets Rtcp Attributes associated with this media description.
        */
        setRtcpAttribute(value: fm.liveswitch.sdp.rtcp.Attribute): void;
        /**
        Sets a value indicating support for RTCP Multiplexing.
        */
        setRtcpMultiplexingSupported(value: boolean): void;
        /**
        Sets the SetupAttribute associated with this MediaDescription.
        */
        setSetupAttribute(value: fm.liveswitch.sdp.SetupAttribute): void;
        /**
        Sets the stream direction indicated in Media Description. Getter returns StreamDirection if DirectionAttribute is present; otherwise, returns StreamDirection.Unset.
        */
        setStreamDirection(value: fm.liveswitch.StreamDirection): void;
        /**
        Converts this instance to a string.
        */
        toString(): string;
        /**
        Updates SDP Quality Attribute associated with this media description if one is present. Otherwise, creates a new one and inserts it into this media description.
        @param quality
        */
        updateQualityAttributeValue(quality: number): void;
    }
}
declare namespace fm.liveswitch.sdp {
    /**
    https://tools.ietf.org/html/rfc5888#page-4 "Media stream identification" media attribute, which is used for identifying media streams within a session description. Its formatting in SDP [RFC4566] is described by the following Augmented Backus-Naur Form(ABNF) [RFC5234]:  mid-attribute      = "a=mid:" identification-tag identification-tag = token ; token is defined in RFC 4566 The identification-tag MUST be unique within an SDP session description.
    */
    class MediaStreamIdAttribute extends fm.liveswitch.sdp.Attribute {
        getTypeString(): string;
        /** @hidden */
        private _identificationTag;
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.mediaStreamIdAttribute]] class.
        @param idValue The identifier.
        */
        constructor(idValue: string);
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.mediaStreamIdAttribute]] class.
        @param value The attribute value.
        */
        static fromAttributeValue(value: string): fm.liveswitch.sdp.MediaStreamIdAttribute;
        /**
        Gets the internal value of the attribute.
        */
        protected getAttributeValue(): string;
        /**
        Gets the identification tag.
        */
        getIdentificationTag(): string;
        /** @hidden */
        private setIdentificationTag;
    }
}
declare namespace fm.liveswitch.sdp {
    /**
    https://tools.ietf.org/html/draft-ietf-mmusic-msid-08 - NB: Removed in subsequent drafts, most likely will not be used eventually. Used here for compatibility with Google Chrome and Mozilla Firefox.  A session-level attribute is defined for signalling the semantics associated with an msid grouping.This allows msid groupings with different semantics to coexist.  This OPTIONAL attribute gives the group identifier and its group semantic; it carries the same meaning as the ssrc-group-attr of RFC 5576 section 4.2, but uses the identifier of the group rather than a list of SSRC values.  This attribute MUST be present if "a=msid" is used.  An empty list of identifiers is an indication that the sender supports the indicated semantic, but has no msid groupings of the given type in the present SDP.  An identifier of "*" is an indication that all "a=msid" lines in the SDP have this specific semantic.  If "*" is not used, each msid-id in the SDP MUST appear in one and only one "msid-semantic" line. The name of the attribute is "msid-semantic". The value of the attribute is given by the following ABNF:  msid-semantic-value = msid - semantic msid-list msid-semantic = token ; see RFC 4566 msid-list = *(" " msid-id) / " *"  The semantic field holds values from the IANA registriy "Semantics for the msid-semantic SDP attribute" (which is defined in Section 6 of https://tools.ietf.org/html/draft-ietf-mmusic-msid-08 ).  An example msid-semantic might look like this, if a semantic LS was registered by IANA for the same purpose as the existing LS grouping semantic:  a= msid-semantic:LS xyzzy forolow  This means that the SDP description has two lip sync groups, with the group identifiers xyzzy and forolow, respectively.  The msid-semantic attribute can occur more than once, but MUST NOT occur more than once with the same msid-semantic value.
    */
    class MediaStreamIdSemanticAttribute extends fm.liveswitch.sdp.Attribute {
        getTypeString(): string;
        /** @hidden */
        private _msIdList;
        /** @hidden */
        private _semanticToken;
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.mediaStreamIdSemanticAttribute]] class.
        @param semanticToken The semantic token.
        */
        constructor(semanticToken: fm.liveswitch.sdp.MediaStreamIdSemanticToken);
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.mediaStreamIdSemanticAttribute]] class.
        @param semanticToken The semantic token.
        @param msidList The msid list for the given semantic token.
        */
        constructor(semanticToken: fm.liveswitch.sdp.MediaStreamIdSemanticToken, msidList: string);
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.mediaStreamIdSemanticAttribute]] class.
        @param value The attribute value.
        */
        static fromAttributeValue(value: string): fm.liveswitch.sdp.MediaStreamIdSemanticAttribute;
        /** @hidden */
        private static getSemanticTokenFromString;
        /** @hidden */
        private static getSemanticTokenString;
        /**
        Gets the internal value of the attribute.
        */
        protected getAttributeValue(): string;
        /**
        Gets the space-delimited list of msids for which a given semantic is used. An empty list of identifiers is an indication that the sender supports the indicated semantic, but has no msid groupings of the given type in the present SDP.  An identifier of "*" is an indication that all "a=msid" lines in the SDP have this specific semantic.  If "*" is not used, each msid-id in the SDP MUST appear in one and only one "msid-semantic" line.
        */
        getMsIdList(): string;
        /** @hidden */
        private getSemanticToken;
        /**
        Sets the space-delimited list of msids for which a given semantic is used. An empty list of identifiers is an indication that the sender supports the indicated semantic, but has no msid groupings of the given type in the present SDP.  An identifier of "*" is an indication that all "a=msid" lines in the SDP have this specific semantic.  If "*" is not used, each msid-id in the SDP MUST appear in one and only one "msid-semantic" line.
        */
        setMsIdList(value: string): void;
        /** @hidden */
        private setSemanticToken;
    }
}
declare namespace fm.liveswitch.sdp {
    class MediaStreamIdSemanticTokenWrapper {
        getTypeString(): string;
        /** @hidden */
        private _value;
        constructor(value: fm.liveswitch.sdp.MediaStreamIdSemanticToken);
        toString(): string;
    }
}
declare namespace fm.liveswitch.sdp {
    /**
    Defines valid SDP media types.
    */
    abstract class MediaType {
        getTypeString(): string;
        /**
        Convert a StreamType enum to an SDP media type.
        @param streamType The StreamType enum.
        */
        static fromStreamType(streamType: fm.liveswitch.StreamType): string;
        /**
        Gets the SDP media type meaning "Application".
        */
        static getApplication(): string;
        /**
        Gets the SDP media type meaning "Audio".
        */
        static getAudio(): string;
        /**
        Gets the SDP media type meaning "Message".
        */
        static getMessage(): string;
        /**
        Gets the SDP media type meaning "Text".
        */
        static getText(): string;
        /**
        Gets the SDP media type meaning "Video".
        */
        static getVideo(): string;
        /**
        Converts an SDP media type to a StreamType enum.
        @param mediaType The SDP media type.
        */
        static toStreamType(mediaType: string): fm.liveswitch.StreamType;
    }
}
declare namespace fm.liveswitch.sdp {
    /**
    An SDP message.
    */
    class Message {
        getTypeString(): string;
        /** @hidden */
        private __bandwidths;
        /** @hidden */
        private __mediaDescriptions;
        /** @hidden */
        private __sessionAttributes;
        /** @hidden */
        private __timeDescriptions;
        /** @hidden */
        private _connectionData;
        /** @hidden */
        private _emailAddress;
        /** @hidden */
        private _encryptionKey;
        /** @hidden */
        private _origin;
        /** @hidden */
        private _phoneNumber;
        /** @hidden */
        private _protocolVersion;
        /** @hidden */
        private _sessionInformation;
        /** @hidden */
        private _sessionName;
        /** @hidden */
        private _timeZoneAdjustments;
        /** @hidden */
        private _uri;
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.message]] class.
        @param origin The originator of the session plus a session identifier and version number.
        */
        constructor(origin: fm.liveswitch.sdp.Origin);
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.message]] class.
        @param origin The originator of the session plus a session identifier and version number.
        @param sessionName The textual session name.
        */
        constructor(origin: fm.liveswitch.sdp.Origin, sessionName: string);
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.message]] class.
        @param origin The originator of the session plus a session identifier and version number.
        @param sessionName The textual session name.
        @param timeDescriptions The array of start, stop, and repeat times for the session.
        */
        constructor(origin: fm.liveswitch.sdp.Origin, sessionName: string, timeDescriptions: fm.liveswitch.sdp.TimeDescription[]);
        /**
        Creates an [[fm.liveswitch.sdp.message]] instance from a string.
        @param s The string to parse.
        */
        static parse(s: string): fm.liveswitch.sdp.Message;
        /**
        Adds a proposed bandwidth.
        @param bandwidth The proposed bandwidth to add.
        */
        addBandwidth(bandwidth: fm.liveswitch.sdp.Bandwidth): void;
        /**
        Adds a media description.
        @param mediaDescription The media description to add.
        */
        addMediaDescription(mediaDescription: fm.liveswitch.sdp.MediaDescription): void;
        /**
        Adds a session-level attribute.
        @param attribute The session-level attribute to add.
        */
        addSessionAttribute(attribute: fm.liveswitch.sdp.Attribute): void;
        /**
        Adds a start, stop, and repeat time.
        @param timeDescription The start, stop, and repeat time to add.
        */
        addTimeDescription(timeDescription: fm.liveswitch.sdp.TimeDescription): void;
        /** @hidden */
        findBundleGroups(): fm.liveswitch.sdp.BundleGroup[];
        /** @hidden */
        findMediaDescription(mid: string): fm.liveswitch.sdp.MediaDescription;
        /** @hidden */
        private findMediaDescriptions;
        /**
        Gets the first media description of type "application".
        */
        getApplicationDescription(): fm.liveswitch.sdp.MediaDescription;
        /**
        Gets any media descriptions of type "application".
        */
        getApplicationDescriptions(): fm.liveswitch.sdp.MediaDescription[];
        /**
        Gets the first media description of type "audio".
        */
        getAudioDescription(): fm.liveswitch.sdp.MediaDescription;
        /**
        Gets any media descriptions of type "audio".
        */
        getAudioDescriptions(): fm.liveswitch.sdp.MediaDescription[];
        /**
        Gets the array of proposed bandwidths to be used by the session.
        */
        getBandwidths(): fm.liveswitch.sdp.Bandwidth[];
        /**
        Gets bundle groups in this media description.
        */
        getBundleGroups(): fm.liveswitch.sdp.BundleGroup[];
        /** @hidden */
        private getBundlingSupport;
        /**
        Gets session-level connection data.
        */
        getConnectionData(): fm.liveswitch.sdp.ConnectionData;
        /**
        Gets the email address for the person responsible for the conference.
        */
        getEmailAddress(): string;
        /**
        Gets the session-level encryption key.
        */
        getEncryptionKey(): fm.liveswitch.sdp.EncryptionKey;
        /** @hidden */
        private getFirstMediaDescription;
        /**
        Gets the array of media descriptions.
        */
        getMediaDescriptions(): fm.liveswitch.sdp.MediaDescription[];
        /**
        Gets the first media description of type "message".
        */
        getMessageDescription(): fm.liveswitch.sdp.MediaDescription;
        /**
        Gets any media descriptions of type "message".
        */
        getMessageDescriptions(): fm.liveswitch.sdp.MediaDescription[];
        /**
        Gets the originator of the session plus a session identifier and version number.
        */
        getOrigin(): fm.liveswitch.sdp.Origin;
        /**
        Gets the phone number for the person responsible for the conference.
        */
        getPhoneNumber(): string;
        /**
        Gets the version of the Session Description Protocol.
        */
        getProtocolVersion(): string;
        /**
        Gets the array of session-level attributes.
        */
        getSessionAttributes(): fm.liveswitch.sdp.Attribute[];
        /**
        Gets textual information about the session.
        */
        getSessionInformation(): string;
        /**
        Obtains Crypto attributes from the session-level attributes in this message. Crypto attributes may also be sent as a media-level argument, so individual media descriptions must also be examined.
        */
        getSessionLevelCryptoAttributes(): fm.liveswitch.sdp.CryptoAttribute[];
        /**
        Obtains the stream direction indicated as a session-level attribute in this message. If none is supplied, StreamDirection.Unset is returned. Stream Direction may also be (and most likely is) indicated as a media-level attribute, so individual media descriptions must also be examined.
        */
        getSessionLevelDirection(): fm.liveswitch.StreamDirection;
        /**
        Obtains Fingerprint attribute from the session-level attributes in this message. Fingerprint attribute may also be sent as a media-level argument, so individual media descriptions must also be examined.
        */
        getSessionLevelFingerprintAttribute(): fm.liveswitch.sdp.ice.FingerprintAttribute;
        /**
        Obtains session-level Ice Options attributes associated with the Sdp Message.
        */
        getSessionLevelIceOptionAttributes(): fm.liveswitch.sdp.Attribute[];
        /**
        Obtains Ice Password Attribute from the session-level attributes in this message. Ice Password attribute may also be sent as a media-level argument, so individual media descriptions must also be examined.
        */
        getSessionLevelIcePasswordAttribute(): fm.liveswitch.sdp.ice.PasswordAttribute;
        /**
        Obtains Ice Ufrag Attribute from the session-level attributes in this message. Ice Ufrag Attributes may also be sent as a media-level argument, so individual media descriptions must also be examined.
        */
        getSessionLevelIceUfragAttribute(): fm.liveswitch.sdp.ice.UfragAttribute;
        /**
        Returns a value stating whether Rtcp Multiplexing support is indicated  as a session-level attribute in this message. Rtcp Multiplexing support may also be indicated via a media-level argument, so individual media descriptions must also be examined.
        */
        getSessionLevelRtcpMultiplexingSupport(): boolean;
        /**
        Obtains session-level RTP ext-map attributes associated with the Sdp Message.
        */
        getSessionLevelRtpExtMapAttributes(): fm.liveswitch.sdp.Attribute[];
        /**
        Obtains Setup Attribute from the session-level attributes in this message. Setup Attributes may also be sent as a media-level argument, so individual media descriptions must also be examined.
        */
        getSessionLevelSetupAttribute(): fm.liveswitch.sdp.SetupAttribute;
        /**
        Gets the textual session name.
        */
        getSessionName(): string;
        /**
        Gets a value indicating whether the SDP Message implies RTP/RTCP Multiplexing Support.
        */
        getSupportsRtcpMultiplexing(): boolean;
        /**
        Gets a value indicating whether Trickle-ICE is supported.
        */
        getSupportsTrickleIce(): boolean;
        /**
        Gets the first media description of type "text".
        */
        getTextDescription(): fm.liveswitch.sdp.MediaDescription;
        /**
        Gets any media descriptions of type "text".
        */
        getTextDescriptions(): fm.liveswitch.sdp.MediaDescription[];
        /**
        Gets the array of start, stop, and repeat times for the session.
        */
        getTimeDescriptions(): fm.liveswitch.sdp.TimeDescription[];
        /**
        Gets the time zone adjustments.
        */
        getTimeZoneAdjustments(): fm.liveswitch.sdp.TimeZones;
        /**
        Gets the pointer to additional information about the session.
        */
        getUri(): fm.liveswitch.Uri;
        /**
        Gets the first media description of type "video".
        */
        getVideoDescription(): fm.liveswitch.sdp.MediaDescription;
        /**
        Gets any media descriptions of type "video".
        */
        getVideoDescriptions(): fm.liveswitch.sdp.MediaDescription[];
        /**
        Adds a media description at the given index.
        @param index The index at which to add the media description.
        @param mediaDescription The media description to add.
        */
        insertMediaDescription(index: number, mediaDescription: fm.liveswitch.sdp.MediaDescription): void;
        /**
        Removes a proposed bandwidth.
        @param bandwidth The proposed bandwidth to remove.
        */
        removeBandwidth(bandwidth: fm.liveswitch.sdp.Bandwidth): boolean;
        /**
        Removes a media description.
        @param mediaDescription The media description to remove.
        */
        removeMediaDescription(mediaDescription: fm.liveswitch.sdp.MediaDescription): boolean;
        /**
        Removes a session-level attribute.
        @param attributeType The session-level attribute type to remove.
        */
        removeSessionAttribute(attributeType: fm.liveswitch.sdp.AttributeType): boolean;
        /**
        Removes a start, stop, and repeat time.
        @param timeDescription The start, stop, and repeat time to remove.
        */
        removeTimeDescription(timeDescription: fm.liveswitch.sdp.TimeDescription): boolean;
        /**
        Removes all time descriptions.
        */
        removeTimeDescriptions(): void;
        /**
        Sets session-level connection data.
        */
        setConnectionData(value: fm.liveswitch.sdp.ConnectionData): void;
        /**
        Sets the email address for the person responsible for the conference.
        */
        setEmailAddress(value: string): void;
        /**
        Sets the session-level encryption key.
        */
        setEncryptionKey(value: fm.liveswitch.sdp.EncryptionKey): void;
        /** @hidden */
        private setOrigin;
        /**
        Sets the phone number for the person responsible for the conference.
        */
        setPhoneNumber(value: string): void;
        /** @hidden */
        private setProtocolVersion;
        /**
        Sets textual information about the session.
        */
        setSessionInformation(value: string): void;
        /** @hidden */
        private setSessionName;
        /**
        Sets a value indicating whether Trickle-ICE is supported.
        */
        setSupportsTrickleIce(value: boolean): void;
        /**
        Sets the time zone adjustments.
        */
        setTimeZoneAdjustments(value: fm.liveswitch.sdp.TimeZones): void;
        /**
        Sets the pointer to additional information about the session.
        */
        setUri(value: fm.liveswitch.Uri): void;
        /**
        Converts this instance to a string.
        */
        toString(): string;
        /**
        Updates SDP Setup Value associated with the session description.
        @param setupValue
        */
        updateSetupValue(setupValue: string): void;
    }
}
declare namespace fm.liveswitch.sdp {
    /**
    Defines valid SDP network types.
    */
    abstract class NetworkType {
        getTypeString(): string;
        /**
        Gets the SDP network type meaning "Internet".
        */
        static getInternet(): string;
    }
}
declare namespace fm.liveswitch.sdp {
    /**
    Defines valid SDP orientations.
    */
    abstract class Orientation {
        getTypeString(): string;
        /**
        Gets the SDP orientation meaning "Landscape".
        */
        static getLandscape(): string;
        /**
        Gets the SDP orientation meaning "Portrait".
        */
        static getPortrait(): string;
        /**
        Gets the SDP orientation meaning "Upside-Down Landscape".
        */
        static getSeascape(): string;
    }
}
declare namespace fm.liveswitch.sdp {
    /**
    Normally this is only used for a whiteboard or presentation tool.  It specifies the orientation of a the workspace on the screen.  It is a media-level attribute.  Permitted values are "portrait", "landscape", and "seascape" (upside-down landscape).  It is not dependent on charset.
    */
    class OrientationAttribute extends fm.liveswitch.sdp.Attribute {
        getTypeString(): string;
        /** @hidden */
        private _orientation;
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.orientationAttribute]] class.
        @param orientation The orientation of a workspace on the screen. See [[fm.liveswitch.sdp.orientationAttribute.orientation]] for possible values.
        */
        constructor(orientation: string);
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.orientationAttribute]] class.
        @param value The attribute value.
        */
        static fromAttributeValue(value: string): fm.liveswitch.sdp.OrientationAttribute;
        /**
        Gets the internal value of the attribute.
        */
        protected getAttributeValue(): string;
        /**
        Gets the orientation of a workspace on the screen. See [[fm.liveswitch.sdp.orientationAttribute.orientation]] for possible values.
        */
        getOrientation(): string;
        /** @hidden */
        private setOrientation;
    }
}
declare namespace fm.liveswitch.sdp {
    /**
    An SDP origin element.
    */
    class Origin {
        getTypeString(): string;
        /** @hidden */
        private _addressType;
        /** @hidden */
        private _networkType;
        /** @hidden */
        private _sessionId;
        /** @hidden */
        private _sessionVersion;
        /** @hidden */
        private _unicastAddress;
        /** @hidden */
        private _username;
        private fmliveswitchsdpOriginInit;
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.origin]] class.
        @param unicastAddress The address of the machine from which the session was created.
        */
        constructor(unicastAddress: string);
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.origin]] class.
        @param unicastAddress The address of the machine from which the session was created.
        @param username The user's login on the originating host.
        */
        constructor(unicastAddress: string, username: string);
        /**
        Creates an [[fm.liveswitch.sdp.origin]] instance from a string.
        @param s The string to parse.
        */
        static parse(s: string): fm.liveswitch.sdp.Origin;
        /** @hidden */
        private generateSessionId;
        /** @hidden */
        private generateSessionVersion;
        /**
        Gets the type of the address. See [[fm.liveswitch.sdp.origin.addressType]] for possible values.
        */
        getAddressType(): string;
        /**
        Gets the type of network. See [[fm.liveswitch.sdp.origin.networkType]] for possible values.
        */
        getNetworkType(): string;
        /**
        Gets the globally unique identifier for the session.
        */
        getSessionId(): number;
        /**
        Gets the version number for the session.
        */
        getSessionVersion(): number;
        /**
        Gets the address of the machine from which the session was created.
        */
        getUnicastAddress(): string;
        /**
        Gets the user's login on the originating host.
        */
        getUsername(): string;
        /**
        Sets the type of the address. See [[fm.liveswitch.sdp.origin.addressType]] for possible values.
        */
        setAddressType(value: string): void;
        /**
        Sets the type of network. See [[fm.liveswitch.sdp.origin.networkType]] for possible values.
        */
        setNetworkType(value: string): void;
        /**
        Sets the globally unique identifier for the session.
        */
        setSessionId(value: number): void;
        /**
        Sets the version number for the session.
        */
        setSessionVersion(value: number): void;
        /**
        Sets the address of the machine from which the session was created.
        */
        setUnicastAddress(value: string): void;
        /**
        Sets the user's login on the originating host.
        */
        setUsername(value: string): void;
        /**
        Converts this instance to a string.
        */
        toString(): string;
    }
}
declare namespace fm.liveswitch.sdp {
    /**
    This gives the length of time in milliseconds represented by the media in a packet.  This is probably only meaningful for audio data, but may be used with other media types if it makes sense.  It should not be necessary to know ptime to decode RTP or vat audio, and it is intended as a recommendation for the encoding/packetisation of audio.  It is a media-level attribute, and it is not dependent on charset.
    */
    class PacketTimeAttribute extends fm.liveswitch.sdp.Attribute {
        getTypeString(): string;
        /** @hidden */
        private _packetTime;
        private fmliveswitchsdpPacketTimeAttributeInit;
        constructor();
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.packetTimeAttribute]] class.
        @param packetTime The length of time in milliseconds represented by
                    the media in a packet.
        */
        constructor(packetTime: number);
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.packetTimeAttribute]] class.
        @param value The attribute value.
        */
        static fromAttributeValue(value: string): fm.liveswitch.sdp.PacketTimeAttribute;
        /**
        Gets the internal value of the attribute.
        */
        protected getAttributeValue(): string;
        /**
        Gets the length of time in milliseconds represented by the media in a packet.
        */
        getPacketTime(): number;
        /** @hidden */
        private setPacketTime;
    }
}
declare namespace fm.liveswitch.sdp {
    /**
    An SDP encryption key with a method of "prompt".
    */
    class PromptEncryptionKey extends fm.liveswitch.sdp.EncryptionKey {
        getTypeString(): string;
        constructor();
        /** @hidden */
        getMethodAndValue(): string;
    }
}
declare namespace fm.liveswitch.sdp {
    /**
    This gives a suggestion for the quality of the encoding as an integer value.  The intention of the quality attribute for video is to specify a non-default trade-off between frame-rate and still-image quality.  For video, the value is in the range 0 to 10, with the following suggested meaning:  10 - the best still-image quality the compression scheme can give. 5  - the default behaviour given no quality suggestion. 0  - the worst still-image quality the codec designer thinks is still usable.  It is a media-level attribute, and it is not dependent on charset.
    */
    class QualityAttribute extends fm.liveswitch.sdp.Attribute {
        getTypeString(): string;
        /** @hidden */
        private _quality;
        private fmliveswitchsdpQualityAttributeInit;
        constructor();
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.qualityAttribute]] class.
        @param quality The suggested quality of the encoding as an integer value from 0-10.
        */
        constructor(quality: number);
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.qualityAttribute]] class.
        @param value The attribute value.
        */
        static fromAttributeValue(value: string): fm.liveswitch.sdp.QualityAttribute;
        /**
        Gets the internal value of the attribute.
        */
        protected getAttributeValue(): string;
        /**
        Gets the suggested quality of the encoding as an integer value from 0-10.
        */
        getQuality(): number;
        /** @hidden */
        private setQuality;
    }
}
declare namespace fm.liveswitch.sdp {
    /**
    This specifies that the tools should be started in receive-only mode where applicable.  It can be either a session- or media- level attribute, and it is not dependent on charset.  Note that recvonly applies to the media only, not to any associated control protocol (e.g., an RTP-based system in recvonly mode SHOULD still send RTCP packets).
    */
    class ReceiveOnlyAttribute extends fm.liveswitch.sdp.DirectionAttribute {
        getTypeString(): string;
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.receiveOnlyAttribute]] class.
        */
        constructor();
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.receiveOnlyAttribute]] class.
        @param value The attribute value.
        */
        static fromAttributeValue(value: string): fm.liveswitch.sdp.ReceiveOnlyAttribute;
        /**
        Gets the internal value of the attribute.
        */
        protected getAttributeValue(): string;
        /**
        Gets the stream direction.
        */
        getStreamDirection(): fm.liveswitch.StreamDirection;
    }
}
declare namespace fm.liveswitch.sdp {
    /**
    An SDP repeat time element.
    */
    class RepeatTime {
        getTypeString(): string;
        /** @hidden */
        private __offsets;
        /** @hidden */
        private _activeDuration;
        /** @hidden */
        private _repeatInterval;
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.repeatTime]] class.
        @param repeatInterval The repeat interval.
        @param activeDuration The active duration.
        */
        constructor(repeatInterval: fm.liveswitch.TimeSpan, activeDuration: fm.liveswitch.TimeSpan);
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.repeatTime]] class.
        @param repeatInterval The repeat interval.
        @param activeDuration The active duration.
        @param offsets The offsets from the start time.
        */
        constructor(repeatInterval: fm.liveswitch.TimeSpan, activeDuration: fm.liveswitch.TimeSpan, offsets: fm.liveswitch.TimeSpan[]);
        /**
        Creates an [[fm.liveswitch.sdp.repeatTime]] instance from a string.
        @param s The string to parse.
        */
        static parse(s: string): fm.liveswitch.sdp.RepeatTime;
        /**
        Adds an offset from the start time.
        @param offset The offset from the start time to add.
        */
        addOffset(offset: fm.liveswitch.TimeSpan): void;
        /**
        Gets the active duration.
        */
        getActiveDuration(): fm.liveswitch.TimeSpan;
        /**
        Gets the array of offsets from the start time.
        */
        getOffsets(): fm.liveswitch.TimeSpan[];
        /**
        Gets the repeat interval.
        */
        getRepeatInterval(): fm.liveswitch.TimeSpan;
        /**
        Removes an offset from the start time.
        @param offset The offset from the start time to remove.
        */
        removeOffset(offset: fm.liveswitch.TimeSpan): boolean;
        /** @hidden */
        private setActiveDuration;
        /** @hidden */
        private setRepeatInterval;
        /**
        Converts this instance to a string.
        */
        toString(): string;
    }
}
declare namespace fm.liveswitch.sdp.rtcp {
    /**
    The RTCP attribute is used to document the RTCP port used for media stream, when that port is not the next higher (odd) port number following the RTP port described in the media line.
    */
    class Attribute extends fm.liveswitch.sdp.Attribute {
        getTypeString(): string;
        /** @hidden */
        private _addressType;
        /** @hidden */
        private _connectionAddress;
        /** @hidden */
        private _networkType;
        /** @hidden */
        private _port;
        private fmliveswitchsdprtcpAttributeInit;
        constructor();
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.rtcp.attribute]] class.
        @param port The RTCP port number.
        @param connectionAddress The RTCP connection address.
        */
        constructor(port: number, connectionAddress: string);
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.rtcp.attribute]] class.
        @param value The attribute value.
        */
        static fromAttributeValue(value: string): fm.liveswitch.sdp.rtcp.Attribute;
        /**
        Gets the type of the address. See [[fm.liveswitch.sdp.rtcp.attribute.addressType]] for possible values.
        */
        getAddressType(): string;
        /**
        Gets the internal value of the attribute.
        */
        protected getAttributeValue(): string;
        /**
        Gets the RTCP connection address.
        */
        getConnectionAddress(): string;
        /**
        Gets the type of network. See [[fm.liveswitch.sdp.rtcp.attribute.networkType]] for possible values.
        */
        getNetworkType(): string;
        /**
        Gets the RTCP port number.
        */
        getPort(): number;
        /**
        Sets the type of the address. See [[fm.liveswitch.sdp.rtcp.attribute.addressType]] for possible values.
        */
        setAddressType(value: string): void;
        /**
        Sets the RTCP connection address.
        */
        setConnectionAddress(value: string): void;
        /**
        Sets the type of network. See [[fm.liveswitch.sdp.rtcp.attribute.networkType]] for possible values.
        */
        setNetworkType(value: string): void;
        /**
        Sets the RTCP port number.
        */
        setPort(value: number): void;
        /**
        Updates the port and connection address.
        @param port The port.
        @param connectionAddress The connection address.
        */
        update(port: number, connectionAddress: string): void;
    }
}
declare namespace fm.liveswitch.sdp.rtcp {
    /**
    This attribute is used to indicate the capability of using RTCP feedback.
    */
    class FeedbackAttribute extends fm.liveswitch.sdp.Attribute {
        getTypeString(): string;
        /** @hidden */
        private _payloadType;
        /** @hidden */
        private _subType;
        /** @hidden */
        private _type;
        private fmliveswitchsdprtcpFeedbackAttributeInit;
        constructor();
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.rtcp.feedbackAttribute]] class.
        @param payloadType The payload type.
        @param type The type.
        */
        constructor(payloadType: number, type: string);
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.rtcp.feedbackAttribute]] class.
        @param payloadType The payload type.
        @param type The type.
        @param subtype The subtype.
        */
        constructor(payloadType: number, type: string, subtype: string);
        /**
        Creates a "ccm fir" feedback attribute.
        @param payloadType The payload type.
        */
        static ccmFirAttribute(payloadType: number): fm.liveswitch.sdp.rtcp.FeedbackAttribute;
        /**
        Creates a "ccm lrr" feedback attribute.
        @param payloadType The payload type.
        */
        static ccmLrrAttribute(payloadType: number): fm.liveswitch.sdp.rtcp.FeedbackAttribute;
        /**
        Creates a "ccm tmmbn" feedback attribute.
        @param payloadType The payload type.
        */
        static ccmTmmbnAttribute(payloadType: number): fm.liveswitch.sdp.rtcp.FeedbackAttribute;
        /**
        Creates a "ccm tmmbr" feedback attribute.
        @param payloadType The payload type.
        */
        static ccmTmmbrAttribute(payloadType: number): fm.liveswitch.sdp.rtcp.FeedbackAttribute;
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.rtcp.feedbackAttribute]] class.
        @param value The attribute value.
        */
        static fromAttributeValue(value: string): fm.liveswitch.sdp.rtcp.FeedbackAttribute;
        /**
        Gets the payload type that represents wildcard feedback attributes ('*').
        */
        static getWildcardPayloadType(): number;
        /**
        Creates a "nack" feedback attribute.
        @param payloadType The payload type.
        */
        static nackAttribute(payloadType: number): fm.liveswitch.sdp.rtcp.FeedbackAttribute;
        /**
        Creates a "nack pli" feedback attribute.
        @param payloadType The payload type.
        */
        static nackPliAttribute(payloadType: number): fm.liveswitch.sdp.rtcp.FeedbackAttribute;
        /**
        Creates a "nack rpsi" feedback attribute.
        @param payloadType The payload type.
        */
        static nackRpsiAttribute(payloadType: number): fm.liveswitch.sdp.rtcp.FeedbackAttribute;
        /**
        Creates a "nack sli" feedback attribute.
        @param payloadType The payload type.
        */
        static nackSliAttribute(payloadType: number): fm.liveswitch.sdp.rtcp.FeedbackAttribute;
        /**
        Creates a "goog-remb" feedback attribute.
        @param payloadType The payload type.
        */
        static rembAttribute(payloadType: number): fm.liveswitch.sdp.rtcp.FeedbackAttribute;
        /**
        Gets the internal value of the attribute.
        */
        protected getAttributeValue(): string;
        /**
        Gets the payload type.
        */
        getPayloadType(): number;
        /**
        Gets the sub-type.
        */
        getSubType(): string;
        /**
        Gets the type.
        */
        getType(): string;
        /**
        Sets the payload type.
        */
        setPayloadType(value: number): void;
        /**
        Sets the sub-type.
        */
        setSubType(value: string): void;
        /**
        Sets the type.
        */
        setType(value: string): void;
    }
}
declare namespace fm.liveswitch.sdp.rtcp {
    /**
    A feedback attribute sub type.
    */
    class FeedbackAttributeSubType {
        getTypeString(): string;
        constructor();
        /**
        Gets the "full intraframe refresh" sub-type.
        */
        static getFir(): string;
        /**
        Gets the "layer refresh request" sub-type.
        */
        static getLrr(): string;
        /**
        Gets the "picture loss indication" sub-type.
        */
        static getPli(): string;
        /**
        Gets the "reference picture selection indication" sub-type.
        */
        static getRpsi(): string;
        /**
        Gets the "slice loss indication" sub-type.
        */
        static getSli(): string;
        /**
        Gets the "temporary maximum media-stream bitrate notification" sub-type.
        */
        static getTmmbn(): string;
        /**
        Gets the "temporary maximum media-stream bitrate request" sub-type.
        */
        static getTmmbr(): string;
    }
}
declare namespace fm.liveswitch.sdp.rtcp {
    /**
    A feedback attribute type.
    */
    class FeedbackAttributeType {
        getTypeString(): string;
        constructor();
        /**
        Gets the "positive acknowledgement" type.
        */
        static getAck(): string;
        /**
        Gets the application-defined type.
        */
        static getApp(): string;
        /**
        Gets the "codec control message" type.
        */
        static getCcm(): string;
        /**
        Gets the "negative acknowledgement" type.
        */
        static getNack(): string;
        /**
        Gets the "receiver estimated maximum bitrate" type.
        */
        static getRemb(): string;
    }
}
declare namespace fm.liveswitch.sdp.rtcp {
    /**
    This attribute is used to signal that RTP and RTCP traffic should be multiplexed on a single port.  It is a property attribute, which does not take a value.
    */
    class MuxAttribute extends fm.liveswitch.sdp.Attribute {
        getTypeString(): string;
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.rtcp.muxAttribute]] class.
        */
        constructor();
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.rtcp.muxAttribute]] class.
        @param value The attribute value.
        */
        static fromAttributeValue(value: string): fm.liveswitch.sdp.rtcp.MuxAttribute;
        /**
        Gets the internal value of the attribute.
        */
        protected getAttributeValue(): string;
    }
}
declare namespace fm.liveswitch.sdp.rtp {
    /**
    https://tools.ietf.org/html/rfc5285#section-5 Stream or media-level attribute used to indicate the presence of RTP Header Extensions, and the mapping of local identifiers used in the header extension to a larger namespace.  A usable mapping MUST use IDs in the valid range, and each ID in this range MUST be used only once for each media (or only once if the mappings are session level).  Mappings that do not conform to these rules MAY be presented, for instance, during offer/answer negotiation as described in the next section, but remapping to conformant values is necessary before they can be applied.  Each extension is named by a URI. Each local identifier potentially used in the stream is mapped to a string using an attribute of the form: a=extmap:VALUE["/"DIRECTION] URI EXTENSIONATTRIBUTES Where URI is a URI, as above, VALUE is the local identifier (ID) of this extension and is an integer in the valid range inclusive (0 is reserved for padding in both forms, and 15 is reserved in the one-byte header form), and direction is one of "sendonly", "recvonly", "sendrecv", or "inactive" (without the quotes). Example:  a=extmap:1 http://example.com/082005/ext.htm#ttime a=extmap:2/sendrecv http://example.com/082005/ext.htm#xmeta short
    */
    class ExtMapAttribute extends fm.liveswitch.sdp.Attribute {
        getTypeString(): string;
        /** @hidden */
        private __direction;
        /** @hidden */
        private _extensionAttributes;
        /** @hidden */
        private _id;
        /** @hidden */
        private _uri;
        private fmliveswitchsdprtpExtMapAttributeInit;
        constructor();
        /**
        RTP Extension Map Attribute.
        @param idValue Local identifier of this extension and is an integer in the valid range inclusive (0 is reserved for padding in both forms, and 15 is reserved in the one-byte header form.
        @param uri Well known extension identifier.
        */
        constructor(idValue: number, uri: string);
        /**
        RTP Extension Map Attribute.
        @param idValue Local identifier of this extension and is an integer in the valid range inclusive (0 is reserved for padding in both forms, and 15 is reserved in the one-byte header form.
        @param uri Well known extension identifier.
        @param direction Disered direction of this RTP Extension Header.
        */
        constructor(idValue: number, uri: string, direction: fm.liveswitch.StreamDirection);
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.rtp.mapAttribute]] class.
        @param value The attribute value.
        */
        static fromAttributeValue(value: string): fm.liveswitch.sdp.rtp.ExtMapAttribute;
        /**
        Gets the internal value of the attribute.
        */
        protected getAttributeValue(): string;
        /**
        Gets the direction of this extension (optional). If not present, stream direction is assumed to be the direction of the extension.
        */
        getDirection(): fm.liveswitch.StreamDirection;
        /**
        Gets extension attributes (optional).
        */
        getExtensionAttributes(): string;
        /**
        Gets the local identifier of this extension.
        */
        getId(): number;
        /**
        Gets the well-known URI of this extension
        */
        getUri(): string;
        /**
        Sets the direction of this extension (optional). If not present, stream direction is assumed to be the direction of the extension.
        */
        setDirection(value: fm.liveswitch.StreamDirection): void;
        /**
        Sets extension attributes (optional).
        */
        setExtensionAttributes(value: string): void;
        /**
        Sets the local identifier of this extension.
        */
        setId(value: number): void;
        /** @hidden */
        private setUri;
    }
}
declare namespace fm.liveswitch.sdp.rtp {
    /** @hidden */
    class FeedbackAttributeCollection {
        getTypeString(): string;
        /** @hidden */
        private __attributes;
        constructor();
        addAttribute(attribute: fm.liveswitch.sdp.rtcp.FeedbackAttribute): boolean;
        /** @hidden */
        private calculateFeedbackAttributeKey;
        clear(): void;
        remove(attribute: fm.liveswitch.sdp.rtcp.FeedbackAttribute): boolean;
        toArray(): fm.liveswitch.sdp.rtcp.FeedbackAttribute[];
        tryGetFeedbackAttribute(payloadType: number, feedbackAttributeType: string, subType: string, feedbackAttribute: fm.liveswitch.Holder<fm.liveswitch.sdp.rtcp.FeedbackAttribute>): boolean;
    }
}
declare namespace fm.liveswitch.sdp.rtp {
    /**
    This attribute maps from an RTP payload type number (as used in an "m=" line) to an format name denoting the payload format to be used.  It also provides information on the clock rate and format parameters.  It is a media-level attribute that is not dependent on charset.
    */
    class MapAttribute extends fm.liveswitch.sdp.Attribute {
        getTypeString(): string;
        /** @hidden */
        private __relatedRtcpFeedbackAttributes;
        /** @hidden */
        private _clockRate;
        /** @hidden */
        private _formatName;
        /** @hidden */
        private _formatParameters;
        /** @hidden */
        private _payloadType;
        /** @hidden */
        private _relatedFormatParametersAttribute;
        /** @hidden */
        private static fm_liveswitch_sdp_rtp_MapAttribute___ianaMapAttributes;
        private fmliveswitchsdprtpMapAttributeInit;
        constructor();
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.rtp.mapAttribute]] class.
        @param payloadType The RTP payload type number.
        @param formatName The format name denoting the payload format to be used.
        @param clockRate The payload clock rate.
        */
        constructor(payloadType: number, formatName: string, clockRate: number);
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.rtp.mapAttribute]] class.
        @param payloadType The RTP payload type number.
        @param formatName The format name denoting the payload format to be used.
        @param clockRate The payload clock rate.
        @param formatParameters The format parameters for the payload.
        */
        constructor(payloadType: number, formatName: string, clockRate: number, formatParameters: string);
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.rtp.mapAttribute]] class.
        @param value The attribute value.
        */
        static fromAttributeValue(value: string): fm.liveswitch.sdp.rtp.MapAttribute;
        /**
        Gets the RTP map attribute for an IANA-reserved payload type.
        @param payloadType The payload type.
        */
        static getIanaMapAttribute(payloadType: number): fm.liveswitch.sdp.rtp.MapAttribute;
        /**
        Adds an Rtcp Feedback attribute associated with this Map Attribute.
        @param attribute
        */
        addRelatedRtcpFeedbackAttribute(attribute: fm.liveswitch.sdp.rtcp.FeedbackAttribute): void;
        /**
        Gets the internal value of the attribute.
        */
        protected getAttributeValue(): string;
        /**
        Gets the payload clock rate.
        */
        getClockRate(): number;
        /**
        Gets the format name denoting the payload format to be used.
        */
        getFormatName(): string;
        /**
        Gets format parameters for the payload.
        */
        getFormatParameters(): string;
        /**
        Gets the RTP payload type number.
        */
        getPayloadType(): number;
        /**
        Gets the RTCP "ccm fir" feedback attribute associated with this payload type.
        */
        getRelatedCcmFirFeedbackAttribute(): fm.liveswitch.sdp.rtcp.FeedbackAttribute;
        /**
        Gets the RTCP "ccm lrr" feedback attribute associated with this payload type.
        */
        getRelatedCcmLrrFeedbackAttribute(): fm.liveswitch.sdp.rtcp.FeedbackAttribute;
        /**
        Gets the RTCP "ccm tmmbn" feedback attribute associated with this payload type.
        */
        getRelatedCcmTmmbnFeedbackAttribute(): fm.liveswitch.sdp.rtcp.FeedbackAttribute;
        /**
        Gets the RTCP "ccm tmmbr" feedback attribute associated with this payload type.
        */
        getRelatedCcmTmmbrFeedbackAttribute(): fm.liveswitch.sdp.rtcp.FeedbackAttribute;
        /**
        Gets Format Parameters attribute associated with this Map Attribute
        */
        getRelatedFormatParametersAttribute(): fm.liveswitch.sdp.FormatParametersAttribute;
        /**
        Gets the RTCP "nack" feedback attribute associated with this payload type.
        */
        getRelatedNackFeedbackAttribute(): fm.liveswitch.sdp.rtcp.FeedbackAttribute;
        /**
        Gets the RTCP "nack pli" feedback attribute associated with this payload type.
        */
        getRelatedNackPliFeedbackAttribute(): fm.liveswitch.sdp.rtcp.FeedbackAttribute;
        /**
        Gets the RTCP "nack rpsi" feedback attribute associated with this payload type.
        */
        getRelatedNackRpsiFeedbackAttribute(): fm.liveswitch.sdp.rtcp.FeedbackAttribute;
        /**
        Gets the RTCP "nack sli" feedback attribute associated with this payload type.
        */
        getRelatedNackSliFeedbackAttribute(): fm.liveswitch.sdp.rtcp.FeedbackAttribute;
        /**
        Gets the RTCP "goog-remb" feedback attribute associated with this payload type.
        */
        getRelatedRembFeedbackAttribute(): fm.liveswitch.sdp.rtcp.FeedbackAttribute;
        /**
        Gets the RTCP feedback attribute for the given payload type, type and subtype associated with this payload type.
        @param payloadType The payload type.
        @param type The type.
        @param subType The sub-type.
        */
        getRelatedRtcpFeedbackAttribute(payloadType: number, type: string, subType: string): fm.liveswitch.sdp.rtcp.FeedbackAttribute;
        /**
        Gets the RTCP feedback attribute for the given type and subtype associated with this payload type.
        @param type The type.
        @param subType The sub-type.
        */
        getRelatedRtcpFeedbackAttribute(type: string, subType: string): fm.liveswitch.sdp.rtcp.FeedbackAttribute;
        /**
        Gets Rtcp Feedback attributes associated with this Map Attribute.
        */
        getRelatedRtcpFeedbackAttributes(): fm.liveswitch.sdp.rtcp.FeedbackAttribute[];
        /**
        Removes an Rtcp Feedback attribute associated with this Map Attribute. Returns true if the attribute was reomved; if the attribute was not present, returns false.
        @param attribute
        */
        removeRelatedRtcpFeedbackAttribute(attribute: fm.liveswitch.sdp.rtcp.FeedbackAttribute): boolean;
        /**
        Resets Rtcp Feedback attributes associated with this Map Attribute.
        */
        resetRtcpFeedbackAttributes(attributes: fm.liveswitch.sdp.rtcp.FeedbackAttribute[]): void;
        /** @hidden */
        private setClockRate;
        /** @hidden */
        private setFormatName;
        /** @hidden */
        private setFormatParameters;
        /**
        Sets the RTP payload type number.
        */
        setPayloadType(value: number): void;
        /**
        Sets Format Parameters attribute associated with this Map Attribute
        */
        setRelatedFormatParametersAttribute(value: fm.liveswitch.sdp.FormatParametersAttribute): void;
        /** @hidden */
        private static __fmliveswitchsdprtpMapAttributeInitialized;
        /** @hidden */
        private static __fmliveswitchsdprtpMapAttributeInitializing;
        /** @hidden */
        static fmliveswitchsdprtpMapAttributeInitialize(): void;
    }
}
declare namespace fm.liveswitch.sdp.rtp {
    /**
    An SDP media description with a transport protocol of "RTP/AVP" or "RTP/SAVP".
    */
    class Media extends fm.liveswitch.sdp.Media {
        getTypeString(): string;
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.rtp.media]] class.
        @param mediaType The media type. See [[fm.liveswitch.sdp.mediaType]] for possible values.
        @param transportPort The transport port.
        @param transportProtocol The transport protocol.
        @param rtpPayloadTypeNumbers The RTP payload type numbers.
        */
        constructor(mediaType: string, transportPort: number, transportProtocol: string, rtpPayloadTypeNumbers: number[]);
        /**
        Generates Rtp Prfile for a given combination of stream type, whjether or not RTCP-based feedback is supported, whether (D)TLS is in use and whether encryption is in use in general.
        @param type Stream type.
        @param rtcpFeedbackSupported Indicates whether Rtcp-based feedback is supported.
        @param useDtls Indicates whether (D)TLS is in use.
        @param useEncryption Indicates whether encryption is in use.
        */
        static generateRtpProfile(type: fm.liveswitch.StreamType, rtcpFeedbackSupported: boolean, useDtls: boolean, useEncryption: boolean): string;
        /**
        Gets the payload types.
        @param formatDesciption The media format desciption.
        */
        static getPayloadTypes(formatDesciption: string): number[];
        /**
        Gets the protocol keyword for the extended RTP audio/video profile.
        */
        static getRtpAvpfTransportProtocol(): string;
        /**
        Gets the protocol keyword for the RTP audio/video profile.
        */
        static getRtpAvpTransportProtocol(): string;
        /**
        Gets the protocol keyword for the extended Secure RTP audio/video profile.
        */
        static getRtpSavpfTransportProtocol(): string;
        /**
        Gets the protocol keyword for the Secure RTP audio/video profile.
        */
        static getRtpSavpTransportProtocol(): string;
        /**
        Gets the protocol keyword for the extended Secure RTP audio/video profile with DTLS key exchange.
        */
        static getUdpTlsRtpSavpfTransportProtocol(): string;
        /**
        Gets the protocol keyword for the Secure RTP audio/video profile with DTLS key exchange.
        */
        static getUdpTlsRtpSavpTransportProtocol(): string;
        /**
        Returns the clockrate of a well-known payload type.
        @param payloadType The well-known payload type to get the clockrate of.
        */
        static getWellKnownPayloadClockRate(payloadType: number): number;
        /**
        Returns the name of a well-known payload type.
        @param payloadType The well-known payload type to get the name of.
        */
        static getWellKnownPayloadName(payloadType: number): string;
        /**
        Returns a value indicating whther a given protocol supports encryption.
        @param protocol Protocol keyword.
        @return Value indicating whther a given protocol supports encryption.
        */
        static supportsEncryption(protocol: string): boolean;
        /**
        Returns a value indicating whther a given protocol supports encryption.
        @param protocol Protocol keyword.
        @return Value indicating whther a given protocol supports encryption.
        */
        static supportsRtcpBasedFeedback(protocol: string): boolean;
    }
}
declare namespace fm.liveswitch.sdp.rtp {
    /**
    A stream for a simulcast stream description.
    */
    class SimulcastStream {
        getTypeString(): string;
        /** @hidden */
        private _ids;
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.rtp.simulcastStream]] class.
        @param idValue The identifier.
        */
        constructor(idValue: fm.liveswitch.sdp.rtp.SimulcastStreamId);
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.rtp.simulcastStream]] class.
        @param ids The identifiers.
        */
        constructor(ids: fm.liveswitch.sdp.rtp.SimulcastStreamId[]);
        /**
        Gets the identifiers.
        */
        getIds(): fm.liveswitch.sdp.rtp.SimulcastStreamId[];
        /** @hidden */
        private setIds;
    }
}
declare namespace fm.liveswitch.sdp.rtp {
    /**
    The allowed directions for a simulcast attribute.
    */
    class SimulcastDirection {
        getTypeString(): string;
        constructor();
        /**
        Gets the receive direction ("recv").
        */
        static getReceive(): string;
        /**
        Gets the send direction ("send").
        */
        static getSend(): string;
    }
}
declare namespace fm.liveswitch.sdp.rtp {
    /**
    A stream description for a simulcast attribute.
    */
    class SimulcastStreamDescription {
        getTypeString(): string;
        /** @hidden */
        private __direction;
        /** @hidden */
        private _streams;
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.rtp.simulcastStreamDescription]] class.
        @param direction The direction.
        @param streams The streams.
        */
        constructor(direction: string, streams: fm.liveswitch.sdp.rtp.SimulcastStream[]);
        /** @hidden */
        private directionIsValid;
        /**
        Gets the direction.
        */
        getDirection(): string;
        /**
        Gets the streams.
        */
        getStreams(): fm.liveswitch.sdp.rtp.SimulcastStream[];
        /** @hidden */
        private setDirection;
        /** @hidden */
        private setStreams;
    }
}
declare namespace fm.liveswitch.sdp.rtp {
    /**
    The allowed directions for an RID attribute.
    */
    class RidDirection {
        getTypeString(): string;
        constructor();
        /**
        Gets the receive direction ("recv").
        */
        static getReceive(): string;
        /**
        Gets the send direction ("send").
        */
        static getSend(): string;
    }
}
declare namespace fm.liveswitch.sdp.rtp {
    /**
    A restriction for an RID attribute.
    */
    class RidRestriction {
        getTypeString(): string;
        /** @hidden */
        private _key;
        /** @hidden */
        private _value;
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.rtp.ridRestriction]] class.
        @param key The key.
        */
        constructor(key: string);
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.rtp.ridRestriction]] class.
        @param key The key.
        @param value The value.
        */
        constructor(key: string, value: string);
        /**
        Gets the "depend" key, for spatial resolution in pixels. The value is a comma-separated list of rid-ids.These rid-ids identify RTP streams that this stream depends on in order to allow for proper interpretation.  The mechanism defined in this document allows for such dependencies to be expressed only when the streams are in the same media section.
        */
        static getDependKey(): string;
        /**
        Gets the "max-br" key, for bit rate in bits per second. The restriction applies to the media payload only, and does not include overhead introduced by other layers(e.g., RTP, UDP, IP, or Ethernet).  The exact means of keeping within this limit are left up to the implementation, and instantaneous excursions outside the limit are permissible. For any given one-second sliding window, however, the total number of bits in the payload portion of RTP SHOULD NOT exceed the value specified in "max-br."
        */
        static getMaxBitrateKey(): string;
        /**
        Gets the "max-bpp" key, for maximum number of bits per pixel, calculated as an average of all samples of any given coded picture. This is expressed as a floating point value, with an allowed range of 0.0001 to 48.0.  These values MUST NOT be encoded with more than four digits to the right of the decimal point.
        */
        static getMaxBitsPerPixelKey(): string;
        /**
        Gets the "max-fs" key, for frame size in pixels per frame. This is the product of frame width and frame height, in pixels, for rectangular frames.
        */
        static getMaxFrameSizeKey(): string;
        /**
        Gets the "max-fps" key, for frame rate in frames per second. For encoders that do not use a fixed framerate for encoding, this value is used to restrict the minimum amount of time between frames: the time between any two consecutive frames SHOULD NOT be less than 1 / max - fps seconds.
        */
        static getMaxFramesPerSecondKey(): string;
        /**
        Gets the "max-height" key, for spatial resolution in pixels. In the case that stream orientation signaling is used to modify the intended display orientation, this attribute refers to the height of the stream when a rotation of zero degrees is encoded.
        */
        static getMaxHeightKey(): string;
        /**
        Gets the "max-pps" key, for pixel rate in pixels per second. This value SHOULD be handled identically to max-fps, after performing the following conversion: max-fps = max-pps / (width* height).  If the stream resolution changes, this value is recalculated. Due to this recalculation, excursions outside the specified maximum are possible near resolution change boundaries.
        */
        static getMaxPixelsPerSecondKey(): string;
        /**
        Gets the "max-width" key, for spatial resolution in pixels. In the case that stream orientation signaling is used to modify the intended display orientation, this attribute refers to the width of the stream when a rotation of zero degrees is encoded.
        */
        static getMaxWidthKey(): string;
        /**
        Gets the restriction key.
        */
        getKey(): string;
        /**
        Gets the restriction value.
        */
        getValue(): string;
        /** @hidden */
        private setKey;
        /**
        Sets the restriction value.
        */
        setValue(value: string): void;
    }
}
declare namespace fm.liveswitch.sdp.rtp {
    /**
    The SDP media attribute "rid" specifies restrictions defining a unique RTP payload configuration.
    */
    class RidAttribute extends fm.liveswitch.sdp.Attribute {
        getTypeString(): string;
        /** @hidden */
        private __direction;
        /** @hidden */
        private _id;
        /** @hidden */
        private _payloadTypes;
        /** @hidden */
        private _restrictions;
        constructor();
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.rtp.ridAttribute]] class.
        @param idValue The identifier.
        @param direction The direction.
        */
        constructor(idValue: string, direction: string);
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.rtp.ridAttribute]] class.
        @param idValue The identifier.
        @param direction The direction.
        @param payloadTypes The payload types.
        */
        constructor(idValue: string, direction: string, payloadTypes: number[]);
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.rtp.ridAttribute]] class.
        @param idValue The identifier.
        @param direction The direction.
        @param payloadTypes The payload types.
        @param restrictions The restrictions.
        */
        constructor(idValue: string, direction: string, payloadTypes: number[], restrictions: fm.liveswitch.sdp.rtp.RidRestriction[]);
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.rtp.ridAttribute]] class.
        @param idValue The identifier.
        @param direction The direction.
        @param restrictions The restrictions.
        */
        constructor(idValue: string, direction: string, restrictions: fm.liveswitch.sdp.rtp.RidRestriction[]);
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.rtp.ridAttribute]] class.
        @param value The attribute value.
        */
        static fromAttributeValue(value: string): fm.liveswitch.sdp.rtp.RidAttribute;
        /**
        Validates that the identifier conforms to RFC syntax, which means that it only contains alpha-numeric characters and/or the hyphen and underscore. See https://tools.ietf.org/html/draft-ietf-avtext-rid/ and https://tools.ietf.org/html/draft-ietf-mmusic-rid/ for more info.
        @param idValue The identifier
        */
        static validateId(idValue: string): boolean;
        /** @hidden */
        private directionIsValid;
        /**
        Gets the internal value of the attribute.
        */
        protected getAttributeValue(): string;
        /**
        Gets the direction.
        */
        getDirection(): string;
        /**
        Gets the identifier.
        */
        getId(): string;
        /**
        Gets the payload types that can be used in the associated stream. This property is optional and may be null.
        */
        getPayloadTypes(): number[];
        /**
        Gets the codec-agnostic restrictions to which the corresponding stream will conform. This property is optional and may be null.
        */
        getRestrictions(): fm.liveswitch.sdp.rtp.RidRestriction[];
        /**
        Gets a restriction value.
        @param restrictionKey The restriction key.
        */
        getRestrictionValue(restrictionKey: string): string;
        /** @hidden */
        private setDirection;
        /** @hidden */
        private setId;
        /**
        Sets the payload types that can be used in the associated stream. This property is optional and may be null.
        */
        setPayloadTypes(value: number[]): void;
        /**
        Sets the codec-agnostic restrictions to which the corresponding stream will conform. This property is optional and may be null.
        */
        setRestrictions(value: fm.liveswitch.sdp.rtp.RidRestriction[]): void;
    }
}
declare namespace fm.liveswitch.sdp.rtp {
    /**
    The SDP media attribute "simulcast" describes, independently for send and receive directions, the number of simulcast RTP streams as well as potential alternative formats for each simulcast RTP stream.
    */
    class SimulcastAttribute extends fm.liveswitch.sdp.Attribute {
        getTypeString(): string;
        /** @hidden */
        private _description1;
        /** @hidden */
        private _description2;
        /** @hidden */
        private _draftVersion;
        private fmliveswitchsdprtpSimulcastAttributeInit;
        constructor();
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.rtp.simulcastAttribute]] class.
        @param description The description.
        */
        constructor(description: fm.liveswitch.sdp.rtp.SimulcastStreamDescription);
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.rtp.simulcastAttribute]] class.
        @param description1 The first description.
        @param description2 The second description.
        */
        constructor(description1: fm.liveswitch.sdp.rtp.SimulcastStreamDescription, description2: fm.liveswitch.sdp.rtp.SimulcastStreamDescription);
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.rtp.simulcastAttribute]] class.
        @param value The attribute value.
        */
        static fromAttributeValue(value: string): fm.liveswitch.sdp.rtp.SimulcastAttribute;
        /** @hidden */
        private static streamsFromString;
        /** @hidden */
        private static streamsToString;
        /**
        Gets the internal value of the attribute.
        */
        protected getAttributeValue(): string;
        /** @hidden */
        private getDescription;
        /**
        Gets the first description.
        */
        getDescription1(): fm.liveswitch.sdp.rtp.SimulcastStreamDescription;
        /**
        Gets the second description.
        */
        getDescription2(): fm.liveswitch.sdp.rtp.SimulcastStreamDescription;
        /**
        Gets the version of the IETF draft to comply with. https://tools.ietf.org/html/draft-ietf-mmusic-sdp-simulcast
        */
        getDraftVersion(): number;
        /**
        Gets the 'receive' description.
        */
        getReceiveDescription(): fm.liveswitch.sdp.rtp.SimulcastStreamDescription;
        /**
        Gets the 'send' description.
        */
        getSendDescription(): fm.liveswitch.sdp.rtp.SimulcastStreamDescription;
        /** @hidden */
        private setDescription1;
        /** @hidden */
        private setDescription2;
        /**
        Sets the version of the IETF draft to comply with. https://tools.ietf.org/html/draft-ietf-mmusic-sdp-simulcast
        */
        setDraftVersion(value: number): void;
    }
}
declare namespace fm.liveswitch.sdp.rtp {
    /**
    A simulcast stream identifier.
    */
    class SimulcastStreamId {
        getTypeString(): string;
        /** @hidden */
        private _id;
        /** @hidden */
        private _paused;
        private fmliveswitchsdprtpSimulcastStreamIdInit;
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.rtp.simulcastStreamId]] class.
        @param idValue The identifier.
        */
        constructor(idValue: string);
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.rtp.simulcastStreamId]] class.
        @param idValue The identifier.
        @param paused Whether the stream is paused.
        */
        constructor(idValue: string, paused: boolean);
        /**
        Gets the identifier.
        */
        getId(): string;
        /**
        Gets whether the stream is paused.
        */
        getPaused(): boolean;
        /** @hidden */
        private setId;
        /** @hidden */
        private setPaused;
    }
}
declare namespace fm.liveswitch.sdp.rtp {
    /**
    The SDP media attribute "ssrc-group" expresses a relationship among several sources of an RTP session.
    */
    class SsrcGroupAttribute extends fm.liveswitch.sdp.Attribute {
        getTypeString(): string;
        /** @hidden */
        private _semantics;
        /** @hidden */
        private _synchronizationSources;
        constructor();
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.rtp.ssrcGroupAttribute]] class.
        @param semantics The semantics.
        @param synchronizationSources The synchronization sources.
        */
        constructor(semantics: string, synchronizationSources: number[]);
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.rtp.ssrcGroupAttribute]] class.
        @param value The attribute value.
        */
        static fromAttributeValue(value: string): fm.liveswitch.sdp.rtp.SsrcGroupAttribute;
        /**
        Gets the internal value of the attribute.
        */
        protected getAttributeValue(): string;
        /**
        Gets the semantics.
        */
        getSemantics(): string;
        /**
        Gets the synchronization sources.
        */
        getSynchronizationSources(): number[];
        /** @hidden */
        private setSemantics;
        /** @hidden */
        private setSynchronizationSources;
    }
}
declare namespace fm.liveswitch.sdp.rtp {
    /**
    The SDP media attribute "ssrc" indicates a property (known as a "source-level attribute") of a media source (RTP stream) within an RTP session.
    */
    class SsrcAttribute extends fm.liveswitch.sdp.Attribute {
        getTypeString(): string;
        /** @hidden */
        private _name;
        /** @hidden */
        private _synchronizationSource;
        /** @hidden */
        private _value;
        private fmliveswitchsdprtpSsrcAttributeInit;
        constructor();
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.rtp.ssrcAttribute]] class.
        @param synchronizationSource The synchronization source.
        @param attributeName Name of the attribute.
        */
        constructor(synchronizationSource: number, attributeName: string);
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.rtp.ssrcAttribute]] class.
        @param synchronizationSource The synchronization source.
        @param attributeName Name of the attribute.
        @param attributeValue The attribute value.
        */
        constructor(synchronizationSource: number, attributeName: string, attributeValue: string);
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.rtp.ssrcAttribute]] class.
        @param value The attribute value.
        */
        static fromAttributeValue(value: string): fm.liveswitch.sdp.rtp.SsrcAttribute;
        /**
        Gets the internal value of the attribute.
        */
        protected getAttributeValue(): string;
        /**
        Gets the name of the attribute.
        */
        getName(): string;
        /**
        Gets the synchronization source.
        */
        getSynchronizationSource(): number;
        /**
        Gets the attribute value.
        */
        getValue(): string;
        /** @hidden */
        private setName;
        /** @hidden */
        private setSynchronizationSource;
        /**
        Sets the attribute value.
        */
        setValue(value: string): void;
    }
}
declare namespace fm.liveswitch.sdp.rtp {
    /**
    SSRC atribute names.
    */
    class SsrcAttributeName {
        getTypeString(): string;
        constructor();
        /**
        Gets a value indicating canonical name.
        */
        static getCName(): string;
        /**
        Gets a value indicating format parameters.
        */
        static getFormatParameters(): string;
        /**
        Gets a value indicating label.
        */
        static getLabel(): string;
        /**
        Gets a value indicating media stream ID.
        */
        static getMediaStreamId(): string;
        /**
        Gets a value indicating media stream label.
        */
        static getMediaStreamLabel(): string;
        /**
        Gets a value indicating previous SSRC.
        */
        static getPreviousSsrc(): string;
    }
}
declare namespace fm.liveswitch.sdp.sctp {
    /**
    AB: Legacy attribute. To be removed when Firefox and Chrome stop using it. The sctpmap attribute maps from a port number (as used in an "m=" line) to an encoding name denoting the payload format to be used on top of the SCTP association or the actual protocol running on top of it. Last appears in https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-06#page-6 Has been replaced in subsequent drafts but is used in Firefox and Chrome for now.
    */
    class MapAttribute extends fm.liveswitch.sdp.Attribute {
        getTypeString(): string;
        /** @hidden */
        private _port;
        /** @hidden */
        private _sctpProtocol;
        /** @hidden */
        private _streams;
        private fmliveswitchsdpsctpMapAttributeInit;
        constructor();
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.sctp.portAttribute]] class.
        @param port The SCTP port.
        @param protocol The protocol.
        @param streams The streams.
        */
        constructor(port: number, protocol: string, streams: number);
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.sctp.portAttribute]] class.
        @param value The attribute value.
        */
        static fromAttributeValue(value: string): fm.liveswitch.sdp.sctp.MapAttribute;
        /**
        Gets the internal value of the attribute.
        */
        protected getAttributeValue(): string;
        /**
        Gets the SCTP port.
        */
        getPort(): number;
        /**
        Gets the SCTP sub-protocol (association usage).
        */
        getSctpProtocol(): string;
        /**
        Gets the number of incoming streams.
        */
        getStreams(): number;
        /** @hidden */
        private setPort;
        /** @hidden */
        private setSctpProtocol;
        /** @hidden */
        private setStreams;
    }
}
declare namespace fm.liveswitch.sdp.sctp {
    /**
    The attribute can be associated with an m- line to indicate the maximum message size (indicated in bytes) that an SCTP endpoint is willing to receive on the SCTP association associated with the m- line. Different attribute values can be used in each direction.
    */
    class MaxMessageSizeAttribute extends fm.liveswitch.sdp.Attribute {
        getTypeString(): string;
        /** @hidden */
        private _maxMessageSize;
        private fmliveswitchsdpsctpMaxMessageSizeAttributeInit;
        constructor();
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.sctp.maxMessageSizeAttribute]] class.
        @param maxMessageSize The maximum message size in bytes.
        */
        constructor(maxMessageSize: number);
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.sctp.maxMessageSizeAttribute]] class.
        @param value The attribute value.
        */
        static fromAttributeValue(value: string): fm.liveswitch.sdp.sctp.MaxMessageSizeAttribute;
        /**
        Gets the internal value of the attribute.
        */
        protected getAttributeValue(): string;
        /**
        Gets the maximum message size in bytes.
        */
        getMaxMessageSize(): number;
        /** @hidden */
        private setMaxMessageSize;
    }
}
declare namespace fm.liveswitch.sdp.sctp {
    /**
    An SDP media description with a transport protocol of "RTP/AVP" or "RTP/SAVP".
    */
    class Media extends fm.liveswitch.sdp.Media {
        getTypeString(): string;
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.sctp.media]] class.
        @param mediaType The media type. See [[fm.liveswitch.sdp.mediaType]] for possible values.
        @param transportPort The transport port.
        @param transportProtocol The transport protocol.
        @param associationUsage The association usage.
        */
        constructor(mediaType: string, transportPort: number, transportProtocol: string, associationUsage: string);
        /**
        Gets the protocol keyword for the SCTP over DTLS data profile.
        */
        static getDtlsSctpTransportProtocol(): string;
        /**
        Gets the protocol keyword for the DTLS over SCTP data profile.
        */
        static getSctpDtlsTransportProtocol(): string;
        /**
        Gets the protocol keyword for the SCTP data profile.
        */
        static getSctpTransportProtocol(): string;
        /**
        Gets the protocol keyword for the SCTP over DTLS over TCP data profile.
        */
        static getTcpDtlsSctpTransportProtocol(): string;
        /**
        Gets the protocol keyword for the SCTP over DTLS over UDP data profile.
        */
        static getUdpDtlsSctpTransportProtocol(): string;
        /**
        Gets the Association Usage name registry for WebRTC Datachannel.
        */
        static getWebRtcDatachannelAssociationUsage(): string;
        /**
        Returns a value indicating whther a given protocol is supported.
        @param protocol Protocol keyword.
        @return Value indicating whther a given protocol is supported.
        */
        static isSupported(protocol: string): boolean;
        /**
        Returns a value indicating whther a given protocol supports encryption.
        @param protocol Protocol keyword.
        @return Value indicating whther a given protocol supports encryption.
        */
        static supportsEncryption(protocol: string): boolean;
    }
}
declare namespace fm.liveswitch.sdp.sctp {
    /**
    The attribute can be associated with an SDP media description (m- line) with a 'UDP/DTLS/SCTP' or a 'TCP/DTLS/SCTP' proto value, in which case the m- line port value indicates the port of the underlying transport-layer protocol (UDP or TCP), on which SCTP is carried, and the 'sctp-port' value indicates the SCTP port.
    */
    class PortAttribute extends fm.liveswitch.sdp.Attribute {
        getTypeString(): string;
        /** @hidden */
        private _port;
        private fmliveswitchsdpsctpPortAttributeInit;
        constructor();
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.sctp.portAttribute]] class.
        @param port The SCTP port.
        */
        constructor(port: number);
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.sctp.portAttribute]] class.
        @param value The attribute value.
        */
        static fromAttributeValue(value: string): fm.liveswitch.sdp.sctp.PortAttribute;
        /**
        Gets the internal value of the attribute.
        */
        protected getAttributeValue(): string;
        /**
        Gets the SCTP port.
        */
        getPort(): number;
        /** @hidden */
        private setPort;
    }
}
declare namespace fm.liveswitch.sdp {
    /**
    This can be a session-level attribute or a media-level attribute.  As a session-level attribute, it specifies the language for the session description.  As a media-level attribute, it specifies the language for any media-level SDP information field associated with that media.  Multiple sdplang attributes can be provided either at session or media level if multiple languages in the session description or media use multiple languages, in which case the order of the attributes indicates the order of importance of the various languages in the session or media from most important to least important.
    */
    class SdpLanguageAttribute extends fm.liveswitch.sdp.Attribute {
        getTypeString(): string;
        /** @hidden */
        private _languageTag;
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.sdpLanguageAttribute]] class.
        @param languageTag The language for either the session description
                    (if used as a session-level attribute) or any media-level SDP
                    information field associated with that media (if used as a
                    media-level attribute).
        */
        constructor(languageTag: string);
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.sdpLanguageAttribute]] class.
        @param value The attribute value.
        */
        static fromAttributeValue(value: string): fm.liveswitch.sdp.SdpLanguageAttribute;
        /**
        Gets the internal value of the attribute.
        */
        protected getAttributeValue(): string;
        /**
        Gets the language for either the session description (if used as a session-level attribute) or any media-level SDP information field associated with that media (if used as a media-level attribute).
        */
        getLanguageTag(): string;
        /** @hidden */
        private setLanguageTag;
    }
}
declare namespace fm.liveswitch.sdp {
    /**
    This specifies that the tools should be started in send-only mode.  An example may be where a different unicast address is to be used for a traffic destination than for a traffic source. In such a case, two media descriptions may be used, one sendonly and one recvonly.  It can be either a session- or media-level attribute, but would normally only be used as a media attribute.  It is not dependent on charset.  Note that sendonly applies only to the media, and any associated control protocol (e.g., RTCP) SHOULD still be received and processed as normal.
    */
    class SendOnlyAttribute extends fm.liveswitch.sdp.DirectionAttribute {
        getTypeString(): string;
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.sendOnlyAttribute]] class.
        */
        constructor();
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.sendOnlyAttribute]] class.
        @param value The attribute value.
        */
        static fromAttributeValue(value: string): fm.liveswitch.sdp.SendOnlyAttribute;
        /**
        Gets the internal value of the attribute.
        */
        protected getAttributeValue(): string;
        /**
        Gets the stream direction.
        */
        getStreamDirection(): fm.liveswitch.StreamDirection;
    }
}
declare namespace fm.liveswitch.sdp {
    /**
    This specifies that the tools should be started in send and receive mode.  This is necessary for interactive conferences with tools that default to receive-only mode.  It can be either a session or media-level attribute, and it is not dependent on charset.
    */
    class SendReceiveAttribute extends fm.liveswitch.sdp.DirectionAttribute {
        getTypeString(): string;
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.sendReceiveAttribute]] class.
        */
        constructor();
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.sendReceiveAttribute]] class.
        @param value The attribute value.
        */
        static fromAttributeValue(value: string): fm.liveswitch.sdp.SendReceiveAttribute;
        /**
        Gets the internal value of the attribute.
        */
        protected getAttributeValue(): string;
        /**
        Gets the stream direction.
        */
        getStreamDirection(): fm.liveswitch.StreamDirection;
    }
}
declare namespace fm.liveswitch.sdp {
    /**
    Defines valid SDP setups.
    */
    abstract class Setup {
        getTypeString(): string;
        /**
        Gets the SDP setup meaning "Active".
        */
        static getActive(): string;
        /**
        Gets the SDP setup meaning "Active or Passive".
        */
        static getActPass(): string;
        /**
        Gets the SDP setup meaning "Passive".
        */
        static getPassive(): string;
    }
}
declare namespace fm.liveswitch.sdp {
    /**
    The 'setup' attribute indicates which of the end points should initiate the TCP connection establishment (i.e., send the initial TCP SYN).  The 'setup' attribute is charset-independent and can be a session-level or a media-level attribute.
    */
    class SetupAttribute extends fm.liveswitch.sdp.Attribute {
        getTypeString(): string;
        /** @hidden */
        private _setup;
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.setupAttribute]] class.
        @param setup Which end point should initiate the connection establishment. See [[fm.liveswitch.sdp.setupAttribute.setup]] for possible values.
        */
        constructor(setup: string);
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.setupAttribute]] class.
        @param value The attribute value.
        */
        static fromAttributeValue(value: string): fm.liveswitch.sdp.SetupAttribute;
        /**
        Gets the internal value of the attribute.
        */
        protected getAttributeValue(): string;
        /**
        Gets which end point should initiate the connection establishment. See [[fm.liveswitch.sdp.setupAttribute.setup]] for possible values.
        */
        getSetup(): string;
        /** @hidden */
        private setSetup;
    }
}
declare namespace fm.liveswitch.sdp {
    /**
    An SDP time description element.
    */
    class TimeDescription {
        getTypeString(): string;
        /** @hidden */
        private __repeatTimes;
        /** @hidden */
        private _timing;
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.timeDescription]] class.
        @param timing The start and stop time.
        */
        constructor(timing: fm.liveswitch.sdp.Timing);
        /**
        Creates an [[fm.liveswitch.sdp.timeDescription]] instance from a string.
        @param s The string to parse.
        */
        static parse(s: string): fm.liveswitch.sdp.TimeDescription;
        /**
        Adds a repeat time.
        @param repeatTime The repeat time to add.
        */
        addRepeatTime(repeatTime: fm.liveswitch.sdp.RepeatTime): void;
        /**
        Gets the array of repeat times.
        */
        getRepeatTimes(): fm.liveswitch.sdp.RepeatTime[];
        /**
        Gets the start and stop time.
        */
        getTiming(): fm.liveswitch.sdp.Timing;
        /**
        Removes a repeat time.
        @param repeatTime The repeat time to remove.
        */
        removeRepeatTime(repeatTime: fm.liveswitch.sdp.RepeatTime): boolean;
        /** @hidden */
        private setTiming;
        /**
        Converts this instance to a string.
        */
        toString(): string;
    }
}
declare namespace fm.liveswitch.sdp {
    /**
    An SDP time zone element.
    */
    class TimeZone {
        getTypeString(): string;
        /** @hidden */
        private _adjustmentTime;
        /** @hidden */
        private _offset;
        private fmliveswitchsdpTimeZoneInit;
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.timeZone]] class.
        @param adjustmentTime The time that a time zone adjustment happens (network time protocol).
        @param offset The offset from the time when the session was first scheduled.
        */
        constructor(adjustmentTime: number, offset: fm.liveswitch.TimeSpan);
        /**
        Creates an [[fm.liveswitch.sdp.timeZone]] instance from a string.
        @param s The string to parse.
        */
        static parse(s: string): fm.liveswitch.sdp.TimeZone;
        /**
        Gets the time that a time zone adjustment happens (network time protocol).
        */
        getAdjustmentTime(): number;
        /**
        Gets the offset from the time when the session was first scheduled.
        */
        getOffset(): fm.liveswitch.TimeSpan;
        /** @hidden */
        private setAdjustmentTime;
        /** @hidden */
        private setOffset;
        /**
        Converts this instance to a string.
        */
        toString(): string;
    }
}
declare namespace fm.liveswitch.sdp {
    /**
    An SDP time zones element.
    */
    class TimeZones {
        getTypeString(): string;
        /** @hidden */
        private __values;
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.timeZones]] class.
        @param values The values.
        */
        constructor(values: fm.liveswitch.sdp.TimeZone[]);
        /**
        Creates an [[fm.liveswitch.sdp.timeZones]] instance from a string.
        @param s The string to parse.
        */
        static parse(s: string): fm.liveswitch.sdp.TimeZones;
        /**
        Adds a time zone adjustment.
        @param value The time zone adjustment to add.
        */
        addTimeZone(value: fm.liveswitch.sdp.TimeZone): void;
        /**
        Gets the array of time zone adjustments.
        */
        getValues(): fm.liveswitch.sdp.TimeZone[];
        /**
        Removes a time zone adjustment.
        @param value The time zone adjustment to remove.
        */
        removeTimeZone(value: fm.liveswitch.sdp.TimeZone): boolean;
        /**
        Converts this instance to a string.
        */
        toString(): string;
    }
}
declare namespace fm.liveswitch.sdp {
    /**
    An SDP timing element.
    */
    class Timing {
        getTypeString(): string;
        /** @hidden */
        private _startTime;
        /** @hidden */
        private _stopTime;
        private fmliveswitchsdpTimingInit;
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.timing]] class.
        */
        constructor();
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.timing]] class.
        @param startTime The start time.
        @param stopTime The stop time.
        */
        constructor(startTime: number, stopTime: number);
        /**
        Creates an [[fm.liveswitch.sdp.timing]] instance from a string.
        @param s The string to parse.
        */
        static parse(s: string): fm.liveswitch.sdp.Timing;
        /**
        Gets the start time.
        */
        getStartTime(): number;
        /**
        Gets the stop time.
        */
        getStopTime(): number;
        /**
        Sets the start time.
        */
        setStartTime(value: number): void;
        /**
        Sets the stop time.
        */
        setStopTime(value: number): void;
        /**
        Converts this instance to a string.
        */
        toString(): string;
    }
}
declare namespace fm.liveswitch.sdp {
    /**
    This gives the name and version number of the tool used to create the session description.  It is a session-level attribute, and it is not dependent on charset.
    */
    class ToolAttribute extends fm.liveswitch.sdp.Attribute {
        getTypeString(): string;
        /** @hidden */
        private _tool;
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.toolAttribute]] class.
        @param tool The name and version number of the
                    tool used to create the session description.
        */
        constructor(tool: string);
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.toolAttribute]] class.
        @param value The attribute value.
        */
        static fromAttributeValue(value: string): fm.liveswitch.sdp.ToolAttribute;
        /**
        Gets the internal value of the attribute.
        */
        protected getAttributeValue(): string;
        /**
        Gets the name and version number of the tool used to create the session description.
        */
        getTool(): string;
        /** @hidden */
        private setTool;
    }
}
declare namespace fm.liveswitch.sdp {
    /**
    An SDP media description with a transport protocol of "udp".
    */
    class UdpMedia extends fm.liveswitch.sdp.Media {
        getTypeString(): string;
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.udpMedia]] class.
        @param mediaType The media type. See [[fm.liveswitch.sdp.mediaType]] for possible values.
        @param transportPort The transport port.
        @param formatDescription The format description.
        */
        constructor(mediaType: string, transportPort: number, formatDescription: string);
        /**
        Gets the protocol keyword for UDP.
        */
        static getUdpTransportProtocol(): string;
    }
}
declare namespace fm.liveswitch.sdp {
    /**
    This attribute is used to encapsulate unrecognized SDP attributes.
    */
    class UnknownAttribute extends fm.liveswitch.sdp.Attribute {
        getTypeString(): string;
        /** @hidden */
        private _name;
        /** @hidden */
        private _value;
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.unknownAttribute]] class.
        @param name The name.
        @param value The value.
        */
        constructor(name: string, value: string);
        /**
        Gets the internal value of the attribute.
        */
        protected getAttributeValue(): string;
        /**
        Gets the attribute name.
        */
        getName(): string;
        /**
        Gets the attribute value.
        */
        getValue(): string;
        /** @hidden */
        private setName;
        /** @hidden */
        private setValue;
    }
}
declare namespace fm.liveswitch.sdp {
    /**
    An SDP encryption key with a method of "uri".
    */
    class UriEncryptionKey extends fm.liveswitch.sdp.EncryptionKey {
        getTypeString(): string;
        /** @hidden */
        private _uri;
        /**
        Initializes a new instance of the [[fm.liveswitch.sdp.uriEncryptionKey]] class.
        @param uri The URI referring to the data containing the key.
        */
        constructor(uri: fm.liveswitch.Uri);
        /** @hidden */
        getMethodAndValue(): string;
        /**
        Gets the URI referring to the data containing the key.
        */
        getUri(): fm.liveswitch.Uri;
        /** @hidden */
        private setUri;
    }
}
declare namespace fm.liveswitch.sdp {
    /** @hidden */
    class Utility {
        getTypeString(): string;
        constructor();
        static splitAndClean(s: string): string[];
    }
}
declare namespace fm.liveswitch {
    /**
    A session description.
    */
    class SessionDescription {
        getTypeString(): string;
        /** @hidden */
        private _renegotiation;
        /** @hidden */
        private _sdpMessage;
        /** @hidden */
        private _tieBreaker;
        /** @hidden */
        private _type;
        private fmliveswitchSessionDescriptionInit;
        constructor();
        /**
        Deserializes an instance from JSON.
        @param sessionDescriptionJson The JSON to deserialize.
        @return The deserialized session description.
        */
        static fromJson(sessionDescriptionJson: string): fm.liveswitch.SessionDescription;
        /**
        Serializes an instance to JSON.
        @param sessionDescription The session description.
        @return
                    The serialized JSON.
            
        */
        static toJson(sessionDescription: fm.liveswitch.SessionDescription): string;
        /**
        Gets a value indicating whether an audio stream is described.
        */
        getHasAudio(): boolean;
        /**
        Gets a value indicating whether a data stream is described.
        */
        getHasData(): boolean;
        /**
        Gets a value indicating whether a video stream is described.
        */
        getHasVideo(): boolean;
        /**
        Gets a value indicating whether this instance is offer.
        */
        getIsOffer(): boolean;
        /** @hidden */
        getRenegotiation(): boolean;
        /**
        Gets the SDP message.
        */
        getSdpMessage(): fm.liveswitch.sdp.Message;
        /**
        Gets the session id of the remote description, if remote description is set. Returns null otherwise.
        */
        getSessionId(): number;
        /**
        Gets the version of the remote description, if remote description is set. Returns null otherwise.
        */
        getSessionVersion(): number;
        /**
        Gets the tie breaker in case of a role conflict.
        */
        getTieBreaker(): string;
        /**
        Gets the type.
        */
        getType(): fm.liveswitch.SessionDescriptionType;
        /** @hidden */
        setRenegotiation(value: boolean): void;
        /**
        Sets the SDP message.
        */
        setSdpMessage(value: fm.liveswitch.sdp.Message): void;
        /**
        Sets the tie breaker in case of a role conflict.
        */
        setTieBreaker(value: string): void;
        /**
        Sets the type.
        */
        setType(value: fm.liveswitch.SessionDescriptionType): void;
        /**
        Serializes this instance to JSON.
        */
        toJson(): string;
    }
}
declare namespace fm.liveswitch {
    class SessionDescriptionTypeWrapper {
        getTypeString(): string;
        /** @hidden */
        private _value;
        constructor(value: fm.liveswitch.SessionDescriptionType);
        toString(): string;
    }
}
declare namespace fm.liveswitch {
    /**
    A size (width and height).
    */
    class Size {
        getTypeString(): string;
        /** @hidden */
        private __height;
        /** @hidden */
        private __width;
        /** @hidden */
        private static fm_liveswitch_Size___empty;
        private fmliveswitchSizeInit;
        /**
        Initializes a new instance of the [[fm.liveswitch.size]] class.
        */
        constructor();
        /**
        Initializes a new instance of the [[fm.liveswitch.size]] class.
        @param width The width.
        @param height The height.
        */
        constructor(width: number, height: number);
        /**
        Deserializes an instance from JSON.
        @param sizeJson The JSON to deserialize.
        @return The deserialized size.
        */
        static fromJson(sizeJson: string): fm.liveswitch.Size;
        /**
        Gets the empty size (0x0).
        */
        static getEmpty(): fm.liveswitch.Size;
        /**
        Determines whether the two sizes are equivalent.
        @param size1 The first size.
        @param size2 The second size.
        */
        static isEquivalent(size1: fm.liveswitch.Size, size2: fm.liveswitch.Size): boolean;
        /** @hidden */
        private static isEquivalentNoCheck;
        /**
        Serializes an instance to JSON.
        @param size The size.
        @return
                    The serialized JSON.
            
        */
        static toJson(size: fm.liveswitch.Size): string;
        /**
        Gets the height.
        */
        getHeight(): number;
        /**
        Gets the width.
        */
        getWidth(): number;
        /**
        Determines whether the specified size is equivalent.
        @param size The size.
        */
        isEquivalent(size: fm.liveswitch.Size): boolean;
        /**
        Sets the height.
        */
        setHeight(value: number): void;
        /**
        Sets the width.
        */
        setWidth(value: number): void;
        /**
        Serializes this instance to JSON.
        @return
                    The serialized JSON.
            
        */
        toJson(): string;
        /**
        Returns a string that represents this instance using format "{width}x{height}".
        */
        toString(): string;
    }
}
declare namespace fm.liveswitch {
    class StreamDirectionWrapper {
        getTypeString(): string;
        /** @hidden */
        private _value;
        constructor(value: fm.liveswitch.StreamDirection);
        toString(): string;
    }
}
declare namespace fm.liveswitch {
    /**
    Class containing utility methods to manipulate [[fm.liveswitch.streamDirection]].
    */
    class StreamDirectionHelper {
        getTypeString(): string;
        constructor();
        /**
        Converts string representations of stream directions to [[fm.liveswitch.streamDirection]].
        @param directionString The direction string.
        @return The direction.
        */
        static directionFromString(directionString: string): fm.liveswitch.StreamDirection;
        /**
        Obtains the string representation of [[fm.liveswitch.streamDirection]].
        @param direction The direction.
        @return The direction string.
        */
        static directionToString(direction: fm.liveswitch.StreamDirection): string;
        /**
        Checks the receive flag.
        @param direction The direction.
        @return The receive flag.
        */
        static isReceiveDisabled(direction: fm.liveswitch.StreamDirection): boolean;
        /**
        Checks the receive flag.
        @param directionString The direction string.
        @return The receive flag.
        */
        static isReceiveDisabled(directionString: string): boolean;
        /**
        Checks the send flag.
        @param direction The direction.
        @return The send flag.
        */
        static isSendDisabled(direction: fm.liveswitch.StreamDirection): boolean;
        /**
        Checks the send flag.
        @param directionString The direction string.
        @return The send flag.
        */
        static isSendDisabled(directionString: string): boolean;
        /**
        Sets the receive flag.
        @param direction The direction.
        @param disabled Whether to disable the receive flag.
        @return The new direction.
        */
        static setReceiveDisabled(direction: fm.liveswitch.StreamDirection, disabled: boolean): fm.liveswitch.StreamDirection;
        /**
        Sets the receive flag.
        @param directionString The direction string.
        @param disabled Whether to disable the receive flag.
        @return The new direction.
        */
        static setReceiveDisabled(directionString: string, disabled: boolean): string;
        /**
        Sets the send flag.
        @param direction The direction.
        @param disabled Whether to disable the send flag.
        @return The new direction.
        */
        static setSendDisabled(direction: fm.liveswitch.StreamDirection, disabled: boolean): fm.liveswitch.StreamDirection;
        /**
        Sets the send flag.
        @param directionString The direction string.
        @param disabled Whether to disable the send flag.
        @return The new direction.
        */
        static setSendDisabled(directionString: string, disabled: boolean): string;
        /**
        Toggles the receive flag.
        @param direction The direction.
        @return The new direction.
        */
        static toggleReceive(direction: fm.liveswitch.StreamDirection): fm.liveswitch.StreamDirection;
        /**
        Toggles the receive flag.
        @param directionString The direction string.
        @return The new direction.
        */
        static toggleReceive(directionString: string): string;
        /**
        Toggles the send flag.
        @param direction The direction.
        @return The new direction.
        */
        static toggleSend(direction: fm.liveswitch.StreamDirection): fm.liveswitch.StreamDirection;
        /**
        Toggles the send flag.
        @param directionString The direction string.
        @return The new direction.
        */
        static toggleSend(directionString: string): string;
    }
}
declare namespace fm.liveswitch {
    class StreamStateWrapper {
        getTypeString(): string;
        /** @hidden */
        private _value;
        constructor(value: fm.liveswitch.StreamState);
        toString(): string;
    }
}
declare namespace fm.liveswitch {
    class StreamTypeWrapper {
        getTypeString(): string;
        /** @hidden */
        private _value;
        constructor(value: fm.liveswitch.StreamType);
        toString(): string;
    }
}
declare namespace fm.liveswitch {
    /**
    Transport Information.
    */
    class TransportInfo extends fm.liveswitch.Info {
        getTypeString(): string;
        /** @hidden */
        private _activeCandidatePairId;
        /** @hidden */
        private _candidatePairs;
        /** @hidden */
        private _localCandidates;
        /** @hidden */
        private _localCertificate;
        /** @hidden */
        private _remoteCandidates;
        /** @hidden */
        private _remoteCertificate;
        /** @hidden */
        private _report;
        /**
        Initializes a new instance of the [[fm.liveswitch.transportInfo]] class.
        */
        constructor();
        constructor(stats: fm.liveswitch.TransportStats, lastStats: fm.liveswitch.TransportStats);
        /**
        Deserializes Json to a TransportReport.
        @param transportReportJson The serialized Json.
        @return The deserialized TransportReport.
        */
        static fromJson(transportReportJson: string): fm.liveswitch.TransportInfo;
        /**
        Deserializes an array from JSON.
        @param transportInfosJson The serialized JSON.
        @return The deserialized array.
        */
        static fromJsonArray(transportInfosJson: string): fm.liveswitch.TransportInfo[];
        /**
        Serializes an instance to Json.
        @param transportReport The instance to serialize.
        @return Serialized Json.
        */
        static toJson(transportReport: fm.liveswitch.TransportInfo): string;
        /**
        Serializes an array to JSON.
        @param transportInfos The array to serialize.
        @return The serialized JSON.
        */
        static toJsonArray(transportInfos: fm.liveswitch.TransportInfo[]): string;
        /**
        Deserializes the properties.
        @param key The key.
        @param valueJson The value in JSON format.
        */
        protected deserializeProperties(key: string, valueJson: string): void;
        /** @hidden */
        private findMatchingCandidate;
        /** @hidden */
        private findMatchingCandidatePair;
        /**
        Gets the active candidate pair identifier.
        */
        getActiveCandidatePairId(): string;
        /**
        Gets the candidate pairs.
        */
        getCandidatePairs(): fm.liveswitch.CandidatePairInfo[];
        /**
        Gets the local candidates.
        */
        getLocalCandidates(): fm.liveswitch.CandidateInfo[];
        /**
        Gets the local certificate.
        */
        getLocalCertificate(): fm.liveswitch.CertificateInfo;
        /**
        Gets the remote candidates.
        */
        getRemoteCandidates(): fm.liveswitch.CandidateInfo[];
        /**
        Gets the remote certificate.
        */
        getRemoteCertificate(): fm.liveswitch.CertificateInfo;
        /**
        Gets the transport report.
        */
        getReport(): fm.liveswitch.TransportReport;
        /**
        Serializes the properties.
        @param jsonObject The JSON object.
        */
        protected serializeProperties(jsonObject: fm.liveswitch.Hash<string, string>): void;
        /**
        Sets the active candidate pair identifier.
        */
        setActiveCandidatePairId(value: string): void;
        /**
        Sets the candidate pairs.
        */
        setCandidatePairs(value: fm.liveswitch.CandidatePairInfo[]): void;
        /**
        Sets the local candidates.
        */
        setLocalCandidates(value: fm.liveswitch.CandidateInfo[]): void;
        /**
        Sets the local certificate.
        */
        setLocalCertificate(value: fm.liveswitch.CertificateInfo): void;
        /**
        Sets the remote candidates.
        */
        setRemoteCandidates(value: fm.liveswitch.CandidateInfo[]): void;
        /**
        Sets the remote certificate.
        */
        setRemoteCertificate(value: fm.liveswitch.CertificateInfo): void;
        /**
        Sets the transport report.
        */
        setReport(value: fm.liveswitch.TransportReport): void;
        /**
        Serializes this instance to Json.
        */
        toJson(): string;
    }
}
declare namespace fm.liveswitch {
    /**
    Transport stats.
    */
    class TransportStats extends fm.liveswitch.BaseStats {
        getTypeString(): string;
        /** @hidden */
        private _activeCandidatePair;
        /** @hidden */
        private _bytesReceived;
        /** @hidden */
        private _bytesSent;
        /** @hidden */
        private _candidatePairs;
        /** @hidden */
        private _localCandidates;
        /** @hidden */
        private _localCertificate;
        /** @hidden */
        private _remoteCandidates;
        /** @hidden */
        private _remoteCertificate;
        /** @hidden */
        private _rtcpTransport;
        private fmliveswitchTransportStatsInit;
        constructor();
        /**
        Derializes transport stats from JSON.
        @param transportJson The transport's stats JSON.
        */
        static fromJson(transportJson: string): fm.liveswitch.TransportStats;
        /**
        Serializes transport stats to JSON.
        @param transport The transport's stats.
        */
        static toJson(transport: fm.liveswitch.TransportStats): string;
        /**
        Deserializes the properties.
        @param key The key.
        @param valueJson The value in JSON format.
        */
        protected deserializeProperties(key: string, valueJson: string): void;
        /**
        Gets the active candidate pair's stats.
        */
        getActiveCandidatePair(): fm.liveswitch.CandidatePairStats;
        /**
        Gets the number of bytes received.
        */
        getBytesReceived(): number;
        /**
        Gets the number of bytes sent.
        */
        getBytesSent(): number;
        /**
        Gets a candidate pair by its identifier.
        @param candidatePairId The candidate pair identifier.
        */
        getCandidatePair(candidatePairId: string): fm.liveswitch.CandidatePairStats;
        /**
        Gets the candidate pairs' stats.
        */
        getCandidatePairs(): fm.liveswitch.CandidatePairStats[];
        /**
        Gets whether the active candidate pair has a host candidate.
        */
        getIsHost(): boolean;
        /**
        Gets whether the active candidate pair has a reflexive candidate.
        */
        getIsReflexive(): boolean;
        /**
        Gets whether the active candidate pair has a relayed candidate.
        */
        getIsRelayed(): boolean;
        /**
        Gets a local candidate by its identifier.
        @param candidateId The candidate identifier.
        */
        getLocalCandidate(candidateId: string): fm.liveswitch.CandidateStats;
        /**
        Gets the local candidates' stats.
        */
        getLocalCandidates(): fm.liveswitch.CandidateStats[];
        /**
        Gets the local certificate's stats.
        */
        getLocalCertificate(): fm.liveswitch.CertificateStats;
        /**
        Gets a remote candidate by its identifier.
        @param candidateId The candidate identifier.
        */
        getRemoteCandidate(candidateId: string): fm.liveswitch.CandidateStats;
        /**
        Gets the remote candidates' stats.
        */
        getRemoteCandidates(): fm.liveswitch.CandidateStats[];
        /**
        Gets the remote certificate's stats.
        */
        getRemoteCertificate(): fm.liveswitch.CertificateStats;
        /**
        Gets the RTCP transport's stats.
        */
        getRtcpTransport(): fm.liveswitch.TransportStats;
        /**
        Serializes the properties.
        @param jsonObject The JSON object.
        */
        protected serializeProperties(jsonObject: fm.liveswitch.Hash<string, string>): void;
        /**
        Sets the active candidate pair's stats.
        */
        setActiveCandidatePair(value: fm.liveswitch.CandidatePairStats): void;
        /**
        Sets the number of bytes received.
        */
        setBytesReceived(value: number): void;
        /**
        Sets the number of bytes sent.
        */
        setBytesSent(value: number): void;
        /**
        Sets the candidate pairs' stats.
        */
        setCandidatePairs(value: fm.liveswitch.CandidatePairStats[]): void;
        /**
        Sets the local candidates' stats.
        */
        setLocalCandidates(value: fm.liveswitch.CandidateStats[]): void;
        /**
        Sets the local certificate's stats.
        */
        setLocalCertificate(value: fm.liveswitch.CertificateStats): void;
        /**
        Sets the remote candidates' stats.
        */
        setRemoteCandidates(value: fm.liveswitch.CandidateStats[]): void;
        /**
        Sets the remote certificate's stats.
        */
        setRemoteCertificate(value: fm.liveswitch.CertificateStats): void;
        /**
        Sets the RTCP transport's stats.
        */
        setRtcpTransport(value: fm.liveswitch.TransportStats): void;
        /**
        Serializes this to JSON.
        */
        toJson(): string;
    }
}
declare namespace fm.liveswitch {
    /**
    Utility methods.
    */
    class Utility {
        getTypeString(): string;
        constructor();
        /**
        Clones the specified list.
        @param list The list.
        */
        static clone<T>(list: Array<T>): Array<T>;
        /**
        Clones an array of int values.
        @param intArray An array of int values.
        */
        static cloneIntArray(intArray: number[]): number[];
        /**
        Clones an array of long values.
        @param longArray An array of long values.
        */
        static cloneLongArray(longArray: number[]): number[];
        /**
        Clones an array of string values.
        @param stringArray An array of string values.
        */
        static cloneStringArray(stringArray: string[]): string[];
        /**
        Gets the first element in the array or the default value if the array is null or empty.
        @param array The array.
        */
        static firstOrDefault<T>(array: T[]): T;
        /**
        Gets the first element in the list or the default value if the list is null or empty.
        @param list The list.
        */
        static firstOrDefault<T>(list: Array<T>): T;
        /**
        Formats a double as a percentage string.
        @param value The value.
        @param decimalPlaces The number of decimal places to include.
        */
        static formatDoubleAsPercent(value: number, decimalPlaces: number): string;
        /**
        Generates a unique identifier.
        */
        static generateId(): string;
        /**
        Generates a synchronization source.
        */
        static generateSynchronizationSource(): number;
        /**
        Generates a tie-breaker. Obsolete. Alias for [[fm.liveswitch.utility.generateId]].
        */
        static generateTieBreaker(): string;
        /**
        Retrieves the difference between two RTP sequence numbers while accounting for overflow rollover.
        @param rtpSequenceNumber The current RTP sequence number.
        @param lastRtpSequenceNumber The last (previous) RTP sequence number.
        @return The difference between the two RTP sequence numbers.
        */
        static getRtpSequenceNumberDelta(rtpSequenceNumber: number, lastRtpSequenceNumber: number): number;
        /**
        Retrieves the difference between two RTP timestamps while accounting for overflow rollover.
        @param rtpTimestamp The current RTP timestamp.
        @param lastRtpTimestamp The last (previous) RTP timestamp.
        @return The difference between the two RTP timestamps.
        */
        static getRtpTimestampDelta(rtpTimestamp: number, lastRtpTimestamp: number): number;
        /**
        Gets the last element in the array or the default value if the array is null or empty.
        @param array The array.
        */
        static lastOrDefault<T>(array: T[]): T;
        /**
        Gets the last element in the list or the default value if the list is null or empty.
        @param list The list.
        */
        static lastOrDefault<T>(list: Array<T>): T;
        /**
        Compares two nullable longs for equality.
        @param long1 The first long value.
        @param long2 The second long value.
        */
        static nullableLongEquals(long1: number, long2: number): boolean;
        /**
        Gets the only element in the array or the default value if the array is null or does not have exactly one value.
        @param array The array.
        */
        static singleOrDefault<T>(array: T[]): T;
        /**
        Gets the only element in the list or the default value if the list is null or does not have exactly one value.
        @param list The list.
        */
        static singleOrDefault<T>(list: Array<T>): T;
        /**
        Splices an array.
        @param array The array.
        @param index The splice index.
        @param addItems The items to add.
        @param createArray A function that creates an array of the given size.
        */
        static splice<T>(array: T[], index: number, addItems: T[], createArray: fm.liveswitch.IFunction1<number, T[]>): T[];
        /**
        Splices an array.
        @param array The array.
        @param index The splice index.
        @param removeCount The number of items to remove.
        @param addItems The items to add.
        @param createArray A function that creates an array of the given size.
        */
        static splice<T>(array: T[], index: number, removeCount: number, addItems: T[], createArray: fm.liveswitch.IFunction1<number, T[]>): T[];
        /**
        Splices an array.
        @param array The array.
        @param index The splice index.
        @param removeCount The number of items to remove.
        @param createArray A function that creates an array of the given size.
        */
        static splice<T>(array: T[], index: number, removeCount: number, createArray: fm.liveswitch.IFunction1<number, T[]>): T[];
        /**
        Converts a list of int values to an array of int values.
        @param intList A list of int values.
        */
        static toIntArray(intList: Array<number>): number[];
        /**
        Converts an array to a list.
        @param array The array.
        */
        static toList<T>(array: T[]): Array<T>;
        /**
        Converts a list of long values to an array of long values.
        @param longList A list of long values.
        */
        static toLongArray(longList: Array<number>): number[];
        /**
        Converts a list of string values to an array of string values.
        @param stringList A list of string values.
        */
        static toStringArray(stringList: Array<string>): string[];
        /**
        Enumerates over all nodes in the tree, invoking the callback for each one.
        @param root The root.
        @param childrenCallback The children callback.
        @param nodeCallback The node callback.
        */
        static treeFindLeaves<T>(root: T, childrenCallback: fm.liveswitch.IFunction1<T, T[]>, nodeCallback: fm.liveswitch.IAction1<T>): void;
        /**
        Enumerates over all nodes in the tree, invoking the callback for each one.
        @param root The root.
        @param childrenCallback The children callback.
        @param nodeCallback The node callback.
        */
        static treeSearch<T>(root: T, childrenCallback: fm.liveswitch.IFunction1<T, T[]>, nodeCallback: fm.liveswitch.IAction1<T>): void;
    }
}
declare namespace fm.liveswitch {
    /**
    A screen configuration.
    */
    class ScreenConfig extends fm.liveswitch.MediaConfig<fm.liveswitch.ScreenConfig> {
        getTypeString(): string;
        /** @hidden */
        private __frameRate;
        /** @hidden */
        private __region;
        private fmliveswitchScreenConfigInit;
        /**
        Initializes a new instance of the [[fm.liveswitch.screenConfig]] class.
        @param origin The region origin.
        @param size The region size.
        @param frameRate The frame rate.
        */
        constructor(origin: fm.liveswitch.Point, size: fm.liveswitch.Size, frameRate: number);
        /**
        Initializes a new instance of the [[fm.liveswitch.screenConfig]] class.
        @param origin The region origin.
        @param size The region size.
        @param frameRate The frame rate.
        @param clockRate The clock rate.
        */
        constructor(origin: fm.liveswitch.Point, size: fm.liveswitch.Size, frameRate: number, clockRate: number);
        /**
        Initializes a new instance of the [[fm.liveswitch.screenConfig]] class.
        @param region The region.
        @param frameRate The frame rate.
        */
        constructor(region: fm.liveswitch.Rectangle, frameRate: number);
        /**
        Initializes a new instance of the [[fm.liveswitch.screenConfig]] class.
        @param region The region.
        @param frameRate The frame rate.
        @param clockRate The clock rate.
        */
        constructor(region: fm.liveswitch.Rectangle, frameRate: number, clockRate: number);
        /**
        Initializes a new instance of the [[fm.liveswitch.screenConfig]] class.
        @param x The region origin X coordinate.
        @param y The region origin Y coordinate.
        @param width The region size width.
        @param height The region size height.
        @param frameRate The frame rate.
        */
        constructor(x: number, y: number, width: number, height: number, frameRate: number);
        /**
        Initializes a new instance of the [[fm.liveswitch.screenConfig]] class.
        @param x The region origin X coordinate.
        @param y The region origin Y coordinate.
        @param width The region size width.
        @param height The region size height.
        @param frameRate The frame rate.
        @param clockRate The clock rate.
        */
        constructor(x: number, y: number, width: number, height: number, frameRate: number, clockRate: number);
        /**
        Gets the frame-rate.
        */
        getFrameRate(): number;
        /**
        Gets the region size height.
        */
        getHeight(): number;
        /**
        Gets the region origin.
        */
        getOrigin(): fm.liveswitch.Point;
        /**
        Gets the region.
        */
        getRegion(): fm.liveswitch.Rectangle;
        /**
        Gets the region size.
        */
        getSize(): fm.liveswitch.Size;
        /**
        Gets the region size width.
        */
        getWidth(): number;
        /**
        Gets the region origin X coordinate.
        */
        getX(): number;
        /**
        Gets the region origin Y coordinate.
        */
        getY(): number;
        /**
        Determines whether the specified configuration is equivalent.
        @param config The configuration.
        */
        isEquivalent(config: fm.liveswitch.ScreenConfig): boolean;
        /**
        Sets the frame-rate.
        */
        setFrameRate(value: number): void;
        /**
        Sets the region origin.
        */
        setOrigin(value: fm.liveswitch.Point): void;
        /**
        Sets the region.
        */
        setRegion(value: fm.liveswitch.Rectangle): void;
        /**
        Sets the region size.
        */
        setSize(value: fm.liveswitch.Size): void;
        /**
        Returns a string that represents this instance.
        */
        toString(): string;
    }
}
declare namespace fm.liveswitch {
    /**
    A video configuration.
    */
    class VideoConfig extends fm.liveswitch.MediaConfig<fm.liveswitch.VideoConfig> {
        getTypeString(): string;
        /** @hidden */
        private __frameRate;
        /** @hidden */
        private __size;
        private fmliveswitchVideoConfigInit;
        /**
        Initializes a new instance of the [[fm.liveswitch.videoConfig]] class.
        @param size The size.
        @param frameRate The frame rate.
        */
        constructor(size: fm.liveswitch.Size, frameRate: number);
        /**
        Initializes a new instance of the [[fm.liveswitch.videoConfig]] class.
        @param size The size.
        @param frameRate The frame rate.
        @param clockRate The clock rate.
        */
        constructor(size: fm.liveswitch.Size, frameRate: number, clockRate: number);
        /**
        Initializes a new instance of the [[fm.liveswitch.videoConfig]] class.
        @param width The width.
        @param height The height.
        @param frameRate The frame rate.
        */
        constructor(width: number, height: number, frameRate: number);
        /**
        Initializes a new instance of the [[fm.liveswitch.videoConfig]] class.
        @param width The width.
        @param height The height.
        @param frameRate The frame rate.
        @param clockRate The clock rate.
        */
        constructor(width: number, height: number, frameRate: number, clockRate: number);
        /**
        Gets the frame duration in milliseconds.
        */
        getFrameDuration(): number;
        /**
        Gets the frame-rate.
        */
        getFrameRate(): number;
        /**
        Gets the size height.
        */
        getHeight(): number;
        /**
        Gets the size.
        */
        getSize(): fm.liveswitch.Size;
        /**
        Gets the size width.
        */
        getWidth(): number;
        /**
        Determines whether the specified configuration is equivalent.
        @param config The configuration.
        */
        isEquivalent(config: fm.liveswitch.VideoConfig): boolean;
        /**
        Sets the frame-rate.
        */
        setFrameRate(value: number): void;
        /**
        Sets the size.
        */
        setSize(value: fm.liveswitch.Size): void;
        /**
        Returns a string that represents this instance.
        */
        toString(): string;
    }
}
declare namespace fm.liveswitch {
    /**
    A media buffer.
    */
    abstract class MediaBuffer<TFormat extends fm.liveswitch.MediaFormat<TFormat>, TBuffer extends fm.liveswitch.MediaBuffer<TFormat, TBuffer>> extends fm.liveswitch.Dynamic {
        getTypeString(): string;
        /** @hidden */
        private __dataBuffers;
        /** @hidden */
        private __format;
        /** @hidden */
        private _recoveredByFec;
        /** @hidden */
        private _rtpHeaders;
        /** @hidden */
        private _sequenceNumbers;
        /** @hidden */
        private _sourceId;
        private fmliveswitchMediaBufferInit;
        /**
        Initializes a new instance of the [[fm.liveswitch.mediaBuffer]] class.
        */
        constructor();
        /**
        Initializes a new instance of the [[fm.liveswitch.mediaBuffer]] class.
        @param dataBuffer The data buffer.
        @param format The format.
        */
        constructor(dataBuffer: fm.liveswitch.DataBuffer, format: TFormat);
        /**
        Initializes a new instance of the [[fm.liveswitch.mediaBuffer]] class.
        @param dataBuffers The data buffers.
        @param format The format.
        */
        constructor(dataBuffers: fm.liveswitch.DataBuffer[], format: TFormat);
        /**
        Clones this instance.
        */
        clone(): TBuffer;
        /**
        Creates a new instance.
        */
        protected abstract createInstance(): TBuffer;
        /**
        Frees the data buffers referenced by this instance.
        @return This instance.
        */
        free(): TBuffer;
        /**
        Gets the data buffer.
        */
        getDataBuffer(): fm.liveswitch.DataBuffer;
        /**
        Gets the data buffers.
        */
        getDataBuffers(): fm.liveswitch.DataBuffer[];
        /**
        Gets the approximate footprint of this media buffer by returning the sum of its data buffer lengths.
        */
        getFootprint(): number;
        /**
        Gets the format.
        */
        getFormat(): TFormat;
        /**
        Gets a value indicating whether this instance has been muted.
        */
        abstract getIsMuted(): boolean;
        /** @hidden */
        getIsPacketized(): boolean;
        /**
        Gets the last sequence number.
        */
        getLastSequenceNumber(): number;
        /**
        Gets a value indicating whether this buffer contains data recovered by forward error correction (FEC).
        */
        getRecoveredByFec(): boolean;
        /**
        Gets the Rtp Packet Header for this media buffer.
        */
        getRtpHeader(): fm.liveswitch.RtpPacketHeader;
        /**
        Gets the RTP Packet Headers for this media buffer.
        */
        getRtpHeaders(): fm.liveswitch.RtpPacketHeader[];
        /**
        Gets the RTP sequence number.
        */
        getRtpSequenceNumber(): number;
        /**
        Gets the RTP sequence numbers.
        */
        getRtpSequenceNumbers(): number[];
        /**
        Gets the sequence number.
        */
        getSequenceNumber(): number;
        /**
        Gets the sequence numbers.
        */
        getSequenceNumbers(): number[];
        /**
        Gets the source identifier.
        */
        getSourceId(): string;
        /**
        Keeps the data buffers referenced by this instance.
        @return This instance.
        */
        keep(): TBuffer;
        /**
        Mutes this instance. This is a one-way operation that clears the underlying data buffer. If the buffer has an unsupported format, this method will return `false`.
        */
        abstract mute(): boolean;
        /**
        Sets the data buffer.
        */
        setDataBuffer(value: fm.liveswitch.DataBuffer): void;
        /**
        Sets the data buffers.
        */
        setDataBuffers(value: fm.liveswitch.DataBuffer[]): void;
        /**
        Sets the format.
        */
        setFormat(value: TFormat): void;
        /**
        Sets a value indicating whether this buffer contains data recovered by forward error correction (FEC).
        */
        setRecoveredByFec(value: boolean): void;
        /**
        Sets the Rtp Packet Header for this media buffer.
        */
        setRtpHeader(value: fm.liveswitch.RtpPacketHeader): void;
        /**
        Sets the RTP Packet Headers for this media buffer.
        */
        setRtpHeaders(value: fm.liveswitch.RtpPacketHeader[]): void;
        /**
        Sets the sequence number.
        */
        setSequenceNumber(value: number): void;
        /**
        Sets the sequence numbers.
        */
        setSequenceNumbers(value: number[]): void;
        /**
        Sets the source identifier.
        */
        setSourceId(value: string): void;
        /**
        Returns a string that represents this instance.
        */
        toString(): string;
        /**
        Attempts to keep the data buffers referenced by this instance.
        @return True if succeeded.
        */
        tryKeep(): boolean;
    }
}
declare namespace fm.liveswitch {
    /**
    A media format.
    */
    abstract class MediaFormat<TFormat extends fm.liveswitch.MediaFormat<TFormat>> {
        getTypeString(): string;
        /** @hidden */
        private __name;
        /** @hidden */
        private __packetizationMode;
        /** @hidden */
        private _clockRate;
        /** @hidden */
        private _isEncrypted;
        /** @hidden */
        private _isFixedBitrate;
        /** @hidden */
        private _isInjected;
        /** @hidden */
        private _isPacketized;
        /** @hidden */
        private _level;
        /** @hidden */
        private _levelIsStrict;
        /** @hidden */
        private _profile;
        /** @hidden */
        private _registeredPayloadType;
        /** @hidden */
        private _staticPayloadType;
        /** @hidden */
        private _tier;
        private fmliveswitchMediaFormatInit;
        /**
        Initializes a new instance of the [[fm.liveswitch.mediaFormat]] class.
        */
        constructor();
        /**
        Initializes a new instance of the [[fm.liveswitch.mediaFormat]] class.
        @param name The name.
        @param clockRate The clock rate.
        */
        constructor(name: string, clockRate: number);
        /**
        Initializes a new instance of the [[fm.liveswitch.mediaFormat]] class.
        @param name The name.
        @param clockRate The clock rate.
        @param packetizationMode The packetization mode.
        */
        constructor(name: string, clockRate: number, packetizationMode: string);
        /**
        Initializes a new instance of the [[fm.liveswitch.mediaFormat]] class.
        @param name The name.
        @param clockRate The clock rate.
        @param level The media format level.
        @param profile The media format profile.
        */
        constructor(name: string, clockRate: number, profile: string, level: string);
        /**
        Initializes a new instance of the [[fm.liveswitch.mediaFormat]] class.
        @param name The name.
        @param clockRate The clock rate.
        @param level The media format level
        @param profile The media format profile
        @param packetizationMode The packetization mode.
        */
        constructor(name: string, clockRate: number, profile: string, level: string, packetizationMode: string);
        /**
        Initializes a new instance of the [[fm.liveswitch.mediaFormat]] class.
        @param name The name.
        @param clockRate The clock rate.
        @param level The media format level
        @param profile The media format profile
        @param packetizationMode The packetization mode.
        @param tier The media format tier.
        */
        constructor(name: string, clockRate: number, profile: string, level: string, packetizationMode: string, tier: string);
        /**
        Gets the name of the RED media format.
        */
        static getRedName(): string;
        /**
        Gets the name of the ULPFEC media format.
        */
        static getUlpFecName(): string;
        /**
        Clones this instance.
        */
        clone(): TFormat;
        /**
        Creates a new instance.
        */
        protected abstract createInstance(): TFormat;
        /**
        Gets the clock rate.
        */
        getClockRate(): number;
        /**
        Gets the full name, including clock rate and encoding parameters.
        */
        getFullName(): string;
        /**
        Gets this format as an info object.
        */
        abstract getInfo(): fm.liveswitch.FormatInfo;
        /**
        Gets whether this is a compressed format.
        */
        abstract getIsCompressed(): boolean;
        /**
        Gets a value indicating that the data is encrypted.
        */
        getIsEncrypted(): boolean;
        /**
        Gets a value indicating whether a format only supports fixed bitrate.
        */
        getIsFixedBitrate(): boolean;
        /**
        Gets a value indicating that the data is injected into the primary media stream (e.g. DTMF).
        */
        getIsInjected(): boolean;
        /**
        Gets a value indicating whether the data is packetized.
        */
        getIsPacketized(): boolean;
        /**
        Gets the level.
        */
        getLevel(): string;
        /**
        Gets a value indicating whether the level is strict.
        */
        getLevelIsStrict(): boolean;
        /**
        Gets the maximum bitrate supported by this format, in kbps.
        */
        getMaxBitrate(): number;
        /**
        Gets the maximum level.
        @param level1 The first level.
        @param level2 The second level.
        @return The maximum level.
        */
        protected getMaxLevel(level1: string, level2: string): string;
        /**
        Gets the minimum bitrate supported by this format, in kbps.
        */
        getMinBitrate(): number;
        /**
        Gets the minimum level.
        @param level1 The first level.
        @param level2 The second level.
        @return The minimum level.
        */
        protected getMinLevel(level1: string, level2: string): string;
        /**
        Gets the name.
        */
        getName(): string;
        /**
        Gets the packetization mode.
        */
        getPacketizationMode(): string;
        /**
        Gets the parameters.
        */
        abstract getParameters(): string;
        /**
        Gets the profile.
        */
        getProfile(): string;
        /** @hidden */
        getRegisteredPayloadType(): number;
        /**
        Gets the static payload type, if this format has a static payload type registered with IANA.
        */
        getStaticPayloadType(): number;
        /**
        Gets the tier.
        */
        getTier(): string;
        /** @hidden */
        private initialize;
        /**
        Determines whether the specified format is compatible.
        @param format The format.
        */
        isCompatible(format: TFormat): boolean;
        /**
        Determines whether the specified format is equivalent.
        @param format The format.
        @param ignoreIsPacketized Whether to ignore if the two formats differ in whether they are packetized.
        */
        isEquivalent(format: TFormat, ignoreIsPacketized: boolean): boolean;
        /**
        Gets whether a level is compatible.
        @param level The level.
        */
        protected isLevelCompatible(level: string): boolean;
        /**
        Gets whether a profile is compatible.
        @param profile The profile.
        */
        protected isProfileCompatible(profile: string): boolean;
        /**
        Sets the clock rate.
        */
        setClockRate(value: number): void;
        /**
        Sets a value indicating that the data is encrypted.
        */
        setIsEncrypted(value: boolean): void;
        /**
        Sets a value indicating whether a format only supports fixed bitrate.
        */
        protected setIsFixedBitrate(value: boolean): void;
        /**
        Sets a value indicating that the data is injected into the primary media stream (e.g. DTMF).
        */
        setIsInjected(value: boolean): void;
        /**
        Sets a value indicating whether the data is packetized.
        */
        setIsPacketized(value: boolean): void;
        /**
        Sets the level.
        */
        setLevel(value: string): void;
        /**
        Sets a value indicating whether the level is strict.
        */
        setLevelIsStrict(value: boolean): void;
        /**
        Sets the name.
        */
        setName(value: string): void;
        /**
        Sets the packetization mode.
        */
        setPacketizationMode(value: string): void;
        /**
        Sets the profile.
        */
        setProfile(value: string): void;
        /** @hidden */
        setRegisteredPayloadType(value: number): void;
        /**
        Sets the static payload type, if this format has a static payload type registered with IANA.
        */
        protected setStaticPayloadType(value: number): void;
        /**
        Sets the tier.
        */
        setTier(value: string): void;
        /**
        Returns a string that represents this instance.
        */
        toString(): string;
        /**
        Updates the level-is-strict flag to a compatible value.
        @param format The format.
        */
        protected updateLevelIsStrictToCompatible(format: TFormat): void;
        /**
        Updates the level to a compatible value.
        @param format The format.
        */
        protected updateLevelToCompatible(format: TFormat): void;
        /**
        Updates the profile to a compatible value.
        @param format The format.
        */
        protected updateProfileToCompatible(format: TFormat): void;
        /**
        Updates the tier to a compatible value.
        @param format The format.
        */
        protected updateTierToCompatible(format: TFormat): void;
        /** @hidden */
        updateToCompatible(format: TFormat): void;
    }
}
declare namespace fm.liveswitch {
    /**
    An audio format.
    */
    class AudioFormat extends fm.liveswitch.MediaFormat<fm.liveswitch.AudioFormat> {
        getTypeString(): string;
        /** @hidden */
        private _channelCount;
        /** @hidden */
        private _littleEndian;
        private fmliveswitchAudioFormatInit;
        /**
        Initializes a new instance of the [[fm.liveswitch.audioFormat]] class.
        */
        constructor();
        /**
        Initializes a new instance of the [[fm.liveswitch.audioFormat]] class.
        @param name The name.
        @param clockRate The clock rate.
        @param channelCount The channel count.
        */
        constructor(name: string, clockRate: number, channelCount: number);
        /**
        Initializes a new instance of the [[fm.liveswitch.audioFormat]] class.
        @param name The name.
        @param config The configuration.
        */
        constructor(name: string, config: fm.liveswitch.AudioConfig);
        /**
        Transforms a FormatInfo into an AudioFormat.
        @param info The format info.
        */
        static fromFormatInfo(info: fm.liveswitch.FormatInfo): fm.liveswitch.AudioFormat;
        /**
        Deserializes an instance from JSON.
        @param audioFormatJson The audio format JSON.
        */
        static fromJson(audioFormatJson: string): fm.liveswitch.AudioFormat;
        /**
        Gets the name of the DTMF audio format ("telephone-event").
        */
        static getDtmfName(): string;
        /**
        Gets the name of the G.722 audio format ("G722").
        */
        static getG722Name(): string;
        /**
        Gets the name of the Linear PCM 16-bit audio (PCM Uncompressed).
        */
        static getL16Name(): string;
        /**
        Gets the name of the Opus audio format ("opus").
        */
        static getOpusName(): string;
        /**
        Gets the name of the PCMA audio format ("PCMA").
        */
        static getPcmaName(): string;
        /**
        Gets the name of the PCM audio format ("PCM").
        */
        static getPcmName(): string;
        /**
        Gets the name of the PCMU audio format ("PCMU").
        */
        static getPcmuName(): string;
        /**
        Serializes an instance to JSON.
        @param audioFormat The audio format.
        */
        static toJson(audioFormat: fm.liveswitch.AudioFormat): string;
        /**
        Clones this instance.
        */
        clone(): fm.liveswitch.AudioFormat;
        /**
        Creates a new instance.
        */
        protected createInstance(): fm.liveswitch.AudioFormat;
        /**
        Gets the channel count.
        */
        getChannelCount(): number;
        /**
        Gets the clock rate and channel count as a configuration.
        */
        getConfig(): fm.liveswitch.AudioConfig;
        /**
        Gets this format as an info object.
        */
        getInfo(): fm.liveswitch.FormatInfo;
        /**
        Gets whether this is a compressed format.
        */
        getIsCompressed(): boolean;
        /**
        Gets a value indicating whether this format is DTMF.
        */
        getIsDtmf(): boolean;
        /**
        Gets a value indicating whether this format is G.722.
        */
        getIsG722(): boolean;
        /**
        Gets a value indicating whether this format is L16.
        */
        getIsL16(): boolean;
        /**
        Gets a value indicating whether this format is Opus.
        */
        getIsOpus(): boolean;
        /**
        Gets a value indicating whether this format is PCM.
        */
        getIsPcm(): boolean;
        /**
        Gets a value indicating whether this format is PCMA.
        */
        getIsPcma(): boolean;
        /**
        Gets a value indicating whether this format is PCMU.
        */
        getIsPcmu(): boolean;
        /**
        Gets whether the format uses little endian byte order.
        */
        getLittleEndian(): boolean;
        /**
        Gets the parameters.
        */
        getParameters(): string;
        /**
        Determines whether the specified format is compatible.
        @param format The format.
        */
        isCompatible(format: fm.liveswitch.AudioFormat): boolean;
        /**
        Determines whether the specified format is equivalent.
        @param format The format.
        @param ignoreIsPacketized Whether to ignore if the two formats differ in whether they are packetized.
        */
        isEquivalent(format: fm.liveswitch.AudioFormat, ignoreIsPacketized: boolean): boolean;
        /**
        Sets the channel count.
        */
        setChannelCount(value: number): void;
        /**
        Sets whether the format uses little endian byte order.
        */
        setLittleEndian(value: boolean): void;
        /**
        Serializes this instance to JSON.
        */
        toJson(): string;
    }
}
declare namespace fm.liveswitch {
    /**
    Media sink base properties/methods.
    */
    abstract class MediaSinkBase extends fm.liveswitch.Dynamic {
        getTypeString(): string;
        /** @hidden */
        private __id;
        /** @hidden */
        private _externalId;
        /** @hidden */
        private _tag;
        constructor();
        /**
        Gets the external identifier.
        */
        getExternalId(): string;
        /**
        Gets the identifier.
        */
        getId(): string;
        /**
        Gets optional data to associate with this instance.
        */
        getTag(): string;
        /**
        Sets the external identifier.
        */
        setExternalId(value: string): void;
        /**
        Sets optional data to associate with this instance.
        */
        setTag(value: string): void;
    }
}
declare namespace fm.liveswitch {
    /**
    Media source base properties/methods.
    */
    abstract class MediaSourceBase extends fm.liveswitch.Dynamic {
        getTypeString(): string;
        /** @hidden */
        private __id;
        /** @hidden */
        private _externalId;
        /** @hidden */
        private _tag;
        constructor();
        /**
        Gets the external identifier.
        */
        getExternalId(): string;
        /**
        Gets the identifier.
        */
        getId(): string;
        /**
        Gets optional data to associate with this instance.
        */
        getTag(): string;
        /**
        Sets the external identifier.
        */
        setExternalId(value: string): void;
        /**
        Sets optional data to associate with this instance.
        */
        setTag(value: string): void;
        /**
        Starts this instance.
        */
        abstract start(): fm.liveswitch.Future<Object>;
        /**
        Stops this instance.
        */
        abstract stop(): fm.liveswitch.Future<Object>;
    }
}
declare namespace fm.liveswitch {
    /**
    Stream interface.
    */
    interface IStream {
        addOnDirectionChange(value: fm.liveswitch.IAction0): void;
        addOnStateChange(value: fm.liveswitch.IAction0): void;
        changeDirection(newDirection: fm.liveswitch.StreamDirection): fm.liveswitch.Error;
        getDirection(): fm.liveswitch.StreamDirection;
        getExternalId(): string;
        getId(): string;
        getLabel(): string;
        getLocalDirection(): fm.liveswitch.StreamDirection;
        getLocalReceive(): boolean;
        getLocalSend(): boolean;
        getMediaDescriptionId(): string;
        getRemoteDirection(): fm.liveswitch.StreamDirection;
        getRemoteReceive(): boolean;
        getRemoteSend(): boolean;
        getState(): fm.liveswitch.StreamState;
        getTag(): string;
        getTransportInfo(): fm.liveswitch.TransportInfo;
        getType(): fm.liveswitch.StreamType;
        removeOnDirectionChange(value: fm.liveswitch.IAction0): void;
        removeOnStateChange(value: fm.liveswitch.IAction0): void;
        setExternalId(value: string): void;
        setLocalDirection(value: fm.liveswitch.StreamDirection): void;
        setLocalReceive(value: boolean): void;
        setLocalSend(value: boolean): void;
        setTag(value: string): void;
    }
}
declare namespace fm.liveswitch {
    /**
    Media stream interface.
    */
    interface IMediaStream extends fm.liveswitch.IStream {
        addOnDiscardBitrateNotification(value: fm.liveswitch.IAction1<fm.liveswitch.BitrateNotification>): void;
        addOnDiscardBitrateRequest(value: fm.liveswitch.IAction1<fm.liveswitch.BitrateRequest>): void;
        addOnLocalEncodingDisabled(value: fm.liveswitch.IAction1<fm.liveswitch.EncodingInfo>): void;
        addOnLocalEncodingEnabled(value: fm.liveswitch.IAction1<fm.liveswitch.EncodingInfo>): void;
        getCodecDisabled(name: string): boolean;
        getControlTransportInfo(): fm.liveswitch.TransportInfo;
        getInfo(): fm.liveswitch.MediaStreamInfo;
        getInputMuted(): boolean;
        getLocalBandwidth(): number;
        getLocalCanonicalName(): string;
        getMaxReceiveBitrate(): number;
        getMaxSendBitrate(): number;
        getOutputMuted(): boolean;
        getPreferredCodecs(): string[];
        getRemoteBandwidth(): number;
        getRemoteCanonicalName(): string;
        getRemoteEncoding(): fm.liveswitch.EncodingInfo;
        getRemoteMuted(): boolean;
        getSimulcastMode(): fm.liveswitch.SimulcastMode;
        raiseBitrateNotification(bitrateNotification: fm.liveswitch.BitrateNotification): boolean;
        raiseBitrateRequest(bitrateRequest: fm.liveswitch.BitrateRequest): boolean;
        removeOnDiscardBitrateNotification(value: fm.liveswitch.IAction1<fm.liveswitch.BitrateNotification>): void;
        removeOnDiscardBitrateRequest(value: fm.liveswitch.IAction1<fm.liveswitch.BitrateRequest>): void;
        removeOnLocalEncodingDisabled(value: fm.liveswitch.IAction1<fm.liveswitch.EncodingInfo>): void;
        removeOnLocalEncodingEnabled(value: fm.liveswitch.IAction1<fm.liveswitch.EncodingInfo>): void;
        setCodecDisabled(name: string, disabled: boolean): void;
        setInputMuted(value: boolean): void;
        setLocalBandwidth(value: number): void;
        setMaxReceiveBitrate(value: number): void;
        setMaxSendBitrate(value: number): void;
        setOutputMuted(value: boolean): void;
        setPreferredCodecs(value: string[]): void;
        setRemoteEncoding(value: fm.liveswitch.EncodingInfo): void;
        setRemoteMuted(value: boolean): void;
        setSimulcastMode(value: fm.liveswitch.SimulcastMode): void;
    }
}
declare namespace fm.liveswitch {
    /**
    Audio stream interface.
    */
    interface IAudioStream extends fm.liveswitch.IMediaStream, fm.liveswitch.IStream {
        addOnReceiveDtmfTone(value: fm.liveswitch.IAction1<fm.liveswitch.dtmf.Tone>): void;
        addOnReceiveDtmfToneChange(value: fm.liveswitch.IAction1<fm.liveswitch.dtmf.Tone>): void;
        addOnSendDtmfTone(value: fm.liveswitch.IAction1<fm.liveswitch.dtmf.Tone>): void;
        addOnSendDtmfToneChange(value: fm.liveswitch.IAction1<fm.liveswitch.dtmf.Tone>): void;
        getG722Disabled(): boolean;
        getOpusDisabled(): boolean;
        getPcmaDisabled(): boolean;
        getPcmuDisabled(): boolean;
        insertDtmfTone(dtmfTone: fm.liveswitch.dtmf.Tone): boolean;
        insertDtmfTones(dtmfTones: fm.liveswitch.dtmf.Tone[]): boolean;
        removeOnReceiveDtmfTone(value: fm.liveswitch.IAction1<fm.liveswitch.dtmf.Tone>): void;
        removeOnReceiveDtmfToneChange(value: fm.liveswitch.IAction1<fm.liveswitch.dtmf.Tone>): void;
        removeOnSendDtmfTone(value: fm.liveswitch.IAction1<fm.liveswitch.dtmf.Tone>): void;
        removeOnSendDtmfToneChange(value: fm.liveswitch.IAction1<fm.liveswitch.dtmf.Tone>): void;
        setG722Disabled(value: boolean): void;
        setOpusDisabled(value: boolean): void;
        setPcmaDisabled(value: boolean): void;
        setPcmuDisabled(value: boolean): void;
    }
}
declare namespace fm.liveswitch {
    class CcmTmmbnPolicyWrapper {
        getTypeString(): string;
        /** @hidden */
        private _value;
        constructor(value: fm.liveswitch.CcmTmmbnPolicy);
        toString(): string;
    }
}
declare namespace fm.liveswitch {
    class CcmTmmbrPolicyWrapper {
        getTypeString(): string;
        /** @hidden */
        private _value;
        constructor(value: fm.liveswitch.CcmTmmbrPolicy);
        toString(): string;
    }
}
declare namespace fm.liveswitch {
    /** @hidden */
    class RateLimiter {
        getTypeString(): string;
        /** @hidden */
        private __lock;
        /** @hidden */
        private __nextAllowedExecution;
        /** @hidden */
        private __numExecutions;
        /** @hidden */
        private __originalExecutionTime;
        /** @hidden */
        private __rules;
        private fmliveswitchRateLimiterInit;
        constructor();
        constructor(rules: fm.liveswitch.RateLimiterRule[]);
        static generateRateLimiterRules(originalInterval: number, backoffMultiplier: number, numRules: number): fm.liveswitch.RateLimiterRule[];
        checkDelay(currentTime: number): number;
        getRules(): fm.liveswitch.RateLimiterRule[];
        reset(): void;
    }
}
declare namespace fm.liveswitch {
    /** @hidden */
    class RateLimiterRule {
        getTypeString(): string;
        /** @hidden */
        private _limit;
        /** @hidden */
        private _period;
        private fmliveswitchRateLimiterRuleInit;
        constructor(limit: number, period: number);
        getLimit(): number;
        getPeriod(): number;
        /** @hidden */
        private setLimit;
        /** @hidden */
        private setPeriod;
    }
}
declare namespace fm.liveswitch {
    /** @hidden */
    class MediaStreamMediaDescriptionManagerUtility {
        getTypeString(): string;
        constructor();
        /** @hidden */
        checkIfMuted(sdpMediaDescription: fm.liveswitch.sdp.MediaDescription): boolean;
        /** @hidden */
        setMuted(muted: boolean, sdpMediaDescription: fm.liveswitch.sdp.MediaDescription): void;
        /** @hidden */
        updateSdpMediaDescription(mediaDescription: fm.liveswitch.sdp.MediaDescription, requirements: fm.liveswitch.IMediaStreamMediaDescriptionRequirementsBase): fm.liveswitch.sdp.MediaDescription;
    }
}
declare namespace fm.liveswitch {
    /** @hidden */
    interface IMediaStreamMediaDescriptionRequirementsBase {
        getLocalMuted(): boolean;
        setLocalMuted(value: boolean): void;
    }
}
declare namespace fm.liveswitch {
    class VideoTypeWrapper {
        getTypeString(): string;
        /** @hidden */
        private _value;
        constructor(value: fm.liveswitch.VideoType);
        toString(): string;
    }
}
declare namespace fm.liveswitch {
    /** @hidden */
    abstract class SimulcastConfig {
        getTypeString(): string;
        /** @hidden */
        private __encodingCount;
        /** @hidden */
        private __preferredBitrate;
        /** @hidden */
        private _disabled;
        private fmliveswitchSimulcastConfigInit;
        constructor(encodingCount: number, preferredBitrate: number);
        getDisabled(): boolean;
        getEncodingCount(): number;
        getPreferredBitrate(): number;
        setDisabled(value: boolean): void;
        setEncodingCount(value: number): void;
        setPreferredBitrate(value: number): void;
    }
}
declare namespace fm.liveswitch {
    /** @hidden */
    class AudioSimulcastConfig extends fm.liveswitch.SimulcastConfig {
        getTypeString(): string;
        constructor(encodingCount: number, preferredBitrate: number);
        /** @hidden */
        getEncodingConfigs(): fm.liveswitch.AudioEncodingConfig[];
    }
}
declare namespace fm.liveswitch {
    /** @hidden */
    class VideoSimulcastConfig extends fm.liveswitch.SimulcastConfig {
        getTypeString(): string;
        /** @hidden */
        private __bitsPerPixel;
        /** @hidden */
        private _degradationPreference;
        private fmliveswitchVideoSimulcastConfigInit;
        constructor(encodingCount: number, preferredBitrate: number);
        constructor(encodingCount: number, preferredBitrate: number, bitsPerPixel: number);
        getBitsPerPixel(): number;
        getDegradationPreference(): fm.liveswitch.VideoDegradationPreference;
        /** @hidden */
        getEncodingConfigs(sourceType: fm.liveswitch.VideoType, sourceWidth: number, sourceHeight: number, sourceFrameRate: number): fm.liveswitch.VideoEncodingConfig[];
        setBitsPerPixel(value: number): void;
        setDegradationPreference(value: fm.liveswitch.VideoDegradationPreference): void;
    }
}
declare namespace fm.liveswitch {
    /**
    A video format.
    */
    class VideoFormat extends fm.liveswitch.MediaFormat<fm.liveswitch.VideoFormat> {
        getTypeString(): string;
        /** @hidden */
        private static fm_liveswitch_VideoFormat__fourCCLookup;
        /** @hidden */
        private static fm_liveswitch_VideoFormat__reverseFourCCLookup;
        /**
        Initializes a new instance of the [[fm.liveswitch.videoFormat]] class.
        */
        constructor();
        /**
        Initializes a new instance of the [[fm.liveswitch.videoFormat]] class.
        @param name The name.
        */
        constructor(name: string);
        /**
        Initializes a new instance of the [[fm.liveswitch.videoFormat]] class.
        @param name The name.
        @param clockRate The clock rate.
        */
        constructor(name: string, clockRate: number);
        /**
        Initializes a new instance of the [[fm.liveswitch.videoFormat]] class.
        @param name The name.
        @param clockRate The clock rate.
        @param packetizationMode The packetization mode.
        */
        constructor(name: string, clockRate: number, packetizationMode: string);
        /**
        Initializes a new instance of the [[fm.liveswitch.videoFormat]] class.
        @param name The name.
        @param clockRate The clock rate.
        @param profile The media format profile.
        @param level The media format level.
        */
        constructor(name: string, clockRate: number, profile: string, level: string);
        /**
        Initializes a new instance of the [[fm.liveswitch.videoFormat]] class.
        @param name The name.
        @param clockRate The clock rate.
        @param packetizationMode The packetization mode.
        @param level The media format level.
        @param profile The media format profile.
        */
        constructor(name: string, clockRate: number, profile: string, level: string, packetizationMode: string);
        /**
        Initializes a new instance of the [[fm.liveswitch.videoFormat]] class.
        @param name The name.
        @param clockRate The clock rate.
        @param packetizationMode The packetization mode.
        @param level The media format level.
        @param profile The media format profile.
        @param tier The media format tier.
        */
        constructor(name: string, clockRate: number, profile: string, level: string, packetizationMode: string, tier: string);
        /**
        Converts a format name to its FourCC value.
        @param formatName The format name.
        @return The FourCC value, or 0 if the format name is not recognized.
        */
        static formatNameToFourCC(formatName: string): number;
        /**
        Transforms a FormatInfo into an VideoFormat.
        @param info The format info.
        */
        static fromFormatInfo(info: fm.liveswitch.FormatInfo): fm.liveswitch.VideoFormat;
        /**
        Deserializes an instance from JSON.
        @param videoFormatJson The video format JSON.
        */
        static fromJson(videoFormatJson: string): fm.liveswitch.VideoFormat;
        /**
        Gets an ABGR video format.
        */
        static getAbgr(): fm.liveswitch.VideoFormat;
        /**
        Gets the name of the ABGR video format ("ABGR"). Indicates that each pixel occupies 32 bits (8 bits for alpha, then 8 bits for blue, then8 bits for green, then 8 bits for red).
        */
        static getAbgrName(): string;
        /**
        Gets an ARGB video format.
        */
        static getArgb(): fm.liveswitch.VideoFormat;
        /**
        Gets the name of the ARGB video format ("ARGB"). Indicates that each pixel occupies 32 bits (8 bits for alpha, then 8 bits for red, then 8 bits for green, then 8 bits for blue).
        */
        static getArgbName(): string;
        /**
        Gets a BGR video format.
        */
        static getBgr(): fm.liveswitch.VideoFormat;
        /**
        Gets an BGRA video format.
        */
        static getBgra(): fm.liveswitch.VideoFormat;
        /**
        Gets the name of the BGRA video format ("BGRA"). Indicates that each pixel occupies 32 bits (8 bits for blue, then8 bits for green, then 8 bits for red, then 8 bits for alpha).
        */
        static getBgraName(): string;
        /**
        Gets the name of the BGR video format ("BGR"). Indicates that each pixel occupies 24 bits (8 bits for blue, then8 bits for green, then 8 bits for red).
        */
        static getBgrName(): string;
        /**
        Gets the default clock rate.
        */
        static getDefaultClockRate(): number;
        /**
        Gets an H.264 video format.
        */
        static getH264(): fm.liveswitch.VideoFormat;
        /**
        Gets the name of the H.264 video format ("H264").
        */
        static getH264Name(): string;
        /**
        Gets an H.265 video format.
        */
        static getH265(): fm.liveswitch.VideoFormat;
        /**
        Gets the name of the H.265 video format ("H265").
        */
        static getH265Name(): string;
        /**
        Gets an I420 video format.
        */
        static getI420(): fm.liveswitch.VideoFormat;
        /**
        Gets the name of the I420 video format ("I420"). Indicates that each pixel occupies 12 bits (8 bits for Y, 2 bits for U, and 2 bits for V). Y plane is followed by U plane and then V plane.
        */
        static getI420Name(): string;
        /**
        Gets an NV12 video format.
        */
        static getNv12(): fm.liveswitch.VideoFormat;
        /**
        Gets the name of the NV12 video format ("NV12"). Indicates that each pixel occupies 12 bits (8 bits for Y, 2 bits for U, and 2 bits for V). Y plane is followed by interleaved U/V plane.
        */
        static getNv12Name(): string;
        /**
        Gets an NV21 video format.
        */
        static getNv21(): fm.liveswitch.VideoFormat;
        /**
        Gets the name of the NV21 video format ("NV21"). Indicates that each pixel occupies 12 bits (8 bits for Y, 2 bits for U, and 2 bits for V). Y plane is followed by interleaved V/U plane.
        */
        static getNv21Name(): string;
        /**
        Gets an RGB video format.
        */
        static getRgb(): fm.liveswitch.VideoFormat;
        /**
        Gets an RGBA video format.
        */
        static getRgba(): fm.liveswitch.VideoFormat;
        /**
        Gets the name of the RGBA video format ("RGBA"). Indicates that each pixel occupies 32 bits (8 bits for red, then 8 bits for green, then 8 bits for blue, then 8 bits for alpha).
        */
        static getRgbaName(): string;
        /**
        Gets the name of the RGB video format ("RGB"). Indicates that each pixel occupies 24 bits (8 bits for red, then 8 bits for green, then 8 bits for blue).
        */
        static getRgbName(): string;
        /**
        Gets a VP8 video format.
        */
        static getVp8(): fm.liveswitch.VideoFormat;
        /**
        Gets the name of the VP8 video format ("VP8").
        */
        static getVp8Name(): string;
        /**
        Gets a VP9 video format.
        */
        static getVp9(): fm.liveswitch.VideoFormat;
        /**
        Gets the name of the VP9 video format ("VP9").
        */
        static getVp9Name(): string;
        /**
        Gets a YV12 video format.
        */
        static getYv12(): fm.liveswitch.VideoFormat;
        /**
        Gets the name of the YV12 video format ("YV12"). Indicates that each pixel occupies 12 bits (8 bits for Y, 2 bits for U, and 2 bits for V). Y plane is followed by V plane and then U plane.
        */
        static getYv12Name(): string;
        /**
        Converts 4 FourCC characters to an int.
        */
        static toFourCC(a: number, b: number, c: number, d: number): number;
        /**
        Converts a FourCC string to a int.
        @param fourcc The fourcc.
        */
        static toFourCC(fourcc: string): number;
        /**
        Serializes an instance to JSON.
        @param videoFormat The video format.
        */
        static toJson(videoFormat: fm.liveswitch.VideoFormat): string;
        /**
        Clones this instance.
        */
        clone(): fm.liveswitch.VideoFormat;
        /**
        Creates a new instance.
        */
        protected createInstance(): fm.liveswitch.VideoFormat;
        /**
        Converts a FourCC value to its format name.
        @param fourcc The FourCC value.
        @return The format name, or an empty string if the FourCC value is not recognized.
        */
        fourCCToFormatName(fourcc: number): string;
        /**
        Gets the FourCC value for this format.
        */
        getFourCC(): number;
        /**
        Gets this format as an info object.
        */
        getInfo(): fm.liveswitch.FormatInfo;
        /**
        Gets a value indicating whether this format is ABGR.
        */
        getIsAbgr(): boolean;
        /**
        Gets a value indicating whether this format is ARGB.
        */
        getIsArgb(): boolean;
        /**
        Gets a value indicating whether this format is BGR.
        */
        getIsBgr(): boolean;
        /**
        Gets a value indicating whether this format is BGRA.
        */
        getIsBgra(): boolean;
        /**
        Gets whether this is a compressed format.
        */
        getIsCompressed(): boolean;
        /**
        Gets a value indicating whether this format is H.264.
        */
        getIsH264(): boolean;
        /**
        Gets a value indicating whether this format is H.265.
        */
        getIsH265(): boolean;
        /**
        Gets a value indicating whether this format is I420.
        */
        getIsI420(): boolean;
        /**
        Gets a value indicating whether this format is NV12.
        */
        getIsNv12(): boolean;
        /**
        Gets a value indicating whether this format is NV21.
        */
        getIsNv21(): boolean;
        /**
        Gets a value indicating whether this format is RGB, BGR, I420, YV12, NV12, NV21, RGBA, BGRA, ARGB, or ABGR.
        */
        getIsRaw(): boolean;
        /**
        Gets a value indicating whether this format is RGB.
        */
        getIsRgb(): boolean;
        /**
        Gets a value indicating whether this format is RGBA.
        */
        getIsRgba(): boolean;
        /**
        Gets a value indicating whether this format is RGBA, BGRA, ARGB, or ABGR.
        */
        getIsRgbaType(): boolean;
        /**
        Gets a value indicating whether this format is RGB or BGR.
        */
        getIsRgbType(): boolean;
        /**
        Gets a value indicating whether this format is VP8.
        */
        getIsVp8(): boolean;
        /**
        Gets a value indicating whether this format is VP9.
        */
        getIsVp9(): boolean;
        /**
        Gets a value indicating whether this format is I420, YV12, NV12, or NV21.
        */
        getIsYuvType(): boolean;
        /**
        Gets a value indicating whether this format is YV12.
        */
        getIsYv12(): boolean;
        /**
        Gets the maximum level.
        @param level1 The first level.
        @param level2 The second level.
        @return The maximum level.
        */
        protected getMaxLevel(level1: string, level2: string): string;
        /**
        Gets the minimum level.
        @param level1 The first level.
        @param level2 The second level.
        @return The minimum level.
        */
        protected getMinLevel(level1: string, level2: string): string;
        /**
        Gets the parameters.
        */
        getParameters(): string;
        /**
        Gets whether a level is compatible.
        @param level The level.
        */
        protected isLevelCompatible(level: string): boolean;
        /**
        Gets whether a profile is compatible.
        @param profile The profile.
        */
        protected isProfileCompatible(profile: string): boolean;
        /**
        Sets the FourCC value for this format.
        */
        setFourCC(value: number): void;
        /**
        Serializes this instance to JSON.
        */
        toJson(): string;
        /**
        Updates the profile to a compatible value.
        @param format The format.
        */
        protected updateProfileToCompatible(format: fm.liveswitch.VideoFormat): void;
        /** @hidden */
        private static __fmliveswitchVideoFormatInitialized;
        /** @hidden */
        private static __fmliveswitchVideoFormatInitializing;
        /** @hidden */
        static fmliveswitchVideoFormatInitialize(): void;
    }
}
declare namespace fm.liveswitch.h265 {
    /**
    An H.265/HEVC format.
    */
    class Format extends fm.liveswitch.VideoFormat {
        getTypeString(): string;
        /**
        Initializes a new instance of the [[fm.liveswitch.h265.format]] class.
        */
        constructor();
        /**
        Initializes a new instance of the [[fm.liveswitch.h265.format]] class.
        @param clockRate The clock rate.
        */
        constructor(clockRate: number);
        /**
        Initializes a new instance of the [[fm.liveswitch.h265.format]] class.
        @param clockRate The clock rate.
        @param profile The profile.
        @param level The level.
        @param tier The tier.
        */
        constructor(clockRate: number, profile: number, level: number, tier: number);
        /**
        Initializes a new instance of the [[fm.liveswitch.h265.format]] class.
        @param profile The profile.
        @param level The level.
        @param tier The tier.
        */
        constructor(profile: number, level: number, tier: number);
    }
}
declare namespace fm.liveswitch.g722 {
    /**
    A G.722 format.
    */
    class Format extends fm.liveswitch.AudioFormat {
        getTypeString(): string;
        /**
        Initializes a new instance of the [[fm.liveswitch.g722.format]] class.
        */
        constructor();
        /**
        Initializes a new instance of the [[fm.liveswitch.g722.format]] class.
        @param clockRate The clock rate.
        @param channelCount The channel count.
        */
        constructor(clockRate: number, channelCount: number);
        /**
        Initializes a new instance of the [[fm.liveswitch.g722.format]] class.
        @param config The configuration.
        */
        constructor(config: fm.liveswitch.AudioConfig);
        /**
        Gets the default clock rate (1).
        */
        static getDefaultChannelCount(): number;
        /**
        Gets the default clock rate (16000).
        */
        static getDefaultClockRate(): number;
        /**
        Gets the default configuration (16000/1).
        */
        static getDefaultConfig(): fm.liveswitch.AudioConfig;
        /**
        Creates a new instance.
        */
        protected createInstance(): fm.liveswitch.AudioFormat;
        /** @hidden */
        private getFixedBitrate;
        /**
        Gets the maximum bitrate supported by this format, in kbps.
        */
        getMaxBitrate(): number;
        /**
        Gets the minimum bitrate supported by this format, in kbps.
        */
        getMinBitrate(): number;
    }
}
declare namespace fm.liveswitch {
    /**
    A moving average.
    */
    class MovingAverage {
        getTypeString(): string;
        /** @hidden */
        private __values;
        /** @hidden */
        private __valuesDivisor;
        /** @hidden */
        private __valuesIndex;
        /** @hidden */
        private __valuesLookback;
        /** @hidden */
        private __valuesSum;
        /** @hidden */
        private _average;
        private fmliveswitchMovingAverageInit;
        /**
        Initializes a new instance of the [[fm.liveswitch.movingAverage]] class.
        @param lookback The number of lookback values.
        */
        constructor(lookback: number);
        /**
        Adds a sample.
        @param value The value to add.
        */
        add(value: number): void;
        /**
        Gets the average.
        */
        getAverage(): number;
        /** @hidden */
        private setAverage;
    }
}
declare namespace fm.liveswitch {
    class CcmLrrPolicyWrapper {
        getTypeString(): string;
        /** @hidden */
        private _value;
        constructor(value: fm.liveswitch.CcmLrrPolicy);
        toString(): string;
    }
}
declare namespace fm.liveswitch {
    /** @hidden */
    class DataMessage {
        getTypeString(): string;
        /** @hidden */
        private __elements;
        /** @hidden */
        private _dataBytes;
        /** @hidden */
        private _dataString;
        /** @hidden */
        private static fm_liveswitch_DataMessage___dataBufferPool;
        /** @hidden */
        private static fm_liveswitch_DataMessage___log;
        /** @hidden */
        static readonly IntUnset: number;
        constructor(messageBytes: fm.liveswitch.DataBuffer);
        constructor(messageString: string);
        /** @hidden */
        static parseBytes(buffer: fm.liveswitch.DataBuffer): fm.liveswitch.DataMessage;
        /** @hidden */
        getBytes(): fm.liveswitch.DataBuffer;
        getDataBytes(): fm.liveswitch.DataBuffer;
        getDataString(): string;
        /** @hidden */
        getElements(): fm.liveswitch.datamessageheader.Element[];
        /** @hidden */
        getNumberOfRetransmissions(): number;
        /** @hidden */
        getRemoteConnectionId(): string;
        /** @hidden */
        getTimeToLive(): number;
        /** @hidden */
        getVersion(): number;
        /** @hidden */
        private setDataBytes;
        /** @hidden */
        private setDataString;
        /** @hidden */
        setElements(value: fm.liveswitch.datamessageheader.Element[]): void;
        /** @hidden */
        setNumberOfRetransmissions(value: number): void;
        /** @hidden */
        setRemoteConnectionId(value: string): void;
        /** @hidden */
        setTimeToLive(value: number): void;
        /** @hidden */
        private static __fmliveswitchDataMessageInitialized;
        /** @hidden */
        private static __fmliveswitchDataMessageInitializing;
        /** @hidden */
        static fmliveswitchDataMessageInitialize(): void;
    }
}
declare namespace fm.liveswitch.datamessageheader {
    /** @hidden */
    abstract class Element {
        getTypeString(): string;
        /** @hidden */
        private _type;
        private fmliveswitchdatamessageheaderElementInit;
        constructor();
        static parseBytes(buffer: fm.liveswitch.DataBuffer, offset: number, offsetPlus: fm.liveswitch.Holder<number>): fm.liveswitch.datamessageheader.Element;
        abstract getBytes(): fm.liveswitch.DataBuffer;
        abstract getLength(): number;
        getType(): number;
        protected setType(value: number): void;
    }
}
declare namespace fm.liveswitch.datamessageheader {
    /** @hidden */
    class DeliveryAttemptsElement extends fm.liveswitch.datamessageheader.Element {
        getTypeString(): string;
        /** @hidden */
        private _deliveryAttempts;
        /** @hidden */
        private static fm_liveswitch_datamessageheader_DeliveryAttemptsElement___dataBufferPool;
        private fmliveswitchdatamessageheaderDeliveryAttemptsElementInit;
        constructor(numAttempts: number);
        /** @hidden */
        static doParseBytes(buffer: fm.liveswitch.DataBuffer, index: number, offsetPlus: fm.liveswitch.Holder<number>): fm.liveswitch.datamessageheader.Element;
        getBytes(): fm.liveswitch.DataBuffer;
        getDeliveryAttempts(): number;
        getLength(): number;
        /** @hidden */
        private setDeliveryAttempts;
        /** @hidden */
        private static __fmliveswitchdatamessageheaderDeliveryAttemptsElementInitialized;
        /** @hidden */
        private static __fmliveswitchdatamessageheaderDeliveryAttemptsElementInitializing;
        /** @hidden */
        static fmliveswitchdatamessageheaderDeliveryAttemptsElementInitialize(): void;
    }
}
declare namespace fm.liveswitch.datamessageheader {
    /** @hidden */
    class ConnectionIdElement extends fm.liveswitch.datamessageheader.Element {
        getTypeString(): string;
        /** @hidden */
        private __connectionId;
        /** @hidden */
        private static fm_liveswitch_datamessageheader_ConnectionIdElement___dataBufferPool;
        constructor(idValue: string);
        /** @hidden */
        static doParseBytes(buffer: fm.liveswitch.DataBuffer, index: number, offsetPlus: fm.liveswitch.Holder<number>): fm.liveswitch.datamessageheader.Element;
        getBytes(): fm.liveswitch.DataBuffer;
        getConnectionId(): string;
        getLength(): number;
        /** @hidden */
        private setConnectionId;
        /** @hidden */
        private static __fmliveswitchdatamessageheaderConnectionIdElementInitialized;
        /** @hidden */
        private static __fmliveswitchdatamessageheaderConnectionIdElementInitializing;
        /** @hidden */
        static fmliveswitchdatamessageheaderConnectionIdElementInitialize(): void;
    }
}
declare namespace fm.liveswitch.datamessageheader {
    /** @hidden */
    class TimeToLiveElement extends fm.liveswitch.datamessageheader.Element {
        getTypeString(): string;
        /** @hidden */
        private _timeToLive;
        /** @hidden */
        private static fm_liveswitch_datamessageheader_TimeToLiveElement___dataBufferPool;
        private fmliveswitchdatamessageheaderTimeToLiveElementInit;
        constructor(ttl: number);
        /** @hidden */
        static doParseBytes(buffer: fm.liveswitch.DataBuffer, index: number, offsetPlus: fm.liveswitch.Holder<number>): fm.liveswitch.datamessageheader.Element;
        getBytes(): fm.liveswitch.DataBuffer;
        getLength(): number;
        getTimeToLive(): number;
        /** @hidden */
        private setTimeToLive;
        /** @hidden */
        private static __fmliveswitchdatamessageheaderTimeToLiveElementInitialized;
        /** @hidden */
        private static __fmliveswitchdatamessageheaderTimeToLiveElementInitializing;
        /** @hidden */
        static fmliveswitchdatamessageheaderTimeToLiveElementInitialize(): void;
    }
}
declare namespace fm.liveswitch.datamessageheader {
    /** @hidden */
    class Type {
        getTypeString(): string;
        constructor();
        static getConnectionId(): number;
        static getDeliveryAttempts(): number;
        static getTimeToLive(): number;
    }
}
declare namespace fm.liveswitch.datamessageheader {
    /** @hidden */
    class UnknownElement extends fm.liveswitch.datamessageheader.Element {
        getTypeString(): string;
        /** @hidden */
        private __length;
        /** @hidden */
        private __payload;
        /** @hidden */
        private static fm_liveswitch_datamessageheader_UnknownElement___dataBufferPool;
        private fmliveswitchdatamessageheaderUnknownElementInit;
        constructor(type: number, payload: fm.liveswitch.DataBuffer);
        /** @hidden */
        static doParseBytes(buffer: fm.liveswitch.DataBuffer, index: number, offsetPlus: fm.liveswitch.Holder<number>): fm.liveswitch.datamessageheader.Element;
        getBytes(): fm.liveswitch.DataBuffer;
        getLength(): number;
        /** @hidden */
        getPayload(): fm.liveswitch.DataBuffer;
        /** @hidden */
        setPayload(value: fm.liveswitch.DataBuffer): void;
        /** @hidden */
        private static __fmliveswitchdatamessageheaderUnknownElementInitialized;
        /** @hidden */
        private static __fmliveswitchdatamessageheaderUnknownElementInitializing;
        /** @hidden */
        static fmliveswitchdatamessageheaderUnknownElementInitialize(): void;
    }
}
declare namespace fm.liveswitch {
    class CcmFirPolicyWrapper {
        getTypeString(): string;
        /** @hidden */
        private _value;
        constructor(value: fm.liveswitch.CcmFirPolicy);
        toString(): string;
    }
}
declare namespace fm.liveswitch {
    class NackPliPolicyWrapper {
        getTypeString(): string;
        /** @hidden */
        private _value;
        constructor(value: fm.liveswitch.NackPliPolicy);
        toString(): string;
    }
}
declare namespace fm.liveswitch {
    /** @hidden */
    class SessionDescriptionStreamMatcher<TStream extends fm.liveswitch.WebRtcStreamBase> {
        getTypeString(): string;
        /** @hidden */
        private __internalAudioStreamIndex;
        /** @hidden */
        private __internalDataStreamIndex;
        /** @hidden */
        private __internalStreamIndexByOfferIndex;
        /** @hidden */
        private __internalVideoStreamIndex;
        /** @hidden */
        private __offererAudioStreamIndex;
        /** @hidden */
        private __offererDataStreamIndex;
        /** @hidden */
        private __offererStreamIndexByInternalIndex;
        /** @hidden */
        private __offererVideoStreamIndex;
        constructor(numStreams: number);
        getInternalStreamIndexFor(oferrerStreamIndex: number): number;
        /** @hidden */
        getInternalStreamMediaIndexForStream(type: fm.liveswitch.StreamType, indexInType: number): number;
        getOffererStreamIndexFor(internalStreamIndex: number): number;
        /** @hidden */
        getOffererStreamMediaIndexForStream(type: fm.liveswitch.StreamType, indexInType: number): number;
        /** @hidden */
        populateInternalStreamTypeIndexes(streams: Array<TStream>): fm.liveswitch.Error;
        /** @hidden */
        populateOffererStreamTypeIndexes(sdpMediaDescriptions: fm.liveswitch.sdp.MediaDescription[]): fm.liveswitch.Error;
        reset(): void;
        reset(numStreams: number): void;
        setMatchingIndexes(internalStreamIndex: number, offererStreamIndex: number): void;
    }
}
declare namespace fm.liveswitch {
    class SimulcastModeWrapper {
        getTypeString(): string;
        /** @hidden */
        private _value;
        constructor(value: fm.liveswitch.SimulcastMode);
        toString(): string;
    }
}
declare namespace fm.liveswitch {
    /**
    Media track interface.
    */
    interface IMediaTrack {
        addOnDestroyed(value: fm.liveswitch.IAction0): void;
        addOnStarted(value: fm.liveswitch.IAction0): void;
        addOnStopped(value: fm.liveswitch.IAction0): void;
        changeSinkOutput(sinkOutput: fm.liveswitch.SinkOutput): fm.liveswitch.Future<Object>;
        changeSourceInput(sourceInput: fm.liveswitch.SourceInput): fm.liveswitch.Future<Object>;
        destroy(): boolean;
        getMuted(): boolean;
        getSinkOutput(): fm.liveswitch.SinkOutput;
        getSinkOutputs(): fm.liveswitch.Future<fm.liveswitch.SinkOutput[]>;
        getSourceInput(): fm.liveswitch.SourceInput;
        getSourceInputs(): fm.liveswitch.Future<fm.liveswitch.SourceInput[]>;
        removeOnDestroyed(value: fm.liveswitch.IAction0): void;
        removeOnStarted(value: fm.liveswitch.IAction0): void;
        removeOnStopped(value: fm.liveswitch.IAction0): void;
        setMuted(value: boolean): void;
        setSinkOutput(value: fm.liveswitch.SinkOutput): void;
        setSourceInput(value: fm.liveswitch.SourceInput): void;
    }
}
declare namespace fm.liveswitch {
    /**
    Audio track interface.
    */
    interface IAudioTrack extends fm.liveswitch.IMediaTrack {
        addOnLevel(value: fm.liveswitch.IAction1<number>): void;
        getGain(): number;
        getVolume(): number;
        removeOnLevel(value: fm.liveswitch.IAction1<number>): void;
        setGain(value: number): void;
        setVolume(value: number): void;
    }
}
declare namespace fm.liveswitch {
    class BundlePolicyWrapper {
        getTypeString(): string;
        /** @hidden */
        private _value;
        constructor(value: fm.liveswitch.BundlePolicy);
        toString(): string;
    }
}
declare namespace fm.liveswitch {
    /**
    A candidate.
    */
    class Candidate {
        getTypeString(): string;
        /** @hidden */
        private __protocol;
        /** @hidden */
        private __relayProtocol;
        /** @hidden */
        private __sdpCandidateAttribute;
        /** @hidden */
        private _dispatched;
        /** @hidden */
        private _sdpMediaIndex;
        private fmliveswitchCandidateInit;
        constructor();
        /**
        Deserializes an instance from JSON.
        @param candidateJson The JSON to deserialize.
        @return
                    The deserialized candidate.
            
        */
        static fromJson(candidateJson: string): fm.liveswitch.Candidate;
        /**
        Serializes an instance to JSON.
        @param candidate The candidate to serialize.
        @return
                    The serialized JSON.
            
        */
        static toJson(candidate: fm.liveswitch.Candidate): string;
        /**
        Gets a value indicating whether this candidate has been already been dispatched as a part of a session description.
        */
        getDispatched(): boolean;
        /** @hidden */
        getProtocol(): fm.liveswitch.ProtocolType;
        /**
        Gets the relay protocol, the protocol used by this candidate to communicate with the relay (TURN) server.
        */
        getRelayProtocol(): fm.liveswitch.ProtocolType;
        /**
        Gets the SDP candidate attribute.
        */
        getSdpCandidateAttribute(): fm.liveswitch.sdp.ice.CandidateAttribute;
        /**
        Gets the media index.
        */
        getSdpMediaIndex(): number;
        /**
        Gets the relay protocol, the protocol used by this candidate to communicate with the relay (TURN) server. Obsolete. Alias for [[fm.liveswitch.candidate.relayProtocol]].
        */
        getTurnTransportProtocol(): fm.liveswitch.ProtocolType;
        /**
        Sets a value indicating whether this candidate has been already been dispatched as a part of a session description.
        */
        setDispatched(value: boolean): void;
        /** @hidden */
        setProtocol(value: fm.liveswitch.ProtocolType): void;
        /**
        Sets the relay protocol, the protocol used by this candidate to communicate with the relay (TURN) server.
        */
        setRelayProtocol(value: fm.liveswitch.ProtocolType): void;
        /**
        Sets the SDP candidate attribute.
        */
        setSdpCandidateAttribute(value: fm.liveswitch.sdp.ice.CandidateAttribute): void;
        /**
        Sets the media index.
        */
        setSdpMediaIndex(value: number): void;
        /**
        Sets the relay protocol, the protocol used by this candidate to communicate with the relay (TURN) server. Obsolete. Alias for [[fm.liveswitch.candidate.relayProtocol]].
        */
        setTurnTransportProtocol(value: fm.liveswitch.ProtocolType): void;
        /**
        Serializes this instance to JSON.
        */
        toJson(): string;
    }
}
declare namespace fm.liveswitch {
    /**
    A color.
    */
    class Color {
        getTypeString(): string;
        /** @hidden */
        private _b;
        /** @hidden */
        private _g;
        /** @hidden */
        private _r;
        private fmliveswitchColorInit;
        /**
        Initializes a new instance of the [[fm.liveswitch.color]] class.
        @param r The red value (0-255).
        @param g The green value (0-255).
        @param b The blue value (0-255).
        */
        constructor(r: number, g: number, b: number);
        /**
        Creates a [[fm.liveswitch.color]] using hue, saturation, and brightness.
        @param hue The hue value (0-359).
        @param saturation The saturation value (0.0-1.0).
        @param brightness The brightness value (0.0-1.0).
        */
        static fromHsb(hue: number, saturation: number, brightness: number): fm.liveswitch.Color;
        /**
        Gets a black color.
        */
        static getBlack(): fm.liveswitch.Color;
        /**
        Gets a blue color.
        */
        static getBlue(): fm.liveswitch.Color;
        /**
        Gets a cyan color.
        */
        static getCyan(): fm.liveswitch.Color;
        /**
        Gets a dark-blue color.
        */
        static getDarkBlue(): fm.liveswitch.Color;
        /**
        Gets a dark-green color.
        */
        static getDarkGreen(): fm.liveswitch.Color;
        /**
        Gets a dark-red color.
        */
        static getDarkRed(): fm.liveswitch.Color;
        /**
        Gets a gray color.
        */
        static getGray(): fm.liveswitch.Color;
        /**
        Gets a green color.
        */
        static getGreen(): fm.liveswitch.Color;
        /**
        Gets a magenta color.
        */
        static getMagenta(): fm.liveswitch.Color;
        /**
        Gets an olive color.
        */
        static getOlive(): fm.liveswitch.Color;
        /**
        Gets a purple color.
        */
        static getPurple(): fm.liveswitch.Color;
        /**
        Gets a red color.
        */
        static getRed(): fm.liveswitch.Color;
        /**
        Gets a teal color.
        */
        static getTeal(): fm.liveswitch.Color;
        /**
        Gets a white color.
        */
        static getWhite(): fm.liveswitch.Color;
        /**
        Gets a yellow color.
        */
        static getYellow(): fm.liveswitch.Color;
        /**
        Gets the blue value (0-255).
        */
        getB(): number;
        /**
        Gets the green value (0-255).
        */
        getG(): number;
        /**
        Gets the red value (0-255).
        */
        getR(): number;
        /** @hidden */
        private setB;
        /** @hidden */
        private setG;
        /** @hidden */
        private setR;
    }
}
declare namespace fm.liveswitch {
    /**
    Connection interface.
    */
    interface IConnection<TConnection, TStream, TAudioStream, TVideoStream, TDataStream> {
        addIceServer(iceServer: fm.liveswitch.IceServer): void;
        addIceServers(iceServers: fm.liveswitch.IceServer[]): void;
        addOnExternalIdChange(value: fm.liveswitch.IAction2<string, string>): void;
        addOnGatheringStateChange(value: fm.liveswitch.IAction1<TConnection>): void;
        addOnIceConnectionStateChange(value: fm.liveswitch.IAction1<TConnection>): void;
        addOnLocalCandidate(value: fm.liveswitch.IAction2<TConnection, fm.liveswitch.Candidate>): void;
        addOnLocalDescription(value: fm.liveswitch.IAction2<TConnection, fm.liveswitch.SessionDescription>): void;
        addOnRemoteCandidate(value: fm.liveswitch.IAction2<TConnection, fm.liveswitch.Candidate>): void;
        addOnRemoteDescription(value: fm.liveswitch.IAction2<TConnection, fm.liveswitch.SessionDescription>): void;
        addOnSignallingStateChange(value: fm.liveswitch.IAction1<TConnection>): void;
        addOnStateChange(value: fm.liveswitch.IAction1<TConnection>): void;
        addRemoteCandidate(remoteCandidate: fm.liveswitch.Candidate): fm.liveswitch.Future<fm.liveswitch.Candidate>;
        close(): boolean;
        createAnswer(): fm.liveswitch.Future<fm.liveswitch.SessionDescription>;
        createOffer(): fm.liveswitch.Future<fm.liveswitch.SessionDescription>;
        getAudioStream(): TAudioStream;
        getAudioStreams(): TAudioStream[];
        getBundlePolicy(): fm.liveswitch.BundlePolicy;
        getCanonicalName(): string;
        getDataStream(): TDataStream;
        getDataStreams(): TDataStream[];
        getDeadStreamTimeout(): number;
        getError(): fm.liveswitch.Error;
        getExternalId(): string;
        getGatheringState(): fm.liveswitch.IceGatheringState;
        getHasAudio(): boolean;
        getHasData(): boolean;
        getHasVideo(): boolean;
        getIceConnectionState(): fm.liveswitch.IceConnectionState;
        getIceGatherPolicy(): fm.liveswitch.IceGatherPolicy;
        getIceServer(): fm.liveswitch.IceServer;
        getIceServers(): fm.liveswitch.IceServer[];
        getId(): string;
        getLegacyTimeout(): boolean;
        getLocalDescription(): fm.liveswitch.SessionDescription;
        getRemoteDescription(): fm.liveswitch.SessionDescription;
        getSignallingState(): fm.liveswitch.SignallingState;
        getState(): fm.liveswitch.ConnectionState;
        getStats(): fm.liveswitch.Future<fm.liveswitch.ConnectionStats>;
        getStreams(): TStream[];
        getTieBreaker(): string;
        getTimeout(): number;
        getTrickleIcePolicy(): fm.liveswitch.TrickleIcePolicy;
        getVideoStream(): TVideoStream;
        getVideoStreams(): TVideoStream[];
        removeIceServer(iceServer: fm.liveswitch.IceServer): void;
        removeIceServers(iceServers: fm.liveswitch.IceServer[]): void;
        removeOnExternalIdChange(value: fm.liveswitch.IAction2<string, string>): void;
        removeOnGatheringStateChange(value: fm.liveswitch.IAction1<TConnection>): void;
        removeOnIceConnectionStateChange(value: fm.liveswitch.IAction1<TConnection>): void;
        removeOnLocalCandidate(value: fm.liveswitch.IAction2<TConnection, fm.liveswitch.Candidate>): void;
        removeOnLocalDescription(value: fm.liveswitch.IAction2<TConnection, fm.liveswitch.SessionDescription>): void;
        removeOnRemoteCandidate(value: fm.liveswitch.IAction2<TConnection, fm.liveswitch.Candidate>): void;
        removeOnRemoteDescription(value: fm.liveswitch.IAction2<TConnection, fm.liveswitch.SessionDescription>): void;
        removeOnSignallingStateChange(value: fm.liveswitch.IAction1<TConnection>): void;
        removeOnStateChange(value: fm.liveswitch.IAction1<TConnection>): void;
        setBundlePolicy(value: fm.liveswitch.BundlePolicy): void;
        setDeadStreamTimeout(value: number): void;
        setError(value: fm.liveswitch.Error): void;
        setExternalId(value: string): void;
        setIceGatherPolicy(value: fm.liveswitch.IceGatherPolicy): void;
        setIceServer(value: fm.liveswitch.IceServer): void;
        setIceServers(value: fm.liveswitch.IceServer[]): void;
        setLegacyTimeout(value: boolean): void;
        setLocalDescription(localDescription: fm.liveswitch.SessionDescription): fm.liveswitch.Future<fm.liveswitch.SessionDescription>;
        setRemoteDescription(remoteDescription: fm.liveswitch.SessionDescription): fm.liveswitch.Future<fm.liveswitch.SessionDescription>;
        setTieBreaker(value: string): void;
        setTimeout(value: number): void;
        setTrickleIcePolicy(value: fm.liveswitch.TrickleIcePolicy): void;
    }
}
declare namespace fm.liveswitch {
    /** @hidden */
    class ConnectionCollection extends fm.liveswitch.Collection<fm.liveswitch.Connection, fm.liveswitch.ConnectionCollection> {
        getTypeString(): string;
        /** @hidden */
        private __lookupByExternalId;
        /** @hidden */
        private __lookupByInternalId;
        /** @hidden */
        private __lookupLock;
        constructor();
        protected addSuccess(value: fm.liveswitch.Connection): void;
        protected arrayFromList(list: Array<fm.liveswitch.Connection>): fm.liveswitch.Connection[];
        protected createCollection(): fm.liveswitch.ConnectionCollection;
        getByExternalId(idValue: string): fm.liveswitch.Connection;
        getById(idValue: string): fm.liveswitch.Connection;
        /** @hidden */
        private processExternalIdChange;
        protected removeSuccess(value: fm.liveswitch.Connection): void;
        tryGetByExternalId(idValue: string, connection: fm.liveswitch.Holder<fm.liveswitch.Connection>): boolean;
        tryGetById(idValue: string, connection: fm.liveswitch.Holder<fm.liveswitch.Connection>): boolean;
    }
}
declare namespace fm.liveswitch {
    /**
    A state machine for data channel states.
    */
    class DataChannelStateMachine extends fm.liveswitch.StateMachine<fm.liveswitch.DataChannelState> {
        getTypeString(): string;
        /**
        Initializes a new instance of the [[fm.liveswitch.dataChannelStateMachine]] class.
        */
        constructor();
        /**
        Converts a state to an integer value.
        @param state The state.
        */
        protected stateToValue(state: fm.liveswitch.DataChannelState): number;
        /**
        Converts an integer value to a state.
        @param value The integer value.
        */
        protected valueToState(value: number): fm.liveswitch.DataChannelState;
    }
}
declare namespace fm.liveswitch {
    /**
    View sink interface.
    */
    interface IViewSink<TView> {
        getView(): TView;
        getViewMirror(): boolean;
        getViewScale(): fm.liveswitch.LayoutScale;
        setViewMirror(value: boolean): void;
        setViewScale(value: fm.liveswitch.LayoutScale): void;
    }
}
declare namespace fm.liveswitch {
    /**
    A state machine for stream states.
    */
    class StreamStateMachine extends fm.liveswitch.StateMachine<fm.liveswitch.StreamState> {
        getTypeString(): string;
        /**
        Initializes a new instance of the [[fm.liveswitch.streamStateMachine]] class.
        */
        constructor();
        /**
        Converts a state to an integer value.
        @param state The state.
        */
        protected stateToValue(state: fm.liveswitch.StreamState): number;
        /**
        Converts an integer value to a state.
        @param value The integer value.
        */
        protected valueToState(value: number): fm.liveswitch.StreamState;
    }
}
declare namespace fm.liveswitch {
    /**
    A state machine for connection states.
    */
    class ConnectionStateMachine extends fm.liveswitch.StateMachine<fm.liveswitch.ConnectionState> {
        getTypeString(): string;
        /**
        Initializes a new instance of the [[fm.liveswitch.connectionStateMachine]] class.
        */
        constructor();
        /**
        Converts a state to an integer value.
        @param state The state.
        */
        protected stateToValue(state: fm.liveswitch.ConnectionState): number;
        /**
        Converts an integer value to a state.
        @param value The integer value.
        */
        protected valueToState(value: number): fm.liveswitch.ConnectionState;
    }
}
declare namespace fm.liveswitch {
    /**
    Data channel interface.
    */
    interface IDataChannel<TDataChannel> {
        addOnStateChange(value: fm.liveswitch.IAction1<TDataChannel>): void;
        getId(): string;
        getInfo(): fm.liveswitch.DataChannelInfo;
        getLabel(): string;
        getOnReceive(): fm.liveswitch.IAction1<fm.liveswitch.DataChannelReceiveArgs>;
        getOrdered(): boolean;
        getState(): fm.liveswitch.DataChannelState;
        getSubprotocol(): string;
        removeOnStateChange(value: fm.liveswitch.IAction1<TDataChannel>): void;
        sendDataBytes(dataBytes: fm.liveswitch.DataBuffer): fm.liveswitch.Future<Object>;
        sendDataString(dataString: string): fm.liveswitch.Future<Object>;
        setOnReceive(value: fm.liveswitch.IAction1<fm.liveswitch.DataChannelReceiveArgs>): void;
    }
}
declare namespace fm.liveswitch {
    /**
    A collection of data channels.
    */
    class DataChannelCollection extends fm.liveswitch.Collection<fm.liveswitch.DataChannel, fm.liveswitch.DataChannelCollection> {
        getTypeString(): string;
        constructor();
        /**
        Creates an array from a list.
        @param list The list.
        */
        protected arrayFromList(list: Array<fm.liveswitch.DataChannel>): fm.liveswitch.DataChannel[];
        /**
        Creates a collection.
        */
        protected createCollection(): fm.liveswitch.DataChannelCollection;
    }
}
declare namespace fm.liveswitch {
    /**
    Arguments for the data channel receive event.
    */
    class DataChannelReceiveArgs {
        getTypeString(): string;
        /** @hidden */
        private __remoteConnectionInfo;
        /** @hidden */
        private _dataBytes;
        /** @hidden */
        private _dataMessage;
        /** @hidden */
        private _dataString;
        constructor();
        /**
        Gets the data buffer.
        */
        getDataBytes(): fm.liveswitch.DataBuffer;
        /** @hidden */
        getDataMessage(): fm.liveswitch.DataMessage;
        /**
        Gets the data string.
        */
        getDataString(): string;
        /**
        Gets the remote connection info.
        */
        getRemoteConnectionInfo(): fm.liveswitch.ConnectionInfo;
        /**
        Sets the data buffer.
        */
        setDataBytes(value: fm.liveswitch.DataBuffer): void;
        /** @hidden */
        setDataMessage(value: fm.liveswitch.DataMessage): void;
        /**
        Sets the data string.
        */
        setDataString(value: string): void;
        /** @hidden */
        setRemoteConnectionInfo(remoteConnectionInfo: Object): void;
    }
}
declare namespace fm.liveswitch {
    /**
    Data stream interface.
    */
    interface IDataStream<TDataChannel> extends fm.liveswitch.IStream {
        getChannels(): TDataChannel[];
        getInfo(): fm.liveswitch.DataStreamInfo;
    }
}
declare namespace fm.liveswitch.dtmf {
    /**
    A DTMF (telephone-event) format.
    */
    class Format extends fm.liveswitch.AudioFormat {
        getTypeString(): string;
        /**
        Initializes a new instance of the [[fm.liveswitch.dtmf.format]] class.
        */
        constructor();
        /**
        Initializes a new instance of the [[fm.liveswitch.dtmf.format]] class.
        @param clockRate The clock rate.
        */
        constructor(clockRate: number);
        /**
        Gets the default clock rate (8000).
        */
        static getDefaultClockRate(): number;
    }
}
declare namespace fm.liveswitch {
    class EncryptionPolicyWrapper {
        getTypeString(): string;
        /** @hidden */
        private _value;
        constructor(value: fm.liveswitch.EncryptionPolicy);
        toString(): string;
    }
}
declare namespace fm.liveswitch.g711 {
    /**
    A G.711 format.
    */
    abstract class Format extends fm.liveswitch.AudioFormat {
        getTypeString(): string;
        /**
        Initializes a new instance of the [[fm.liveswitch.g711.format]] class.
        @param name The name.
        @param clockRate The clock rate.
        @param channelCount The channel count.
        */
        constructor(name: string, clockRate: number, channelCount: number);
        /**
        Gets the default clock rate (1).
        */
        static getDefaultChannelCount(): number;
        /**
        Gets the default clock rate (8000).
        */
        static getDefaultClockRate(): number;
        /**
        Gets the default configuration (8000/1).
        */
        static getDefaultConfig(): fm.liveswitch.AudioConfig;
        /** @hidden */
        private getFixedBitrate;
        /**
        Gets the maximum bitrate supported by this format, in kbps.
        */
        getMaxBitrate(): number;
        /**
        Gets the minimum bitrate supported by this format, in kbps.
        */
        getMinBitrate(): number;
    }
}
declare namespace fm.liveswitch.h264 {
    /**
    An H.264 format.
    */
    class Format extends fm.liveswitch.VideoFormat {
        getTypeString(): string;
        /**
        Initializes a new instance of the [[fm.liveswitch.h264.format]] class.
        */
        constructor();
        /**
        Initializes a new instance of the [[fm.liveswitch.h264.format]] class.
        @param clockRate The clock rate.
        */
        constructor(clockRate: number);
        /**
        Initializes a new instance of the [[fm.liveswitch.h264.format]] class.
        @param clockRate The clock rate.
        @param packetizationMode The packetization mode.
        */
        constructor(clockRate: number, packetizationMode: number);
        /**
        Initializes a new instance of the [[fm.liveswitch.h264.format]] class.
        @param clockRate The clock rate.
        @param profile The profile.
        @param level The level.
        @param packetizationMode The packetization mode.
        */
        constructor(clockRate: number, profile: string, level: string, packetizationMode: number);
        /**
        Initializes a new instance of the [[fm.liveswitch.h264.format]] class.
        @param clockRate The clock rate.
        @param profileLevelId The profile level ID.
        @param packetizationMode The packetization mode.
        */
        constructor(clockRate: number, profileLevelId: fm.liveswitch.h264.ProfileLevelId, packetizationMode: number);
        /**
        Initializes a new instance of the [[fm.liveswitch.h264.format]] class.
        @param profile The profile.
        @param level The level.
        @param packetizationMode The packetization mode.
        */
        constructor(profile: string, level: string, packetizationMode: number);
        /**
        Initializes a new instance of the [[fm.liveswitch.h264.format]] class.
        @param profileLevelId The profile level ID.
        */
        constructor(profileLevelId: fm.liveswitch.h264.ProfileLevelId);
        /**
        Initializes a new instance of the [[fm.liveswitch.h264.format]] class.
        @param profileLevelId The profile level ID.
        @param packetizationMode The packetization mode.
        */
        constructor(profileLevelId: fm.liveswitch.h264.ProfileLevelId, packetizationMode: number);
        /**
        Creates a new instance.
        */
        protected createInstance(): fm.liveswitch.VideoFormat;
        /**
        Gets the maximum bitrate supported by this format, in kbps.
        */
        getMaxBitrate(): number;
        /**
        Gets the minimum bitrate supported by this format, in kbps.
        */
        getMinBitrate(): number;
    }
}
declare namespace fm.liveswitch.h264 {
    /**
    An H.264 Profile IOP.
    */
    class ProfileIop {
        getTypeString(): string;
        /** @hidden */
        private _dataBuffer;
        /**
        Initializes a new instance of the [[fm.liveswitch.h264.profileIop]] class.
        @param profileIop The profile IOP.
        */
        constructor(profileIop: number);
        /**
        Gets a value indicating whether constraint 0 is set.
        */
        getConstraintSet0(): boolean;
        /**
        Gets a value indicating whether constraint 1 is set.
        */
        getConstraintSet1(): boolean;
        /**
        Gets a value indicating whether constraint 2 is set.
        */
        getConstraintSet2(): boolean;
        /**
        Gets the backing data buffer.
        */
        getDataBuffer(): fm.liveswitch.DataBuffer;
        /**
        Sets a value indicating whether constraint 0 is set.
        */
        setConstraintSet0(value: boolean): void;
        /**
        Sets a value indicating whether constraint 1 is set.
        */
        setConstraintSet1(value: boolean): void;
        /**
        Sets a value indicating whether constraint 2 is set.
        */
        setConstraintSet2(value: boolean): void;
        /** @hidden */
        private setDataBuffer;
    }
}
declare namespace fm.liveswitch.h264 {
    /**
    An H.264 Profile Level ID.
    */
    class ProfileLevelId {
        getTypeString(): string;
        /** @hidden */
        private _levelIdc;
        /** @hidden */
        private _profileIdc;
        /** @hidden */
        private _profileIop;
        private fmliveswitchh264ProfileLevelIdInit;
        /**
        Initializes a new instance of the [[fm.liveswitch.h264.profileLevelId]] class.
        */
        constructor();
        /**
        Initializes a new instance of the [[fm.liveswitch.h264.profileLevelId]] class.
        @param profile The profile.
        @param level The level.
        */
        constructor(profile: string, level: string);
        /**
        Initializes a new instance of the [[fm.liveswitch.h264.profileLevelId]] class.
        @param profileIdc The profile ID code.
        @param profileIop The profile constraints.
        @param levelIdc The level ID code.
        */
        constructor(profileIdc: number, profileIop: number, levelIdc: number);
        /**
        Initializes a new instance of the [[fm.liveswitch.h264.profileLevelId]] class.
        @param profileLevelId The profile level identifier.
        */
        constructor(profileLevelId: string);
        /**
        Gets baseline profile level 1.0.
        */
        static getBaselineLevel10(): fm.liveswitch.h264.ProfileLevelId;
        /**
        Gets baseline profile level 3.1.
        */
        static getBaselineLevel31(): fm.liveswitch.h264.ProfileLevelId;
        /**
        Gets constrained baseline profile level 1.0.
        */
        static getConstrainedBaselineLevel10(): fm.liveswitch.h264.ProfileLevelId;
        /**
        Gets constrained baseline profile level 3.1.
        */
        static getConstrainedBaselineLevel31(): fm.liveswitch.h264.ProfileLevelId;
        /**
        Gets [[fm.liveswitch.h264.profileLevelId.constrainedBaselineLevel31]].
        */
        static getDefault(): fm.liveswitch.h264.ProfileLevelId;
        /**
        Gets high profile level 5.0.
        */
        static getHighLevel50(): fm.liveswitch.h264.ProfileLevelId;
        /**
        Gets main profile level 5.0.
        */
        static getMainLevel50(): fm.liveswitch.h264.ProfileLevelId;
        /**
        Gets the level.
        */
        getLevel(): string;
        /**
        Gets the level ID code.
        */
        getLevelIdc(): number;
        /**
        Gets the max encoding info value for the given level.
        @return EncodingInfo relating to the h264 profile level
        */
        getMaxEncoding(): fm.liveswitch.EncodingInfo;
        /**
        Gets the profile.
        */
        getProfile(): string;
        /**
        Gets the profile ID Code.
        */
        getProfileIdc(): number;
        /**
        Gets the profile constraints.
        */
        getProfileIop(): fm.liveswitch.h264.ProfileIop;
        /**
        Sets the level ID code.
        */
        setLevelIdc(value: number): void;
        /**
        Sets the profile ID Code.
        */
        setProfileIdc(value: number): void;
        /**
        Sets the profile constraints.
        */
        setProfileIop(value: fm.liveswitch.h264.ProfileIop): void;
        /**
        Returns a string that represents this instance.
        */
        toString(): string;
    }
}
declare namespace fm.liveswitch {
    class IceConnectionStateWrapper {
        getTypeString(): string;
        /** @hidden */
        private _value;
        constructor(value: fm.liveswitch.IceConnectionState);
        toString(): string;
    }
}
declare namespace fm.liveswitch {
    class IceGatheringStateWrapper {
        getTypeString(): string;
        /** @hidden */
        private _value;
        constructor(value: fm.liveswitch.IceGatheringState);
        toString(): string;
    }
}
declare namespace fm.liveswitch {
    class IceGatherPolicyWrapper {
        getTypeString(): string;
        /** @hidden */
        private _value;
        constructor(value: fm.liveswitch.IceGatherPolicy);
        toString(): string;
    }
}
declare namespace fm.liveswitch {
    /**
    An ICE server.
    */
    class IceServer {
        getTypeString(): string;
        /** @hidden */
        private __ipAddress;
        /** @hidden */
        private __ipAddresses;
        /** @hidden */
        private _password;
        /** @hidden */
        private _url;
        /** @hidden */
        private _username;
        constructor();
        /**
        Initializes a new instance of the [[fm.liveswitch.iceServer]] class.
        @param url The URL.
        */
        constructor(url: string);
        /**
        Initializes a new instance of the [[fm.liveswitch.iceServer]] class.
        @param url The URL.
        @param username The username.
        @param password The password.
        */
        constructor(url: string, username: string, password: string);
        /**
        Deserializes an instance from JSON.
        @param iceServerJson The JSON to deserialize.
        @return The deserialized ICE server.
        */
        static fromJson(iceServerJson: string): fm.liveswitch.IceServer;
        /**
        Deserializes an array of instances from JSON.
        @param iceServersJson The JSON to deserialize.
        @return The deserialized ICE server array.
        */
        static fromJsonArray(iceServersJson: string): fm.liveswitch.IceServer[];
        /**
        Gets the default non-secure port (in use for STUN and TURN).
        */
        static getDefaultPort(): number;
        /**
        Gets the default STUN port.
        */
        static getDefaultStunPort(): number;
        /**
        Gets the default STUNS port.
        */
        static getDefaultStunsPort(): number;
        /**
        Gets the default TURN port.
        */
        static getDefaultTurnPort(): number;
        /**
        Gets the default TURNS port.
        */
        static getDefaultTurnsPort(): number;
        /** @hidden */
        private static parseAddress;
        /** @hidden */
        private static parsePort;
        /**
        Serializes an instance to JSON.
        @param iceServer The ICE server.
        @return
                    The serialized JSON.
            
        */
        static toJson(iceServer: fm.liveswitch.IceServer): string;
        /**
        Serializes an array of instances to JSON.
        @param iceServers The ICE servers.
        @return
                    The serialized JSON.
            
        */
        static toJsonArray(iceServers: fm.liveswitch.IceServer[]): string;
        /**
        Gets the host.
        */
        getHost(): string;
        /** @hidden */
        getIPAddress(): string;
        /** @hidden */
        getIPAddresses(): string[];
        /**
        Gets a value indicating whether this represents a secure STUN or TURN server.
        */
        getIsSecure(): boolean;
        /**
        Gets a value indicating whether this represents a STUN server.
        */
        getIsStun(): boolean;
        /**
        Gets a value indicating whether this represents a TCP server.
        */
        getIsTcp(): boolean;
        /**
        Gets a value indicating whether this represents a TURN server.
        */
        getIsTurn(): boolean;
        /**
        Gets a value indicating whether this represents a UDP server.
        */
        getIsUdp(): boolean;
        /**
        Gets the password.
        */
        getPassword(): string;
        /**
        Gets the port.
        */
        getPort(): number;
        /**
        Gets the URL.
        */
        getUrl(): string;
        /**
        Gets the username.
        */
        getUsername(): string;
        /** @hidden */
        setIPAddress(value: string): void;
        /** @hidden */
        setIPAddresses(value: string[]): void;
        /** @hidden */
        private setPassword;
        /** @hidden */
        private setUrl;
        /** @hidden */
        private setUsername;
        /**
        Serializes this instance to JSON.
        @return
                    The serialized JSON.
            
        */
        toJson(): string;
    }
}
declare namespace fm.liveswitch {
    /**
    An ICE server collection.
    */
    class IceServerCollection extends fm.liveswitch.Collection<fm.liveswitch.IceServer, fm.liveswitch.IceServerCollection> {
        getTypeString(): string;
        constructor();
        /**
        Creates an array from a list.
        @param list The list.
        */
        protected arrayFromList(list: Array<fm.liveswitch.IceServer>): fm.liveswitch.IceServer[];
        /**
        Creates a collection.
        */
        protected createCollection(): fm.liveswitch.IceServerCollection;
    }
}
declare namespace fm.liveswitch {
    /**
    Media interface.
    */
    interface IMedia<TIAudioTrack extends fm.liveswitch.IAudioTrack, TIVideoTrack extends fm.liveswitch.IVideoTrack> {
        addOnAudioDestroyed(value: fm.liveswitch.IAction0): void;
        addOnAudioLevel(value: fm.liveswitch.IAction1<number>): void;
        addOnVideoDestroyed(value: fm.liveswitch.IAction0): void;
        addOnVideoSize(value: fm.liveswitch.IAction1<fm.liveswitch.Size>): void;
        destroy(): void;
        getAudioGain(): number;
        getAudioMuted(): boolean;
        getAudioTrack(): TIAudioTrack;
        getAudioTracks(): TIAudioTrack[];
        getAudioVolume(): number;
        getId(): string;
        getVideoMuted(): boolean;
        getVideoSize(): fm.liveswitch.Size;
        getVideoTrack(): TIVideoTrack;
        getVideoTracks(): TIVideoTrack[];
        grabVideoFrame(): fm.liveswitch.Future<fm.liveswitch.VideoBuffer>;
        removeOnAudioDestroyed(value: fm.liveswitch.IAction0): void;
        removeOnAudioLevel(value: fm.liveswitch.IAction1<number>): void;
        removeOnVideoDestroyed(value: fm.liveswitch.IAction0): void;
        removeOnVideoSize(value: fm.liveswitch.IAction1<fm.liveswitch.Size>): void;
        setAudioGain(value: number): void;
        setAudioMuted(value: boolean): void;
        setAudioVolume(value: number): void;
        setId(value: string): void;
        setVideoMuted(value: boolean): void;
    }
}
declare namespace fm.liveswitch {
    /**
    Local media interface.
    */
    interface ILocalMedia<TLocalMedia, TIAudioTrack extends fm.liveswitch.IAudioTrack, TIVideoTrack extends fm.liveswitch.IVideoTrack> extends fm.liveswitch.IMedia<TIAudioTrack, TIVideoTrack> {
        addOnAudioStarted(value: fm.liveswitch.IAction0): void;
        addOnAudioStopped(value: fm.liveswitch.IAction0): void;
        addOnVideoStarted(value: fm.liveswitch.IAction0): void;
        addOnVideoStopped(value: fm.liveswitch.IAction0): void;
        changeAudioSourceInput(audioSourceInput: fm.liveswitch.SourceInput): fm.liveswitch.Future<Object>;
        changeVideoSourceInput(videoSourceInput: fm.liveswitch.SourceInput): fm.liveswitch.Future<Object>;
        getAudioEncoding(): fm.liveswitch.AudioEncodingConfig;
        getAudioEncodings(): fm.liveswitch.AudioEncodingConfig[];
        getAudioSimulcastDisabled(): boolean;
        getAudioSimulcastEncodingCount(): number;
        getAudioSimulcastPreferredBitrate(): number;
        getAudioSourceInput(): fm.liveswitch.SourceInput;
        getAudioSourceInputs(): fm.liveswitch.Future<fm.liveswitch.SourceInput[]>;
        getState(): fm.liveswitch.LocalMediaState;
        getVideoEncoding(): fm.liveswitch.VideoEncodingConfig;
        getVideoEncodings(): fm.liveswitch.VideoEncodingConfig[];
        getVideoSimulcastBitsPerPixel(): number;
        getVideoSimulcastDegradationPreference(): fm.liveswitch.VideoDegradationPreference;
        getVideoSimulcastDisabled(): boolean;
        getVideoSimulcastEncodingCount(): number;
        getVideoSimulcastPreferredBitrate(): number;
        getVideoSourceInput(): fm.liveswitch.SourceInput;
        getVideoSourceInputs(): fm.liveswitch.Future<fm.liveswitch.SourceInput[]>;
        removeOnAudioStarted(value: fm.liveswitch.IAction0): void;
        removeOnAudioStopped(value: fm.liveswitch.IAction0): void;
        removeOnVideoStarted(value: fm.liveswitch.IAction0): void;
        removeOnVideoStopped(value: fm.liveswitch.IAction0): void;
        setAudioEncodings(value: fm.liveswitch.AudioEncodingConfig[]): void;
        setAudioSimulcastDisabled(value: boolean): void;
        setAudioSimulcastEncodingCount(value: number): void;
        setAudioSimulcastPreferredBitrate(value: number): void;
        setAudioSourceInput(value: fm.liveswitch.SourceInput): void;
        setVideoEncodings(value: fm.liveswitch.VideoEncodingConfig[]): void;
        setVideoSimulcastBitsPerPixel(value: number): void;
        setVideoSimulcastDegradationPreference(value: fm.liveswitch.VideoDegradationPreference): void;
        setVideoSimulcastDisabled(value: boolean): void;
        setVideoSimulcastEncodingCount(value: number): void;
        setVideoSimulcastPreferredBitrate(value: number): void;
        setVideoSourceInput(value: fm.liveswitch.SourceInput): void;
        start(): fm.liveswitch.Future<TLocalMedia>;
        stop(): fm.liveswitch.Future<TLocalMedia>;
    }
}
declare namespace fm.liveswitch {
    /**
    Viewable media interface.
    */
    interface IViewableMedia<TView> {
        getId(): string;
        getView(): TView;
    }
}
declare namespace fm.liveswitch {
    /**
    Viewable media interface with a view sink.
    */
    interface IViewSinkableMedia<TView, TViewSink extends fm.liveswitch.IViewSink<TView>> extends fm.liveswitch.IViewableMedia<TView> {
        getViewSink(): TViewSink;
    }
}
declare namespace fm.liveswitch {
    /**
    Remote media interface.
    */
    interface IRemoteMedia<TIAudioTrack extends fm.liveswitch.IAudioTrack, TIVideoTrack extends fm.liveswitch.IVideoTrack> extends fm.liveswitch.IMedia<TIAudioTrack, TIVideoTrack> {
        changeAudioSinkOutput(audioSinkOutput: fm.liveswitch.SinkOutput): fm.liveswitch.Future<Object>;
        changeVideoSinkOutput(videoSinkOutput: fm.liveswitch.SinkOutput): fm.liveswitch.Future<Object>;
        getAudioSinkOutput(): fm.liveswitch.SinkOutput;
        getAudioSinkOutputs(): fm.liveswitch.Future<fm.liveswitch.SinkOutput[]>;
        getVideoSinkOutput(): fm.liveswitch.SinkOutput;
        getVideoSinkOutputs(): fm.liveswitch.Future<fm.liveswitch.SinkOutput[]>;
        setAudioSinkOutput(value: fm.liveswitch.SinkOutput): void;
        setVideoSinkOutput(value: fm.liveswitch.SinkOutput): void;
    }
}
declare namespace fm.liveswitch {
    /**
    Video stream interface.
    */
    interface IVideoStream extends fm.liveswitch.IMediaStream, fm.liveswitch.IStream {
        addOnDiscardKeyFrameRequest(value: fm.liveswitch.IAction1<number[]>): void;
        getH264Disabled(): boolean;
        getH265Disabled(): boolean;
        getVp8Disabled(): boolean;
        getVp9Disabled(): boolean;
        raiseKeyFrameRequest(synchronizationSources: number[]): void;
        removeOnDiscardKeyFrameRequest(value: fm.liveswitch.IAction1<number[]>): void;
        setH264Disabled(value: boolean): void;
        setH265Disabled(value: boolean): void;
        setVp8Disabled(value: boolean): void;
        setVp9Disabled(value: boolean): void;
    }
}
declare namespace fm.liveswitch {
    /**
    Video track interface.
    */
    interface IVideoTrack extends fm.liveswitch.IMediaTrack {
        addOnSize(value: fm.liveswitch.IAction1<fm.liveswitch.Size>): void;
        getSize(): fm.liveswitch.Size;
        grabFrame(): fm.liveswitch.Future<fm.liveswitch.VideoBuffer>;
        removeOnSize(value: fm.liveswitch.IAction1<fm.liveswitch.Size>): void;
    }
}
declare namespace fm.liveswitch {
    /**
    A layout definition, including local and remote frame definitions.
    */
    class Layout {
        getTypeString(): string;
        /** @hidden */
        private __localFrame;
        /** @hidden */
        private __remoteFrames;
        /** @hidden */
        private _height;
        /** @hidden */
        private _origin;
        /** @hidden */
        private _width;
        private fmliveswitchLayoutInit;
        constructor();
        /**
        Gets all frames (local and remote).
        */
        getAllFrames(): fm.liveswitch.LayoutFrame[];
        /**
        Gets the layout height.
        */
        getHeight(): number;
        /**
        Gets the local frame.
        */
        getLocalFrame(): fm.liveswitch.LayoutFrame;
        /**
        Gets the layout origin.
        */
        getOrigin(): fm.liveswitch.LayoutOrigin;
        /**
        Gets the remote frames.
        */
        getRemoteFrames(): fm.liveswitch.LayoutFrame[];
        /**
        Gets the layout width.
        */
        getWidth(): number;
        /**
        Sets the layout height.
        */
        setHeight(value: number): void;
        /**
        Sets the local frame.
        */
        setLocalFrame(value: fm.liveswitch.LayoutFrame): void;
        /**
        Sets the layout origin.
        */
        setOrigin(value: fm.liveswitch.LayoutOrigin): void;
        /**
        Sets the remote frames.
        */
        setRemoteFrames(value: fm.liveswitch.LayoutFrame[]): void;
        /**
        Sets the layout width.
        */
        setWidth(value: number): void;
        /**
        Swaps the properties of two frames.
        @param frame1 The first frame.
        @param frame2 The second frame.
        */
        swapFrames(frame1: fm.liveswitch.LayoutFrame, frame2: fm.liveswitch.LayoutFrame): void;
        /**
        Swaps the local frame with a remote frame.
        @param remoteFrameIndex The index of the remote frame.
        */
        swapLocalFrame(remoteFrameIndex: number): void;
        /**
        Swaps two remote frames.
        @param remoteFrameIndex1 The index of the first remote frame.
        @param remoteFrameIndex2 The index of the second remote frame.
        */
        swapRemoteFrames(remoteFrameIndex1: number, remoteFrameIndex2: number): void;
    }
}
declare namespace fm.liveswitch {
    class LayoutAlignmentWrapper {
        getTypeString(): string;
        /** @hidden */
        private _value;
        constructor(value: fm.liveswitch.LayoutAlignment);
        toString(): string;
    }
}
declare namespace fm.liveswitch {
    class LayoutDirectionWrapper {
        getTypeString(): string;
        /** @hidden */
        private _value;
        constructor(value: fm.liveswitch.LayoutDirection);
        toString(): string;
    }
}
declare namespace fm.liveswitch {
    class LayoutModeWrapper {
        getTypeString(): string;
        /** @hidden */
        private _value;
        constructor(value: fm.liveswitch.LayoutMode);
        toString(): string;
    }
}
declare namespace fm.liveswitch {
    class LayoutOriginWrapper {
        getTypeString(): string;
        /** @hidden */
        private _value;
        constructor(value: fm.liveswitch.LayoutOrigin);
        toString(): string;
    }
}
declare namespace fm.liveswitch {
    /**
    Defines the results of a layout calculation.
    */
    class LayoutTable {
        getTypeString(): string;
        /** @hidden */
        private _cellHeight;
        /** @hidden */
        private _cellWidth;
        /** @hidden */
        private _columnCount;
        /** @hidden */
        private _rowCount;
        private fmliveswitchLayoutTableInit;
        /**
        Initializes a new instance of the [[fm.liveswitch.layoutTable]] class.
        @param columnCount The column count.
        @param rowCount The row count.
        @param cellWidth The width of each cell.
        @param cellHeight The height of each cell.
        */
        constructor(columnCount: number, rowCount: number, cellWidth: number, cellHeight: number);
        /**
        Gets the height of each cell.
        */
        getCellHeight(): number;
        /**
        Gets the width of each cell.
        */
        getCellWidth(): number;
        /**
        Gets the column count.
        */
        getColumnCount(): number;
        /**
        Gets the row count.
        */
        getRowCount(): number;
        /**
        Sets the height of each cell.
        */
        setCellHeight(value: number): void;
        /**
        Sets the width of each cell.
        */
        setCellWidth(value: number): void;
        /**
        Sets the column count.
        */
        setColumnCount(value: number): void;
        /**
        Sets the row count.
        */
        setRowCount(value: number): void;
    }
}
declare namespace fm.liveswitch {
    class LocalMediaStateWrapper {
        getTypeString(): string;
        /** @hidden */
        private _value;
        constructor(value: fm.liveswitch.LocalMediaState);
        toString(): string;
    }
}
declare namespace fm.liveswitch {
    /**
    A video buffer.
    */
    class VideoBuffer extends fm.liveswitch.MediaBuffer<fm.liveswitch.VideoFormat, fm.liveswitch.VideoBuffer> {
        getTypeString(): string;
        /** @hidden */
        private __height;
        /** @hidden */
        private __isMuted;
        /** @hidden */
        private __orientation;
        /** @hidden */
        private __width;
        /** @hidden */
        private _horizontallyMirrored;
        /** @hidden */
        private _strides;
        /** @hidden */
        private _verticallyMirrored;
        /** @hidden */
        private static fm_liveswitch_VideoBuffer___dataBufferPool;
        private fmliveswitchVideoBufferInit;
        /**
        Initializes a new instance of the [[fm.liveswitch.videoBuffer]] class.
        */
        constructor();
        /**
        Initializes a new instance of the [[fm.liveswitch.videoBuffer]] class.
        @param width The width.
        @param height The height.
        @param dataBuffer The data buffer.
        @param format The format.
        */
        constructor(width: number, height: number, dataBuffer: fm.liveswitch.DataBuffer, format: fm.liveswitch.VideoFormat);
        /**
        Initializes a new instance of the [[fm.liveswitch.videoBuffer]] class.
        @param width The width.
        @param height The height.
        @param dataBuffers The data buffers.
        @param format The format.
        */
        constructor(width: number, height: number, dataBuffers: fm.liveswitch.DataBuffer[], format: fm.liveswitch.VideoFormat);
        /**
        Initializes a new instance of the [[fm.liveswitch.videoBuffer]] class.
        @param width The width.
        @param height The height.
        @param stride The stride.
        @param dataBuffer The data buffer.
        @param format The format.
        */
        constructor(width: number, height: number, stride: number, dataBuffer: fm.liveswitch.DataBuffer, format: fm.liveswitch.VideoFormat);
        /**
        Initializes a new instance of the [[fm.liveswitch.videoBuffer]] class.
        @param width The width.
        @param height The height.
        @param strides The strides.
        @param dataBuffers The data buffers.
        @param format The format.
        */
        constructor(width: number, height: number, strides: number[], dataBuffers: fm.liveswitch.DataBuffer[], format: fm.liveswitch.VideoFormat);
        /** @hidden */
        private static calculateByteCount;
        /** @hidden */
        private static canPackWithoutCopy;
        /** @hidden */
        private static clamp;
        /**
        Creates a black (0, 0, 0) video buffer with the specified width/height.
        @param width The width.
        @param height The height.
        @param formatName Name of the format.
        */
        static createBlack(width: number, height: number, formatName: string): fm.liveswitch.VideoBuffer;
        /**
        Creates a blue (0, 0, 255) video buffer with the specified width/height.
        @param width The width.
        @param height The height.
        @param formatName Name of the format.
        */
        static createBlue(width: number, height: number, formatName: string): fm.liveswitch.VideoBuffer;
        /**
        Creates a custom video buffer with the specified width/height and red/green/blue values for the specified format name. If the format is not supported, returns null.
        @param width The width.
        @param height The height.
        @param red The red value.
        @param green The green value.
        @param blue The blue value.
        @param formatName Name of the format.
        */
        static createCustom(width: number, height: number, red: number, green: number, blue: number, formatName: string): fm.liveswitch.VideoBuffer;
        /**
        Creates a custom video buffer with the specified width/height and red/green/blue values for the specified format name. If the format is not supported, returns null.
        @param width The width.
        @param height The height.
        @param red The red value.
        @param green The green value.
        @param blue The blue value.
        @param formatName Name of the format.
        @param buffer The output data buffer.
        */
        static createCustom(width: number, height: number, red: number, green: number, blue: number, formatName: string, buffer: fm.liveswitch.DataBuffer): fm.liveswitch.VideoBuffer;
        /**
        Creates a cyan (0, 255, 255) video buffer with the specified width/height.
        @param width The width.
        @param height The height.
        @param formatName Name of the format.
        */
        static createCyan(width: number, height: number, formatName: string): fm.liveswitch.VideoBuffer;
        /**
        Creates a dark blue (0, 0, 128) video buffer with the specified width/height.
        @param width The width.
        @param height The height.
        @param formatName Name of the format.
        */
        static createDarkBlue(width: number, height: number, formatName: string): fm.liveswitch.VideoBuffer;
        /**
        Creates a dark green (0, 128, 0) video buffer with the specified width/height.
        @param width The width.
        @param height The height.
        @param formatName Name of the format.
        */
        static createDarkGreen(width: number, height: number, formatName: string): fm.liveswitch.VideoBuffer;
        /**
        Creates a dark red (128, 0, 0) video buffer with the specified width/height.
        @param width The width.
        @param height The height.
        @param formatName Name of the format.
        */
        static createDarkRed(width: number, height: number, formatName: string): fm.liveswitch.VideoBuffer;
        /**
        Creates a gray (255, 255, 255) video buffer with the specified width/height.
        @param width The width.
        @param height The height.
        @param formatName Name of the format.
        */
        static createGray(width: number, height: number, formatName: string): fm.liveswitch.VideoBuffer;
        /**
        Creates a green (0, 255, 0) video buffer with the specified width/height.
        @param width The width.
        @param height The height.
        @param formatName Name of the format.
        */
        static createGreen(width: number, height: number, formatName: string): fm.liveswitch.VideoBuffer;
        /**
        Creates a magenta (255, 0, 255) video buffer with the specified width/height.
        @param width The width.
        @param height The height.
        @param formatName Name of the format.
        */
        static createMagenta(width: number, height: number, formatName: string): fm.liveswitch.VideoBuffer;
        /**
        Creates an olive (128, 128, 0) video buffer with the specified width/height.
        @param width The width.
        @param height The height.
        @param formatName Name of the format.
        */
        static createOlive(width: number, height: number, formatName: string): fm.liveswitch.VideoBuffer;
        /**
        Creates a purple (128, 0, 128) video buffer with the specified width/height.
        @param width The width.
        @param height The height.
        @param formatName Name of the format.
        */
        static createPurple(width: number, height: number, formatName: string): fm.liveswitch.VideoBuffer;
        /**
        Creates a red (255, 0, 0) video buffer with the specified width/height.
        @param width The width.
        @param height The height.
        @param formatName Name of the format.
        */
        static createRed(width: number, height: number, formatName: string): fm.liveswitch.VideoBuffer;
        /**
        Creates a teal (0, 128, 128) video buffer with the specified width/height.
        @param width The width.
        @param height The height.
        @param formatName Name of the format.
        */
        static createTeal(width: number, height: number, formatName: string): fm.liveswitch.VideoBuffer;
        /**
        Creates a white (255, 255, 255) video buffer with the specified width/height.
        @param width The width.
        @param height The height.
        @param formatName Name of the format.
        */
        static createWhite(width: number, height: number, formatName: string): fm.liveswitch.VideoBuffer;
        /**
        Creates a yellow (255, 255, 0) video buffer with the specified width/height.
        @param width The width.
        @param height The height.
        @param formatName Name of the format.
        */
        static createYellow(width: number, height: number, formatName: string): fm.liveswitch.VideoBuffer;
        /**
        Deserializes an instance from JSON.
        @param videoBufferJson The video buffer JSON.
        */
        static fromJson(videoBufferJson: string): fm.liveswitch.VideoBuffer;
        /**
        Deserializes an array of instances from JSON.
        @param videoBuffersJson The video buffers JSON.
        */
        static fromJsonArray(videoBuffersJson: string): fm.liveswitch.VideoBuffer[];
        /**
        Gets the minimum data buffer length for a given width, height, and format.
        @param width The width.
        @param height The height.
        @param formatName Name of the format.
        */
        static getMinimumBufferLength(width: number, height: number, formatName: string): number;
        /**
        Serializes an instance to JSON.
        @param videoBuffer The video buffer.
        */
        static toJson(videoBuffer: fm.liveswitch.VideoBuffer): string;
        /**
        Serializes an array of instances to JSON.
        @param videoBuffers The video buffers.
        */
        static toJsonArray(videoBuffers: fm.liveswitch.VideoBuffer[]): string;
        /**
        Clones this instance.
        */
        clone(): fm.liveswitch.VideoBuffer;
        /**
        Creates a new video buffer using the specified format.
        @param format The format.
        */
        convert(format: fm.liveswitch.VideoFormat): fm.liveswitch.VideoBuffer;
        /**
        Creates a new video buffer using the specified format.
        @param format The format.
        @param dataBuffer The data buffer.
        */
        convert(format: fm.liveswitch.VideoFormat, dataBuffer: fm.liveswitch.DataBuffer): fm.liveswitch.VideoBuffer;
        /**
        Creates a new video buffer using the specified format.
        @param format The format.
        @param usePool Whether to use the DataBufferPool.
        */
        convert(format: fm.liveswitch.VideoFormat, usePool: boolean): fm.liveswitch.VideoBuffer;
        /** @hidden */
        private convertRgbaToYuv;
        /** @hidden */
        private convertYuvToRgba;
        /**
        Copy the transformation attributes from another video buffer.
        */
        copyTransformationAttributes(sourceBuffer: fm.liveswitch.VideoBuffer): void;
        /**
        Creates a new instance.
        */
        protected createInstance(): fm.liveswitch.VideoBuffer;
        /**
        Gets the A value at a given index. If the video buffer is not RGBA-type, then this will return 255.
        @param index The index.
        @return The A value.
        */
        getAValue(index: number): number;
        /** @hidden */
        private getAValueOffset;
        /**
        Gets the B value at a given index.
        @param index The index.
        @return The B value, or -1 if the video buffer is not RGB/RGBA-type.
        */
        getBValue(index: number): number;
        /** @hidden */
        private getBValueOffset;
        /** @hidden */
        private getDefaultStrides;
        /**
        Gets the G value at a given index.
        @param index The index.
        @return The G value, or -1 if the video buffer is not RGB/RGBA-type.
        */
        getGValue(index: number): number;
        /** @hidden */
        private getGValueOffset;
        /**
        Gets the height.
        */
        getHeight(): number;
        /**
        Gets whether this buffer should be mirrored over the X axis.
        */
        getHorizontallyMirrored(): boolean;
        /**
        Gets whether inversion is required to reset the mirroring of this buffer.
        */
        getInversionRequired(): boolean;
        /**
        Gets a value indicating whether this buffer has ABGR video.
        */
        getIsAbgr(): boolean;
        /**
        Gets a value indicating whether this buffer has ARGB video.
        */
        getIsArgb(): boolean;
        /**
        Gets a value indicating whether this buffer has BGR video.
        */
        getIsBgr(): boolean;
        /**
        Gets a value indicating whether this buffer has BGRA video.
        */
        getIsBgra(): boolean;
        /**
        Gets a value indicating whether this buffer has H.264 video.
        */
        getIsH264(): boolean;
        /**
        Gets a value indicating whether this buffer has H.265 video.
        */
        getIsH265(): boolean;
        /**
        Gets a value indicating whether this buffer has I420 video.
        */
        getIsI420(): boolean;
        /**
        Gets a value indicating whether this instance has been muted.
        */
        getIsMuted(): boolean;
        /**
        Gets a value indicating whether this buffer has NV12 video.
        */
        getIsNv12(): boolean;
        /**
        Gets a value indicating whether this buffer has NV21 video.
        */
        getIsNv21(): boolean;
        /**
        Gets a value indicating whether the data is packed into a single data buffer.
        */
        getIsPacked(): boolean;
        /**
        Gets a value indicating whether the data is spread across multiple data buffers (planes).
        */
        getIsPlanar(): boolean;
        /**
        Gets a value indicating whether this buffer has raw video.
        */
        getIsRaw(): boolean;
        /**
        Gets a value indicating whether this buffer has RGB video.
        */
        getIsRgb(): boolean;
        /**
        Gets a value indicating whether this buffer has RGBA video.
        */
        getIsRgba(): boolean;
        /**
        Gets a value indicating whether this buffer has raw RGBA, BGRA, ARGB, or ABGR video.
        */
        getIsRgbaType(): boolean;
        /**
        Gets a value indicating whether this buffer has raw RGB or BGR video.
        */
        getIsRgbType(): boolean;
        /**
        Gets a value indicating whether this buffer has VP8 video.
        */
        getIsVp8(): boolean;
        /**
        Gets a value indicating whether this buffer has VP9 video.
        */
        getIsVp9(): boolean;
        /**
        Gets a value indicating whether this buffer has raw I420, YV12, NV12, or NV21 video.
        */
        getIsYuvType(): boolean;
        /**
        Gets a value indicating whether this buffer has YV12 video.
        */
        getIsYv12(): boolean;
        /**
        Gets the desired orientation of the buffer.
        */
        getOrientation(): number;
        /**
        Gets whether rotation is required to reset the mirroring and orientation of this buffer.
        */
        getRotationRequired(): number;
        /**
        Gets the R value at a given index.
        @param index The index.
        @return The R value, or -1 if the video buffer is not RGB/RGBA-type.
        */
        getRValue(index: number): number;
        /** @hidden */
        private getRValueOffset;
        /**
        Gets the stride.
        */
        getStride(): number;
        /**
        Gets the strides.
        */
        getStrides(): number[];
        /**
        Gets a boolean value on whether the buffer needs to be transformed.
        */
        getTransformRequired(): boolean;
        /**
        Gets the U value at a given index.
        @param index The index.
        @return The U value, or -1 if the video buffer is not YUV-type.
        */
        getUValue(index: number): number;
        /** @hidden */
        private getUValueOffset;
        /**
        Gets whether this buffer should be mirrored over the Y axis.
        */
        getVerticallyMirrored(): boolean;
        /**
        Gets the V value at a given index.
        @param index The index.
        @return The V value, or -1 if the video buffer is not YUV-type.
        */
        getVValue(index: number): number;
        /** @hidden */
        private getVValueOffset;
        /**
        Gets the width.
        */
        getWidth(): number;
        /**
        Gets the Y value at a given index.
        @param index The index.
        @return The Y value, or -1 if the video buffer is not YUV-type.
        */
        getYValue(index: number): number;
        /** @hidden */
        private getYValueOffset;
        /**
        Mutes this instance. This is a one-way operation that clears the underlying data buffer.
        */
        mute(): boolean;
        /** @hidden */
        private readRgba;
        /** @hidden */
        private readYuv;
        /**
        Resets the transformation attributes back to default values.
        */
        resetTransformationAttributes(): void;
        /**
        Gets the A value at a given index. If the video buffer is not RGBA-type, then this will return false.
        @param aValue The A value.
        @param index The index.
        @return `true` if the video buffer is RGBA-type.
        */
        setAValue(aValue: number, index: number): boolean;
        /**
        Gets the B value at a given index.
        @param bValue The B value.
        @param index The index.
        @return `true` if the video buffer is RGB/RGBA-type.
        */
        setBValue(bValue: number, index: number): boolean;
        /**
        Sets the G value at a given index.
        @param gValue The G value.
        @param index The index.
        @return `true` if the video buffer is RGB/RGBA-type.
        */
        setGValue(gValue: number, index: number): boolean;
        /**
        Sets the height.
        */
        setHeight(value: number): void;
        /**
        Sets whether this buffer should be mirrored over the X axis.
        */
        setHorizontallyMirrored(value: boolean): void;
        /** @hidden */
        setIsMuted(value: boolean): void;
        /**
        Sets the desired orientation of the buffer.
        */
        setOrientation(value: number): void;
        /**
        Sets the R value at a given index.
        @param rValue The R value.
        @param index The index.
        @return `true` if the video buffer is RGB/RGBA-type.
        */
        setRValue(rValue: number, index: number): boolean;
        /**
        Sets the stride.
        */
        setStride(value: number): void;
        /**
        Sets the strides.
        */
        setStrides(value: number[]): void;
        /**
        Sets the U value at a given index.
        @param uValue The U value.
        @param index The index.
        @return `true` if the video buffer is YUV-type.
        */
        setUValue(uValue: number, index: number): boolean;
        /**
        Sets whether this buffer should be mirrored over the Y axis.
        */
        setVerticallyMirrored(value: boolean): void;
        /**
        Sets the V value at a given index.
        @param vValue The V value.
        @param index The index.
        @return `true` if the video buffer is YUV-type.
        */
        setVValue(vValue: number, index: number): boolean;
        /**
        Sets the width.
        */
        setWidth(value: number): void;
        /**
        Sets the Y value at a given index.
        @param yValue The Y value.
        @param index The index.
        @return `true` if the video buffer is YUV-type.
        */
        setYValue(yValue: number, index: number): boolean;
        /**
        Serializes this instance to JSON.
        */
        toJson(): string;
        /**
        Creates a packed representation of this planar buffer, if in YUV-planar format. Otherwise, returns the current buffer. If the planar data is not contiguous in memory, new memory will be allocated for the packed representation.
        */
        toPacked(): fm.liveswitch.VideoBuffer;
        /**
        Creates a packed representation of this planar buffer, if in YUV-planar format. Otherwise, returns the current buffer. If the planar data is not contiguous in memory, new memory will be allocated or taken from the data buffer pool for the packed representation.
        @param usePool Whether to use the data buffer pool for any required memory allocations.
        */
        toPacked(usePool: boolean): fm.liveswitch.VideoBuffer;
        /**
        Creates a planar representation of this packed buffer, if in YUV-packed format. Otherwise, returns the current buffer.
        */
        toPlanar(): fm.liveswitch.VideoBuffer;
        /** @hidden */
        private writeRgba;
        /** @hidden */
        private writeYuv;
        /** @hidden */
        private static __fmliveswitchVideoBufferInitialized;
        /** @hidden */
        private static __fmliveswitchVideoBufferInitializing;
        /** @hidden */
        static fmliveswitchVideoBufferInitialize(): void;
    }
}
declare namespace fm.liveswitch {
    /** @hidden */
    class RemoteCandidatePromise extends fm.liveswitch.Promise<fm.liveswitch.Candidate> {
        getTypeString(): string;
        /** @hidden */
        private _remoteCandidate;
        constructor(remoteCandidate: fm.liveswitch.Candidate);
        getRemoteCandidate(): fm.liveswitch.Candidate;
        /** @hidden */
        private setRemoteCandidate;
    }
}
declare namespace fm.liveswitch {
    /**
    A collection of remote medias.
    */
    class RemoteMediaCollection extends fm.liveswitch.Collection<fm.liveswitch.RemoteMedia, fm.liveswitch.RemoteMediaCollection> {
        getTypeString(): string;
        /** @hidden */
        private __lookup;
        /** @hidden */
        private __lookupLock;
        constructor();
        /**
        Invoked when an element is added to the collection.
        @param value The value.
        */
        protected addSuccess(value: fm.liveswitch.RemoteMedia): void;
        /**
        Creates an array from a list.
        @param list The list.
        */
        protected arrayFromList(list: Array<fm.liveswitch.RemoteMedia>): fm.liveswitch.RemoteMedia[];
        /**
        Creates a collection.
        */
        protected createCollection(): fm.liveswitch.RemoteMediaCollection;
        /**
        Gets a media by ID.
        @param idValue The identifier.
        */
        getById(idValue: string): fm.liveswitch.RemoteMedia;
        /**
        Invoked when an element is removed from the collection.
        @param value The value.
        */
        protected removeSuccess(value: fm.liveswitch.RemoteMedia): void;
    }
}
declare namespace fm.liveswitch {
    /**
    A collection of remote medias.
    */
    class MediaCollection extends fm.liveswitch.RemoteMediaCollection {
        getTypeString(): string;
        constructor();
    }
}
declare namespace fm.liveswitch {
    class NackPolicyWrapper {
        getTypeString(): string;
        /** @hidden */
        private _value;
        constructor(value: fm.liveswitch.NackPolicy);
        toString(): string;
    }
}
declare namespace fm.liveswitch.opus {
    /**
    An Opus format.
    */
    class Format extends fm.liveswitch.AudioFormat {
        getTypeString(): string;
        /**
        Initializes a new instance of the [[fm.liveswitch.opus.format]] class.
        */
        constructor();
        /**
        Initializes a new instance of the [[fm.liveswitch.opus.format]] class.
        @param clockRate The clock rate.
        @param channelCount The channel count.
        */
        constructor(clockRate: number, channelCount: number);
        /**
        Initializes a new instance of the [[fm.liveswitch.opus.format]] class.
        @param config The configuration.
        */
        constructor(config: fm.liveswitch.AudioConfig);
        /**
        Gets the default clock rate (2).
        */
        static getDefaultChannelCount(): number;
        /**
        Gets the default clock rate (48000).
        */
        static getDefaultClockRate(): number;
        /**
        Gets the default configuration (48000/2).
        */
        static getDefaultConfig(): fm.liveswitch.AudioConfig;
        /**
        Creates a new instance.
        */
        protected createInstance(): fm.liveswitch.AudioFormat;
        /**
        Gets the maximum bitrate supported by this format, in kbps.
        */
        getMaxBitrate(): number;
        /**
        Gets the minimum bitrate supported by this format, in kbps.
        */
        getMinBitrate(): number;
    }
}
declare namespace fm.liveswitch.pcma {
    /**
    A PCMA (G.711a) format.
    */
    class Format extends fm.liveswitch.g711.Format {
        getTypeString(): string;
        /**
        Initializes a new instance of the [[fm.liveswitch.pcma.format]] class.
        */
        constructor();
        /**
        Initializes a new instance of the [[fm.liveswitch.pcma.format]] class.
        @param clockRate The clock rate.
        @param channelCount The channel count.
        */
        constructor(clockRate: number, channelCount: number);
        /**
        Initializes a new instance of the [[fm.liveswitch.pcma.format]] class.
        @param config The configuration.
        */
        constructor(config: fm.liveswitch.AudioConfig);
        /**
        Creates a new instance.
        */
        protected createInstance(): fm.liveswitch.AudioFormat;
    }
}
declare namespace fm.liveswitch.pcmu {
    /**
    A PCMU (G.711u) format.
    */
    class Format extends fm.liveswitch.g711.Format {
        getTypeString(): string;
        /**
        Initializes a new instance of the [[fm.liveswitch.pcmu.format]] class.
        */
        constructor();
        /**
        Initializes a new instance of the [[fm.liveswitch.pcmu.format]] class.
        @param clockRate The clock rate.
        @param channelCount The channel count.
        */
        constructor(clockRate: number, channelCount: number);
        /**
        Initializes a new instance of the [[fm.liveswitch.pcmu.format]] class.
        @param config The configuration.
        */
        constructor(config: fm.liveswitch.AudioConfig);
        /**
        Creates a new instance.
        */
        protected createInstance(): fm.liveswitch.AudioFormat;
    }
}
declare namespace fm.liveswitch {
    class RedFecPolicyWrapper {
        getTypeString(): string;
        /** @hidden */
        private _value;
        constructor(value: fm.liveswitch.RedFecPolicy);
        toString(): string;
    }
}
declare namespace fm.liveswitch {
    class RembPolicyWrapper {
        getTypeString(): string;
        /** @hidden */
        private _value;
        constructor(value: fm.liveswitch.RembPolicy);
        toString(): string;
    }
}
declare namespace fm.liveswitch {
    /**
    An RTP packet header.
    */
    class RtpPacketHeader {
        getTypeString(): string;
        /** @hidden */
        private __headerExtension;
        /** @hidden */
        private _contributingSourceCount;
        /** @hidden */
        private _contributingSources;
        /** @hidden */
        private _extension;
        /** @hidden */
        private _marker;
        /** @hidden */
        private _padding;
        /** @hidden */
        private _paddingLength;
        /** @hidden */
        private _payloadType;
        /** @hidden */
        private _sequenceNumber;
        /** @hidden */
        private _synchronizationSource;
        /** @hidden */
        private _timestamp;
        /** @hidden */
        private _version;
        private fmliveswitchRtpPacketHeaderInit;
        /**
        Creates a new instance of the [[fm.liveswitch.rtpPacketHeader]] class.
        */
        constructor();
        /**
        Gets the length of the fixed header.
        */
        static getFixedHeaderLength(): number;
        /**
        Calculates the length of the header. At least 12 bytes.
        */
        calculateHeaderLength(): number;
        /**
        Clones this instance.
        */
        clone(): fm.liveswitch.RtpPacketHeader;
        /**
        Gets the number of contributing sources.
        */
        getContributingSourceCount(): number;
        /**
        Gets the contributing sources.
        */
        getContributingSources(): number[];
        /**
        Gets if there is an extension.
        */
        getExtension(): boolean;
        /**
        Gets the header extension.
        */
        getHeaderExtension(): fm.liveswitch.IRtpHeaderExtension;
        /**
        Gets if the marker bit is set.
        */
        getMarker(): boolean;
        /**
        Gets if the packet has padding.
        */
        getPadding(): boolean;
        /**
        Gets the number of bytes of padding.
        */
        getPaddingLength(): number;
        /**
        Gets the payload type.
        */
        getPayloadType(): number;
        /**
        Gets the sequence number.
        */
        getSequenceNumber(): number;
        /**
        Gets the synchronization source.
        */
        getSynchronizationSource(): number;
        /**
        Gets the timestamp.
        */
        getTimestamp(): number;
        /**
        Gets the version of the packet. Should be 2.
        */
        getVersion(): number;
        /**
        Sets the number of contributing sources.
        */
        setContributingSourceCount(value: number): void;
        /**
        Sets the contributing sources.
        */
        setContributingSources(value: number[]): void;
        /** @hidden */
        private setExtension;
        /**
        Sets the header extension.
        */
        setHeaderExtension(value: fm.liveswitch.IRtpHeaderExtension): void;
        /**
        Sets if the marker bit is set.
        */
        setMarker(value: boolean): void;
        /**
        Sets if the packet has padding.
        */
        setPadding(value: boolean): void;
        /** @hidden */
        private setPaddingLength;
        /**
        Sets the payload type.
        */
        setPayloadType(value: number): void;
        /**
        Sets the sequence number.
        */
        setSequenceNumber(value: number): void;
        /**
        Sets the synchronization source.
        */
        setSynchronizationSource(value: number): void;
        /**
        Sets the timestamp.
        */
        setTimestamp(value: number): void;
        /**
        Sets the version of the packet. Should be 2.
        */
        setVersion(value: number): void;
        /**
        Writes this header to a buffer starting at the offset.
        @param buffer The target buffer.
        @param offset The starting offset.
        */
        writeTo(buffer: fm.liveswitch.DataBuffer, offset: number): void;
    }
}
declare namespace fm.liveswitch {
    /**
    The interface that all rtp header extensions must implement.
    */
    interface IRtpHeaderExtension {
        fillBuffer(buffer: fm.liveswitch.DataBuffer, offset: number): void;
        getId(): Uint8Array;
        getLength(): number;
    }
}
declare namespace fm.liveswitch.rtp {
    /** @hidden */
    class HeaderExtensionFormWrapper {
        getTypeString(): string;
        /** @hidden */
        private _value;
        constructor(value: fm.liveswitch.rtp.HeaderExtensionForm);
        toString(): string;
    }
}
declare namespace fm.liveswitch.rtp {
    /** @hidden */
    class RawHeaderExtension implements fm.liveswitch.IRtpHeaderExtension {
        getTypeString(): string;
        /** @hidden */
        private _appBits;
        /** @hidden */
        private _form;
        /** @hidden */
        private _id;
        /** @hidden */
        private _payload;
        private fmliveswitchrtpRawHeaderExtensionInit;
        constructor(idValue: Uint8Array, payload: Uint8Array);
        fillBuffer(buffer: fm.liveswitch.DataBuffer, offset: number): void;
        getAppBits(): number;
        getForm(): fm.liveswitch.rtp.HeaderExtensionForm;
        getId(): Uint8Array;
        getLength(): number;
        getPayload(): Uint8Array;
        /** @hidden */
        private setAppBits;
        /** @hidden */
        private setForm;
        /** @hidden */
        private setId;
        /** @hidden */
        private setPayload;
    }
}
declare namespace fm.liveswitch {
    class SdesPolicyWrapper {
        getTypeString(): string;
        /** @hidden */
        private _value;
        constructor(value: fm.liveswitch.SdesPolicy);
        toString(): string;
    }
}
declare namespace fm.liveswitch {
    class SignallingStateWrapper {
        getTypeString(): string;
        /** @hidden */
        private _value;
        constructor(value: fm.liveswitch.SignallingState);
        toString(): string;
    }
}
declare namespace fm.liveswitch {
    /**
    A sink output (e.g. device, track, screen).
    */
    class SinkOutput {
        getTypeString(): string;
        /** @hidden */
        private _id;
        /** @hidden */
        private _name;
        constructor();
        /**
        Initializes a new instance of the [[fm.liveswitch.sinkOutput]] class.
        @param idValue The identifier.
        @param name The name.
        */
        constructor(idValue: string, name: string);
        /**
        Deserializes an instance from JSON.
        @param sinkOutputJson The sink output JSON.
        */
        static fromJson(sinkOutputJson: string): fm.liveswitch.SinkOutput;
        /**
        Deserializes an instance array from JSON.
        @param sinkOutputsJson The sink outputs JSON.
        */
        static fromJsonArray(sinkOutputsJson: string): fm.liveswitch.SinkOutput[];
        /**
        Serializes an instance to JSON.
        @param sinkOutput The sink output.
        */
        static toJson(sinkOutput: fm.liveswitch.SinkOutput): string;
        /**
        Serializes an instance array to JSON.
        @param sinkOutputs The sink outputs.
        */
        static toJsonArray(sinkOutputs: fm.liveswitch.SinkOutput[]): string;
        /**
        Gets the identifier.
        */
        getId(): string;
        /**
        Gets the name.
        */
        getName(): string;
        /** @hidden */
        private setId;
        /** @hidden */
        private setName;
        /**
        Serializes this instance to JSON.
        */
        toJson(): string;
        /**
        Returns a string that represents this instance.
        @return
                    A string that represents this instance.
            
        */
        toString(): string;
    }
}
declare namespace fm.liveswitch {
    /**
    A source input (e.g. device, track, screen).
    */
    class SourceInput {
        getTypeString(): string;
        /** @hidden */
        private _id;
        /** @hidden */
        private _name;
        constructor();
        /**
        Initializes a new instance of the [[fm.liveswitch.sourceInput]] class.
        @param idValue The identifier.
        @param name The name.
        */
        constructor(idValue: string, name: string);
        /**
        Deserializes an instance from JSON.
        @param sourceInputJson The source input JSON.
        */
        static fromJson(sourceInputJson: string): fm.liveswitch.SourceInput;
        /**
        Deserializes an instance array from JSON.
        @param sourceInputsJson The source inputs JSON.
        */
        static fromJsonArray(sourceInputsJson: string): fm.liveswitch.SourceInput[];
        /**
        Serializes an instance to JSON.
        @param sourceInput The source input.
        */
        static toJson(sourceInput: fm.liveswitch.SourceInput): string;
        /**
        Serializes an instance array to JSON.
        @param sourceInputs The source inputs.
        */
        static toJsonArray(sourceInputs: fm.liveswitch.SourceInput[]): string;
        /**
        Gets the identifier.
        */
        getId(): string;
        /**
        Gets the name.
        */
        getName(): string;
        /**
        Sets the identifier.
        */
        setId(value: string): void;
        /**
        Sets the name.
        */
        setName(value: string): void;
        /**
        Serializes this instance to JSON.
        */
        toJson(): string;
        /**
        Returns a string that represents this instance.
        @return
                    A string that represents this instance.
            
        */
        toString(): string;
    }
}
declare namespace fm.liveswitch {
    /**
    A stream collection.
    */
    class StreamCollection extends fm.liveswitch.Collection<fm.liveswitch.WebRtcStream, fm.liveswitch.StreamCollection> {
        getTypeString(): string;
        constructor();
        /**
        Creates an array from a list.
        @param list The list.
        */
        protected arrayFromList(list: Array<fm.liveswitch.WebRtcStream>): fm.liveswitch.WebRtcStream[];
        /**
        Creates a collection.
        */
        protected createCollection(): fm.liveswitch.StreamCollection;
        /**
        Gets a stream by its type.
        */
        getByType<T extends fm.liveswitch.WebRtcStream>(type: fm.liveswitch.StreamType): T;
        /**
        Gets some streams by their type.
        */
        getManyByType<T extends fm.liveswitch.WebRtcStream>(type: fm.liveswitch.StreamType): Array<T>;
    }
}
declare namespace fm.liveswitch {
    /** @hidden */
    class TransportTypeWrapper {
        getTypeString(): string;
        /** @hidden */
        private _value;
        constructor(value: fm.liveswitch.TransportType);
        toString(): string;
    }
}
declare namespace fm.liveswitch {
    class TrickleIcePolicyWrapper {
        getTypeString(): string;
        /** @hidden */
        private _value;
        constructor(value: fm.liveswitch.TrickleIcePolicy);
        toString(): string;
    }
}
declare namespace fm.liveswitch {
    /** @hidden */
    class VideoUtility {
        getTypeString(): string;
        constructor();
        static getBitrate(pixelCount: number, frameRate: number, bitsPerPixel: number): number;
        static getBitrate(preferredBitrate: number, width: number, height: number, frameRate: number, bitsPerPixel: number): number;
        static getBitratePowerScale(): number;
        static getEncodingConfig(degradationPreference: fm.liveswitch.VideoDegradationPreference, multiplier: number, frameRate: number): fm.liveswitch.VideoEncodingConfig;
        static getPixelCount(bitrate: number, frameRate: number, bitsPerPixel: number): number;
        static processDegradationPreference(degradationPreference: fm.liveswitch.VideoDegradationPreference, type: fm.liveswitch.VideoType): fm.liveswitch.VideoDegradationPreference;
        static updateEncodingConfig(encodingConfig: fm.liveswitch.VideoEncodingConfig, degradationPreference: fm.liveswitch.VideoDegradationPreference, multiplier: number, frameRate: number): void;
    }
}
declare namespace fm.liveswitch.vp8 {
    /**
    A VP8 format.
    */
    class Format extends fm.liveswitch.VideoFormat {
        getTypeString(): string;
        /**
        Initializes a new instance of the [[fm.liveswitch.vp8.format]] class.
        */
        constructor();
        /**
        Initializes a new instance of the [[fm.liveswitch.vp8.format]] class.
        @param clockRate The clock rate.
        */
        constructor(clockRate: number);
        /**
        Creates a new instance.
        */
        protected createInstance(): fm.liveswitch.VideoFormat;
        /**
        Gets the maximum bitrate supported by this format, in kbps.
        */
        getMaxBitrate(): number;
        /**
        Gets the minimum bitrate supported by this format, in kbps.
        */
        getMinBitrate(): number;
    }
}
declare namespace fm.liveswitch.vp9 {
    /**
    A VP9 format.
    */
    class Format extends fm.liveswitch.VideoFormat {
        getTypeString(): string;
        /**
        Initializes a new instance of the [[fm.liveswitch.vp9.format]] class.
        */
        constructor();
        /**
        Initializes a new instance of the [[fm.liveswitch.vp9.format]] class.
        @param clockRate The clock rate.
        */
        constructor(clockRate: number);
        /**
        Creates a new instance.
        */
        protected createInstance(): fm.liveswitch.VideoFormat;
        /**
        Gets the maximum bitrate supported by this format, in kbps.
        */
        getMaxBitrate(): number;
        /**
        Gets the minimum bitrate supported by this format, in kbps.
        */
        getMinBitrate(): number;
    }
}
declare namespace fm.liveswitch {
    /**
    A channel.
    */
    class Channel extends fm.liveswitch.Dynamic {
        getTypeString(): string;
        /** @hidden */
        private __channelQueue;
        /** @hidden */
        private __connectionFactory;
        /** @hidden */
        private __deferredLayout;
        /** @hidden */
        private __deferredLayoutTimestamp;
        /** @hidden */
        private __doSend;
        /** @hidden */
        private __invitations;
        /** @hidden */
        private __lastVideoLayoutTimestamp;
        /** @hidden */
        private __left;
        /** @hidden */
        private __lock;
        /** @hidden */
        private __messageBytesReceived;
        /** @hidden */
        private __messageBytesSent;
        /** @hidden */
        private __messagesReceived;
        /** @hidden */
        private __messagesSent;
        /** @hidden */
        private __onClaimUpdate;
        /** @hidden */
        private __onClientMessage;
        /** @hidden */
        private __onDeviceMessage;
        /** @hidden */
        private __onKick;
        /** @hidden */
        private __onMcuVideoLayout;
        /** @hidden */
        private __onMessage;
        /** @hidden */
        private __onPeerConnectionOffer;
        /** @hidden */
        private __onRemoteClientJoin;
        /** @hidden */
        private __onRemoteClientLeave;
        /** @hidden */
        private __onRemoteClientUpdate;
        /** @hidden */
        private __onRemoteUpstreamConnectionClose;
        /** @hidden */
        private __onRemoteUpstreamConnectionOpen;
        /** @hidden */
        private __onRemoteUpstreamConnectionUpdate;
        /** @hidden */
        private __onUserMessage;
        /** @hidden */
        private __peerConnectionOffers;
        /** @hidden */
        private __remoteClientInfos;
        /** @hidden */
        private __remoteUpstreamConnectionInfos;
        /** @hidden */
        private _applicationId;
        /** @hidden */
        private _claim;
        /** @hidden */
        private _clientId;
        /** @hidden */
        private _clientRoles;
        /** @hidden */
        private _clientTag;
        /** @hidden */
        private _connections;
        /** @hidden */
        private _deviceAlias;
        /** @hidden */
        private _deviceId;
        /** @hidden */
        private _id;
        /** @hidden */
        private _onClaimUpdate;
        /** @hidden */
        private _onClientMessage;
        /** @hidden */
        private _onDeviceMessage;
        /** @hidden */
        private _onKick;
        /** @hidden */
        private _onMcuVideoLayout;
        /** @hidden */
        private _onMessage;
        /** @hidden */
        private _onPeerConnectionOffer;
        /** @hidden */
        private _onRemoteClientJoin;
        /** @hidden */
        private _onRemoteClientLeave;
        /** @hidden */
        private _onRemoteClientUpdate;
        /** @hidden */
        private _onRemoteUpstreamConnectionClose;
        /** @hidden */
        private _onRemoteUpstreamConnectionOpen;
        /** @hidden */
        private _onRemoteUpstreamConnectionUpdate;
        /** @hidden */
        private _onUserMessage;
        /** @hidden */
        private _userAlias;
        /** @hidden */
        private _userId;
        /** @hidden */
        private static fm_liveswitch_Channel___log;
        private fmliveswitchChannelInit;
        /** @hidden */
        constructor(sharedLock: Object, connectionFactory: fm.liveswitch.ConnectionFactory, applicationId: string, userId: string, userAlias: string, deviceId: string, deviceAlias: string, clientId: string, clientTag: string, clientRoles: string[], idValue: string, doSend: fm.liveswitch.IFunction1<fm.liveswitch.Message, fm.liveswitch.Future<fm.liveswitch.Message>>);
        /**
        Adds a handler that is raised when the client's channel claim has been updated. Parameters: - oldConnectionInfo - the old channel claim - newConnectionInfo - the new channel claim
        */
        addOnClaimUpdate(value: fm.liveswitch.IAction2<fm.liveswitch.ChannelClaim, fm.liveswitch.ChannelClaim>): void;
        /**
        Adds a handler that is raised when a channel/client-scope message is received from the server. Parameters: - clientInfo - the sending client information - message - the message
        */
        addOnClientMessage(value: fm.liveswitch.IAction2<fm.liveswitch.ClientInfo, string>): void;
        /**
        Adds a handler that is raised when a channel/device-scope message is received from the server. Parameters: - clientInfo - the sending client information - message - the message
        */
        addOnDeviceMessage(value: fm.liveswitch.IAction2<fm.liveswitch.ClientInfo, string>): void;
        /**
        Adds a handler that is raised when the client is kicked from the channel.
        */
        addOnKick(value: fm.liveswitch.IAction0): void;
        /**
        Adds a handler that is raised when a new MCU video layout is received from the server. Parameters: - videoLayout - the new MCU video layout
        */
        addOnMcuVideoLayout(value: fm.liveswitch.IAction1<fm.liveswitch.VideoLayout>): void;
        /**
        Adds a handler that is raised when a channel-scope message is received from the server. Parameters: - clientInfo - the sending client information - message - the message
        */
        addOnMessage(value: fm.liveswitch.IAction2<fm.liveswitch.ClientInfo, string>): void;
        /**
        Adds a handler that is raised when a remote client wants to open a peer connection. Parameters: - peerConnectionOffer - the peer connection offer
        */
        addOnPeerConnectionOffer(value: fm.liveswitch.IAction1<fm.liveswitch.PeerConnectionOffer>): void;
        /**
        Adds a handler that is raised when a remote client joins this channel. Parameters: - clientInfo - the remote client information
        */
        addOnRemoteClientJoin(value: fm.liveswitch.IAction1<fm.liveswitch.ClientInfo>): void;
        /**
        Adds a handler that is raised when a remote client leaves this channel. Parameters: - clientInfo - the remote client information
        */
        addOnRemoteClientLeave(value: fm.liveswitch.IAction1<fm.liveswitch.ClientInfo>): void;
        /**
        Adds a handler that is raised when a remote client updates their config. Parameters: - oldClientInfo - the old remote client information - newClientInfo - the new remote client information
        */
        addOnRemoteClientUpdate(value: fm.liveswitch.IAction2<fm.liveswitch.ClientInfo, fm.liveswitch.ClientInfo>): void;
        /**
        Adds a handler that is raised when a remote upstream (SFU or MCU) connection is closed by a remote client. Parameters: - connectionInfo - the remote connection information
        */
        addOnRemoteUpstreamConnectionClose(value: fm.liveswitch.IAction1<fm.liveswitch.ConnectionInfo>): void;
        /**
        Adds a handler that is raised when a remote upstream (SFU or MCU) connection is opened by a remote client. Parameters: - connectionInfo - the remote connection information
        */
        addOnRemoteUpstreamConnectionOpen(value: fm.liveswitch.IAction1<fm.liveswitch.ConnectionInfo>): void;
        /**
        Adds a handler that is raised when a remote upstream (SFU or MCU) connection is updated by a remote client. Parameters: - oldConnectionInfo - the old remote connection information - newConnectionInfo - the new remote connection information
        */
        addOnRemoteUpstreamConnectionUpdate(value: fm.liveswitch.IAction2<fm.liveswitch.ConnectionInfo, fm.liveswitch.ConnectionInfo>): void;
        /**
        Adds a handler that is raised when a channel/user-scope message is received from the server. Parameters: - clientInfo - the sending client information - message - the message
        */
        addOnUserMessage(value: fm.liveswitch.IAction2<fm.liveswitch.ClientInfo, string>): void;
        /**
        Closes all active connections.
        */
        closeAll(): fm.liveswitch.Future<Object>;
        /**
        Creates an audio-only MCU connection.
        @param audioStream The audio stream.
        */
        createMcuConnection(audioStream: fm.liveswitch.AudioStream): fm.liveswitch.McuConnection;
        /**
        Creates an audio/data MCU connection.
        @param audioStream The audio stream.
        @param dataStream The data stream.
        */
        createMcuConnection(audioStream: fm.liveswitch.AudioStream, dataStream: fm.liveswitch.DataStream): fm.liveswitch.McuConnection;
        /**
        Creates an audio/data MCU connection with a specific media identifier that can be targeted by SFU downstream connections. The media identifer is only relevant if this connection will send media.
        @param audioStream The audio stream.
        @param dataStream The data stream.
        @param mediaId The media identifier, unique to this channel, for persistent SFU downstream connections.
        */
        createMcuConnection(audioStream: fm.liveswitch.AudioStream, dataStream: fm.liveswitch.DataStream, mediaId: string): fm.liveswitch.McuConnection;
        /**
        Creates an audio-only MCU connection with a specific media identifier that can be targeted by SFU downstream connections. The media identifer is only relevant if this connection will send media.
        @param audioStream The audio stream.
        @param mediaId The media identifier, unique to this channel, for persistent SFU downstream connections.
        */
        createMcuConnection(audioStream: fm.liveswitch.AudioStream, mediaId: string): fm.liveswitch.McuConnection;
        /**
        Creates an audio/video MCU connection.
        @param audioStream The audio stream.
        @param videoStream The video stream.
        */
        createMcuConnection(audioStream: fm.liveswitch.AudioStream, videoStream: fm.liveswitch.VideoStream): fm.liveswitch.McuConnection;
        /**
        Creates an audio/video/data MCU connection.
        @param audioStream The audio stream.
        @param videoStream The video stream.
        @param dataStream The data stream.
        */
        createMcuConnection(audioStream: fm.liveswitch.AudioStream, videoStream: fm.liveswitch.VideoStream, dataStream: fm.liveswitch.DataStream): fm.liveswitch.McuConnection;
        /**
        Creates an audio/video MCU connection with a specific media identifier that can be targeted by SFU downstream connections. The media identifer is only relevant if this connection will send media.
        @param audioStream The audio stream.
        @param videoStream The video stream.
        @param dataStream The data stream.
        @param mediaId The media identifier, unique to this channel, for persistent SFU downstream connections.
        */
        createMcuConnection(audioStream: fm.liveswitch.AudioStream, videoStream: fm.liveswitch.VideoStream, dataStream: fm.liveswitch.DataStream, mediaId: string): fm.liveswitch.McuConnection;
        /**
        Creates an audio/video MCU connection with a specific media identifier that can be targeted by SFU downstream connections. The media identifer is only relevant if this connection will send media.
        @param audioStream The audio stream.
        @param videoStream The video stream.
        @param mediaId The media identifier, unique to this channel, for persistent SFU downstream connections.
        */
        createMcuConnection(audioStream: fm.liveswitch.AudioStream, videoStream: fm.liveswitch.VideoStream, mediaId: string): fm.liveswitch.McuConnection;
        /**
        Creates a data-only MCU connection.
        @param dataStream The data stream.
        */
        createMcuConnection(dataStream: fm.liveswitch.DataStream): fm.liveswitch.McuConnection;
        /**
        Creates a data-only MCU connection with a specific media identifier that can be targeted by SFU downstream connections. The media identifer is only relevant if this connection will send media.
        @param dataStream The data stream.
        @param mediaId The media identifier, unique to this channel, for persistent SFU downstream connections.
        */
        createMcuConnection(dataStream: fm.liveswitch.DataStream, mediaId: string): fm.liveswitch.McuConnection;
        /**
        Creates a video-only MCU connection.
        @param videoStream The video stream.
        */
        createMcuConnection(videoStream: fm.liveswitch.VideoStream): fm.liveswitch.McuConnection;
        /**
        Creates a video/data MCU connection.
        @param videoStream The video stream.
        @param dataStream The data stream.
        */
        createMcuConnection(videoStream: fm.liveswitch.VideoStream, dataStream: fm.liveswitch.DataStream): fm.liveswitch.McuConnection;
        /**
        Creates a video/data MCU connection with a specific media identifier that can be targeted by SFU downstream connections. The media identifer is only relevant if this connection will send media.
        @param videoStream The video stream.
        @param dataStream The data stream.
        @param mediaId The media identifier, unique to this channel, for persistent SFU downstream connections.
        */
        createMcuConnection(videoStream: fm.liveswitch.VideoStream, dataStream: fm.liveswitch.DataStream, mediaId: string): fm.liveswitch.McuConnection;
        /**
        Creates a video-only MCU connection with a specific media identifier that can be targeted by SFU downstream connections. The media identifer is only relevant if this connection will send media.
        @param videoStream The video stream.
        @param mediaId The media identifier, unique to this channel, for persistent SFU downstream connections.
        */
        createMcuConnection(videoStream: fm.liveswitch.VideoStream, mediaId: string): fm.liveswitch.McuConnection;
        /**
        Creates an audio-only peer connection in the answering role.
        @param peerConnectionOffer The peer connection offer.
        @param audioStream The audio stream.
        */
        createPeerConnection(peerConnectionOffer: fm.liveswitch.PeerConnectionOffer, audioStream: fm.liveswitch.AudioStream): fm.liveswitch.PeerConnection;
        /**
        Creates an audio/data peer connection in the answering role.
        @param peerConnectionOffer The peer connection offer.
        @param audioStream The audio stream.
        @param dataStream The data stream.
        */
        createPeerConnection(peerConnectionOffer: fm.liveswitch.PeerConnectionOffer, audioStream: fm.liveswitch.AudioStream, dataStream: fm.liveswitch.DataStream): fm.liveswitch.PeerConnection;
        /**
        Creates an audio/video peer connection in the answering role.
        @param peerConnectionOffer The peer connection offer.
        @param audioStream The audio stream.
        @param videoStream The video stream.
        */
        createPeerConnection(peerConnectionOffer: fm.liveswitch.PeerConnectionOffer, audioStream: fm.liveswitch.AudioStream, videoStream: fm.liveswitch.VideoStream): fm.liveswitch.PeerConnection;
        /**
        Creates an audio/video/data peer connection in the answering role.
        @param peerConnectionOffer The peer connection offer.
        @param audioStream The audio stream.
        @param videoStream The video stream.
        @param dataStream The data stream.
        */
        createPeerConnection(peerConnectionOffer: fm.liveswitch.PeerConnectionOffer, audioStream: fm.liveswitch.AudioStream, videoStream: fm.liveswitch.VideoStream, dataStream: fm.liveswitch.DataStream): fm.liveswitch.PeerConnection;
        /**
        Creates a data-only peer connection in the answering role.
        @param peerConnectionOffer The peer connection offer.
        @param dataStream The data stream.
        */
        createPeerConnection(peerConnectionOffer: fm.liveswitch.PeerConnectionOffer, dataStream: fm.liveswitch.DataStream): fm.liveswitch.PeerConnection;
        /**
        Creates a video-only peer connection in the answering role.
        @param peerConnectionOffer The peer connection offer.
        @param videoStream The video stream.
        */
        createPeerConnection(peerConnectionOffer: fm.liveswitch.PeerConnectionOffer, videoStream: fm.liveswitch.VideoStream): fm.liveswitch.PeerConnection;
        /**
        Creates a video/data peer connection in the answering role.
        @param peerConnectionOffer The peer connection offer.
        @param videoStream The video stream.
        @param dataStream The data stream.
        */
        createPeerConnection(peerConnectionOffer: fm.liveswitch.PeerConnectionOffer, videoStream: fm.liveswitch.VideoStream, dataStream: fm.liveswitch.DataStream): fm.liveswitch.PeerConnection;
        /**
        Creates an audio-only peer connection in the offering role.
        @param remoteClientInfo The remote client information.
        @param audioStream The audio stream.
        */
        createPeerConnection(remoteClientInfo: fm.liveswitch.ClientInfo, audioStream: fm.liveswitch.AudioStream): fm.liveswitch.PeerConnection;
        /**
        Creates an audio/data peer connection in the offering role.
        @param remoteClientInfo The remote client information.
        @param audioStream The audio stream.
        @param dataStream The data stream.
        */
        createPeerConnection(remoteClientInfo: fm.liveswitch.ClientInfo, audioStream: fm.liveswitch.AudioStream, dataStream: fm.liveswitch.DataStream): fm.liveswitch.PeerConnection;
        /**
        Creates an audio/video peer connection in the offering role.
        @param remoteClientInfo The remote client information.
        @param audioStream The audio stream.
        @param videoStream The video stream.
        */
        createPeerConnection(remoteClientInfo: fm.liveswitch.ClientInfo, audioStream: fm.liveswitch.AudioStream, videoStream: fm.liveswitch.VideoStream): fm.liveswitch.PeerConnection;
        /**
        Creates an audio/video/data peer connection in the offering role.
        @param remoteClientInfo The remote client information.
        @param audioStream The audio stream.
        @param videoStream The video stream.
        @param dataStream The data stream.
        */
        createPeerConnection(remoteClientInfo: fm.liveswitch.ClientInfo, audioStream: fm.liveswitch.AudioStream, videoStream: fm.liveswitch.VideoStream, dataStream: fm.liveswitch.DataStream): fm.liveswitch.PeerConnection;
        /**
        Creates a data-only peer connection in the offering role.
        @param remoteClientInfo The remote client information.
        @param dataStream The data stream.
        */
        createPeerConnection(remoteClientInfo: fm.liveswitch.ClientInfo, dataStream: fm.liveswitch.DataStream): fm.liveswitch.PeerConnection;
        /**
        Creates a video-only peer connection in the offering role.
        @param remoteClientInfo The remote client information.
        @param videoStream The video stream.
        */
        createPeerConnection(remoteClientInfo: fm.liveswitch.ClientInfo, videoStream: fm.liveswitch.VideoStream): fm.liveswitch.PeerConnection;
        /**
        Creates a video/data peer connection in the offering role.
        @param remoteClientInfo The remote client information.
        @param videoStream The video stream.
        @param dataStream The data stream.
        */
        createPeerConnection(remoteClientInfo: fm.liveswitch.ClientInfo, videoStream: fm.liveswitch.VideoStream, dataStream: fm.liveswitch.DataStream): fm.liveswitch.PeerConnection;
        /**
        Creates an audio-only SFU downstream connection to the SFU or MCU upstream connection identified by the remote connection info.
        @param remoteConnectionInfo The remote connection information.
        @param audioStream The audio stream.
        */
        createSfuDownstreamConnection(remoteConnectionInfo: fm.liveswitch.ConnectionInfo, audioStream: fm.liveswitch.AudioStream): fm.liveswitch.SfuDownstreamConnection;
        /**
        Creates an audio/data SFU downstream connection.
        @param remoteConnectionInfo The remote connection information.
        @param audioStream The audio stream.
        @param dataStream The data stream.
        */
        createSfuDownstreamConnection(remoteConnectionInfo: fm.liveswitch.ConnectionInfo, audioStream: fm.liveswitch.AudioStream, dataStream: fm.liveswitch.DataStream): fm.liveswitch.SfuDownstreamConnection;
        /**
        Creates an audio/video SFU downstream connection to the SFU or MCU upstream connection identified by the remote connection info.
        @param remoteConnectionInfo The remote connection information.
        @param audioStream The audio stream.
        @param videoStream The video stream.
        */
        createSfuDownstreamConnection(remoteConnectionInfo: fm.liveswitch.ConnectionInfo, audioStream: fm.liveswitch.AudioStream, videoStream: fm.liveswitch.VideoStream): fm.liveswitch.SfuDownstreamConnection;
        /**
        Creates an audio/video/data SFU downstream connection.
        @param remoteConnectionInfo The remote connection information.
        @param audioStream The audio stream.
        @param videoStream The video stream.
        @param dataStream The data stream.
        */
        createSfuDownstreamConnection(remoteConnectionInfo: fm.liveswitch.ConnectionInfo, audioStream: fm.liveswitch.AudioStream, videoStream: fm.liveswitch.VideoStream, dataStream: fm.liveswitch.DataStream): fm.liveswitch.SfuDownstreamConnection;
        /**
        Creates a data-only SFU downstream connection.
        @param remoteConnectionInfo The remote connection information.
        @param dataStream The data stream.
        */
        createSfuDownstreamConnection(remoteConnectionInfo: fm.liveswitch.ConnectionInfo, dataStream: fm.liveswitch.DataStream): fm.liveswitch.SfuDownstreamConnection;
        /**
        Creates a video-only SFU downstream connection to the SFU or MCU upstream connection identified by the remote connection info.
        @param remoteConnectionInfo The remote connection information.
        @param videoStream The video stream.
        */
        createSfuDownstreamConnection(remoteConnectionInfo: fm.liveswitch.ConnectionInfo, videoStream: fm.liveswitch.VideoStream): fm.liveswitch.SfuDownstreamConnection;
        /**
        Creates a video/data SFU downstream connection.
        @param remoteConnectionInfo The remote connection information.
        @param videoStream The video stream.
        @param dataStream The data stream.
        */
        createSfuDownstreamConnection(remoteConnectionInfo: fm.liveswitch.ConnectionInfo, videoStream: fm.liveswitch.VideoStream, dataStream: fm.liveswitch.DataStream): fm.liveswitch.SfuDownstreamConnection;
        /**
        Creates an audio-only SFU downstream connection to the SFU or MCU upstream connection with the remote media identifier.
        @param remoteMediaId The remote media identifier.
        @param audioStream The audio stream.
        */
        createSfuDownstreamConnection(remoteMediaId: string, audioStream: fm.liveswitch.AudioStream): fm.liveswitch.SfuDownstreamConnection;
        /**
        Creates an audio/data SFU downstream connection.
        @param remoteMediaId The remote media identifier.
        @param audioStream The audio stream.
        @param dataStream The data stream.
        */
        createSfuDownstreamConnection(remoteMediaId: string, audioStream: fm.liveswitch.AudioStream, dataStream: fm.liveswitch.DataStream): fm.liveswitch.SfuDownstreamConnection;
        /**
        Creates an audio/video SFU downstream connection.
        @param remoteMediaId The remote media identifier.
        @param audioStream The audio stream.
        @param videoStream The video stream.
        */
        createSfuDownstreamConnection(remoteMediaId: string, audioStream: fm.liveswitch.AudioStream, videoStream: fm.liveswitch.VideoStream): fm.liveswitch.SfuDownstreamConnection;
        /**
        Creates an audio/video/data SFU downstream connection.
        @param remoteMediaId The remote media identifier.
        @param audioStream The audio stream.
        @param videoStream The video stream.
        @param dataStream The data stream.
        */
        createSfuDownstreamConnection(remoteMediaId: string, audioStream: fm.liveswitch.AudioStream, videoStream: fm.liveswitch.VideoStream, dataStream: fm.liveswitch.DataStream): fm.liveswitch.SfuDownstreamConnection;
        /**
        Creates a data-only SFU downstream connection.
        @param remoteMediaId The remote media identifier.
        @param dataStream The data stream.
        */
        createSfuDownstreamConnection(remoteMediaId: string, dataStream: fm.liveswitch.DataStream): fm.liveswitch.SfuDownstreamConnection;
        /**
        Creates a video-only SFU downstream connection.
        @param remoteMediaId The remote media identifier.
        @param videoStream The video stream.
        */
        createSfuDownstreamConnection(remoteMediaId: string, videoStream: fm.liveswitch.VideoStream): fm.liveswitch.SfuDownstreamConnection;
        /**
        Creates a video/data SFU downstream connection.
        @param remoteMediaId The remote media identifier.
        @param videoStream The audio stream.
        @param dataStream The data stream.
        */
        createSfuDownstreamConnection(remoteMediaId: string, videoStream: fm.liveswitch.VideoStream, dataStream: fm.liveswitch.DataStream): fm.liveswitch.SfuDownstreamConnection;
        /**
        Creates an audio-only SFU upstream connection.
        @param audioStream The audio stream.
        */
        createSfuUpstreamConnection(audioStream: fm.liveswitch.AudioStream): fm.liveswitch.SfuUpstreamConnection;
        /**
        Creates an audio/data SFU upstream connection.
        @param audioStream The audio stream.
        @param dataStream The data stream.
        */
        createSfuUpstreamConnection(audioStream: fm.liveswitch.AudioStream, dataStream: fm.liveswitch.DataStream): fm.liveswitch.SfuUpstreamConnection;
        /**
        Creates an audio/data SFU upstream connection with a specific media identifier that can be targeted by SFU downstream connections.
        @param audioStream The audio stream.
        @param dataStream The data stream.
        @param mediaId The media identifier, unique to this channel, for persistent SFU downstream connections.
        */
        createSfuUpstreamConnection(audioStream: fm.liveswitch.AudioStream, dataStream: fm.liveswitch.DataStream, mediaId: string): fm.liveswitch.SfuUpstreamConnection;
        /**
        Creates an audio-only SFU upstream connection with a specific media identifier that can be targeted by SFU downstream connections.
        @param audioStream The audio stream.
        @param mediaId The media identifier, unique to this channel, for persistent SFU downstream connections.
        */
        createSfuUpstreamConnection(audioStream: fm.liveswitch.AudioStream, mediaId: string): fm.liveswitch.SfuUpstreamConnection;
        /**
        Creates an audio/video SFU upstream connection.
        @param audioStream The audio stream.
        @param videoStream The video stream.
        */
        createSfuUpstreamConnection(audioStream: fm.liveswitch.AudioStream, videoStream: fm.liveswitch.VideoStream): fm.liveswitch.SfuUpstreamConnection;
        /**
        Creates an audio/video/data SFU upstream connection.
        @param audioStream The audio stream.
        @param videoStream The video stream.
        @param dataStream The data stream.
        */
        createSfuUpstreamConnection(audioStream: fm.liveswitch.AudioStream, videoStream: fm.liveswitch.VideoStream, dataStream: fm.liveswitch.DataStream): fm.liveswitch.SfuUpstreamConnection;
        /**
        Creates an audio/video SFU upstream connection with a specific media identifier that can be targeted by SFU downstream connections.
        @param audioStream The audio stream.
        @param videoStream The video stream.
        @param dataStream The video stream.
        @param mediaId The media identifier, unique to this channel, for persistent SFU downstream connections.
        */
        createSfuUpstreamConnection(audioStream: fm.liveswitch.AudioStream, videoStream: fm.liveswitch.VideoStream, dataStream: fm.liveswitch.DataStream, mediaId: string): fm.liveswitch.SfuUpstreamConnection;
        /**
        Creates an audio/video SFU upstream connection with a specific media identifier that can be targeted by SFU downstream connections.
        @param audioStream The audio stream.
        @param videoStream The video stream.
        @param mediaId The media identifier, unique to this channel, for persistent SFU downstream connections.
        */
        createSfuUpstreamConnection(audioStream: fm.liveswitch.AudioStream, videoStream: fm.liveswitch.VideoStream, mediaId: string): fm.liveswitch.SfuUpstreamConnection;
        /**
        Creates a data-only SFU upstream connection.
        @param dataStream The data stream.
        */
        createSfuUpstreamConnection(dataStream: fm.liveswitch.DataStream): fm.liveswitch.SfuUpstreamConnection;
        /**
        Creates a data-only SFU upstream connection with a specific media identifier that can be targeted by SFU downstream connections.
        @param dataStream The data stream.
        @param mediaId The media identifier, unique to this channel, for persistent SFU downstream connections.
        */
        createSfuUpstreamConnection(dataStream: fm.liveswitch.DataStream, mediaId: string): fm.liveswitch.SfuUpstreamConnection;
        /**
        Creates a video-only SFU upstream connection.
        @param videoStream The video stream.
        */
        createSfuUpstreamConnection(videoStream: fm.liveswitch.VideoStream): fm.liveswitch.SfuUpstreamConnection;
        /**
        Creates a video/data SFU upstream connection.
        @param videoStream The video stream.
        @param dataStream The data stream.
        */
        createSfuUpstreamConnection(videoStream: fm.liveswitch.VideoStream, dataStream: fm.liveswitch.DataStream): fm.liveswitch.SfuUpstreamConnection;
        /**
        Creates a video/data SFU upstream connection with a specific media identifier that can be targeted by SFU downstream connections.
        @param videoStream The video stream.
        @param dataStream The data stream.
        @param mediaId The media identifier, unique to this channel, for persistent SFU downstream connections.
        */
        createSfuUpstreamConnection(videoStream: fm.liveswitch.VideoStream, dataStream: fm.liveswitch.DataStream, mediaId: string): fm.liveswitch.SfuUpstreamConnection;
        /**
        Creates a video-only SFU upstream connection with a specific media identifier that can be targeted by SFU downstream connections.
        @param videoStream The video stream.
        @param mediaId The media identifier, unique to this channel, for persistent SFU downstream connections.
        */
        createSfuUpstreamConnection(videoStream: fm.liveswitch.VideoStream, mediaId: string): fm.liveswitch.SfuUpstreamConnection;
        /** @hidden */
        private doInvite;
        /** @hidden */
        private doKickClient;
        /** @hidden */
        private doSimpleSend;
        /** @hidden */
        private doUpdate;
        /**
        Gets the application identifier.
        */
        getApplicationId(): string;
        /**
        Gets the claim.
        */
        getClaim(): fm.liveswitch.ChannelClaim;
        /**
        Gets the client identifier.
        */
        getClientId(): string;
        /**
        Gets the client roles.
        */
        getClientRoles(): string[];
        /**
        Gets the client tag.
        */
        getClientTag(): string;
        /**
        Gets the active connections.
        */
        getConnections(): fm.liveswitch.ManagedConnectionCollection;
        /**
        Gets the device alias.
        */
        getDeviceAlias(): string;
        /**
        Gets the device identifier.
        */
        getDeviceId(): string;
        /** @hidden */
        private getEquivalentRemoteClientInfo;
        /** @hidden */
        private getEquivalentRemoteUpstreamConnectionInfo;
        /**
        Gets the channel identifier.
        */
        getId(): string;
        /**
        Gets the number of message bytes received.
        */
        getMessageBytesReceived(): number;
        /**
        Gets the number of message bytes sent.
        */
        getMessageBytesSent(): number;
        /**
        Gets the number of messages received.
        */
        getMessagesReceived(): number;
        /**
        Gets the number of messages sent.
        */
        getMessagesSent(): number;
        /**
        Gets information about a remote client.
        @param clientId The client identifier.
        */
        getRemoteClientInfo(clientId: string): fm.liveswitch.ClientInfo;
        /**
        Gets information about the remote client in this channel.
        */
        getRemoteClientInfos(): fm.liveswitch.ClientInfo[];
        /**
        Gets information about a remote connection.
        @param connectionId The connection identifier.
        */
        getRemoteConnectionInfo(connectionId: string): fm.liveswitch.ConnectionInfo;
        /**
        Gets information about the remote upstream (SFU or MCU) connections opened by remote clients in this channel.
        */
        getRemoteUpstreamConnectionInfos(): fm.liveswitch.ConnectionInfo[];
        /** @hidden */
        getReport(): fm.liveswitch.ChannelReport;
        /**
        Gets the user alias.
        */
        getUserAlias(): string;
        /**
        Gets the user identifier.
        */
        getUserId(): string;
        /**
        Invites a user into this channel.
        @param userId The user id to invite.
        @param protocol The protocol to use for the invite.
        */
        invite(userId: string, protocol: string): fm.liveswitch.Future<fm.liveswitch.Invitation>;
        /**
        Kicks a client from this channel if the kick permission is enabled.
        @param remoteClientInfo The remote client to kick.
        */
        kickClient(remoteClientInfo: fm.liveswitch.ClientInfo): fm.liveswitch.Future<Object>;
        /** @hidden */
        leave(): void;
        /** @hidden */
        private processAnswer;
        /** @hidden */
        private processBitrateNotification;
        /** @hidden */
        private processBitrateRequest;
        /** @hidden */
        private processCandidate;
        /** @hidden */
        private processClientUpdate;
        /** @hidden */
        private processClose;
        /** @hidden */
        processConnectionMessages(message: fm.liveswitch.Message): boolean;
        /** @hidden */
        private processConnectionStateChange;
        /** @hidden */
        private processError;
        /** @hidden */
        private processFail;
        /** @hidden */
        private processInviteFeedback;
        /** @hidden */
        private processKeyFrameRequest;
        /** @hidden */
        processMessageAsync(message: fm.liveswitch.Message): void;
        /** @hidden */
        private processMessageForLocalConnection;
        /** @hidden */
        private processMessageForRemoteConnection;
        /** @hidden */
        processMessageSync(message: fm.liveswitch.Message): void;
        /** @hidden */
        private processMessageType;
        /** @hidden */
        private processNotifyJoin;
        /** @hidden */
        private processNotifyLeave;
        /** @hidden */
        private processNotifyUpstreamClose;
        /** @hidden */
        private processNotifyUpstreamOpen;
        /** @hidden */
        private processNotifyUpstreamUpdate;
        /** @hidden */
        private processOffer;
        /** @hidden */
        private processReject;
        /** @hidden */
        private processVideoLayout;
        /**
        Rejects a peer connection offer.
        @param peerConnectionOffer The peer connection offer.
        */
        rejectPeerConnection(peerConnectionOffer: fm.liveswitch.PeerConnectionOffer): fm.liveswitch.Future<Object>;
        /**
        Removes a handler that is raised when the client's channel claim has been updated. Parameters: - oldConnectionInfo - the old channel claim - newConnectionInfo - the new channel claim
        */
        removeOnClaimUpdate(value: fm.liveswitch.IAction2<fm.liveswitch.ChannelClaim, fm.liveswitch.ChannelClaim>): void;
        /**
        Removes a handler that is raised when a channel/client-scope message is received from the server. Parameters: - clientInfo - the sending client information - message - the message
        */
        removeOnClientMessage(value: fm.liveswitch.IAction2<fm.liveswitch.ClientInfo, string>): void;
        /**
        Removes a handler that is raised when a channel/device-scope message is received from the server. Parameters: - clientInfo - the sending client information - message - the message
        */
        removeOnDeviceMessage(value: fm.liveswitch.IAction2<fm.liveswitch.ClientInfo, string>): void;
        /**
        Removes a handler that is raised when the client is kicked from the channel.
        */
        removeOnKick(value: fm.liveswitch.IAction0): void;
        /**
        Removes a handler that is raised when a new MCU video layout is received from the server. Parameters: - videoLayout - the new MCU video layout
        */
        removeOnMcuVideoLayout(value: fm.liveswitch.IAction1<fm.liveswitch.VideoLayout>): void;
        /**
        Removes a handler that is raised when a channel-scope message is received from the server. Parameters: - clientInfo - the sending client information - message - the message
        */
        removeOnMessage(value: fm.liveswitch.IAction2<fm.liveswitch.ClientInfo, string>): void;
        /**
        Removes a handler that is raised when a remote client wants to open a peer connection. Parameters: - peerConnectionOffer - the peer connection offer
        */
        removeOnPeerConnectionOffer(value: fm.liveswitch.IAction1<fm.liveswitch.PeerConnectionOffer>): void;
        /**
        Removes a handler that is raised when a remote client joins this channel. Parameters: - clientInfo - the remote client information
        */
        removeOnRemoteClientJoin(value: fm.liveswitch.IAction1<fm.liveswitch.ClientInfo>): void;
        /**
        Removes a handler that is raised when a remote client leaves this channel. Parameters: - clientInfo - the remote client information
        */
        removeOnRemoteClientLeave(value: fm.liveswitch.IAction1<fm.liveswitch.ClientInfo>): void;
        /**
        Removes a handler that is raised when a remote client updates their config. Parameters: - oldClientInfo - the old remote client information - newClientInfo - the new remote client information
        */
        removeOnRemoteClientUpdate(value: fm.liveswitch.IAction2<fm.liveswitch.ClientInfo, fm.liveswitch.ClientInfo>): void;
        /**
        Removes a handler that is raised when a remote upstream (SFU or MCU) connection is closed by a remote client. Parameters: - connectionInfo - the remote connection information
        */
        removeOnRemoteUpstreamConnectionClose(value: fm.liveswitch.IAction1<fm.liveswitch.ConnectionInfo>): void;
        /**
        Removes a handler that is raised when a remote upstream (SFU or MCU) connection is opened by a remote client. Parameters: - connectionInfo - the remote connection information
        */
        removeOnRemoteUpstreamConnectionOpen(value: fm.liveswitch.IAction1<fm.liveswitch.ConnectionInfo>): void;
        /**
        Removes a handler that is raised when a remote upstream (SFU or MCU) connection is updated by a remote client. Parameters: - oldConnectionInfo - the old remote connection information - newConnectionInfo - the new remote connection information
        */
        removeOnRemoteUpstreamConnectionUpdate(value: fm.liveswitch.IAction2<fm.liveswitch.ConnectionInfo, fm.liveswitch.ConnectionInfo>): void;
        /**
        Removes a handler that is raised when a channel/user-scope message is received from the server. Parameters: - clientInfo - the sending client information - message - the message
        */
        removeOnUserMessage(value: fm.liveswitch.IAction2<fm.liveswitch.ClientInfo, string>): void;
        /** @hidden */
        send(message: fm.liveswitch.Message): fm.liveswitch.Future<fm.liveswitch.Message>;
        /**
        Sends a message to a client in the channel.
        @param message The message to be sent.
        @param userId The user identifier.
        @param deviceId The device identifier.
        @param clientId The client identifier.
        */
        sendClientMessage(userId: string, deviceId: string, clientId: string, message: string): fm.liveswitch.Future<Object>;
        /**
        Sends a message to a device in the channel.
        @param message The message to be sent.
        @param userId The user identifier.
        @param deviceId The device identifier.
        */
        sendDeviceMessage(userId: string, deviceId: string, message: string): fm.liveswitch.Future<Object>;
        /**
        Sends a message to the channel.
        @param message The message to be sent.
        */
        sendMessage(message: string): fm.liveswitch.Future<Object>;
        /**
        Sends a message to a user in the channel.
        @param userId The user identifier.
        @param message The message.
        */
        sendUserMessage(userId: string, message: string): fm.liveswitch.Future<Object>;
        /** @hidden */
        private setApplicationId;
        /** @hidden */
        private setClaim;
        /** @hidden */
        private setClientId;
        /** @hidden */
        private setClientRoles;
        /** @hidden */
        private setClientTag;
        /** @hidden */
        private setConnections;
        /** @hidden */
        private setDeviceAlias;
        /** @hidden */
        private setDeviceId;
        /** @hidden */
        private setId;
        /** @hidden */
        private setUserAlias;
        /** @hidden */
        private setUserId;
        /** @hidden */
        private simpleSend;
        /**
        Updates the configuration for this channel.
        @param newConfig The new recording configuration
        */
        update(newConfig: fm.liveswitch.ChannelConfig): fm.liveswitch.Future<Object>;
        /** @hidden */
        updateClientConfig(clientConfig: fm.liveswitch.ClientConfig): void;
        /** @hidden */
        private static __fmliveswitchChannelInitialized;
        /** @hidden */
        private static __fmliveswitchChannelInitializing;
        /** @hidden */
        static fmliveswitchChannelInitialize(): void;
    }
}
declare namespace fm.liveswitch {
    /** @hidden */
    class ChannelJoinInfo {
        getTypeString(): string;
        /** @hidden */
        private _channelId;
        /** @hidden */
        private _promise;
        /** @hidden */
        private _timestamp;
        /** @hidden */
        private _token;
        private fmliveswitchChannelJoinInfoInit;
        constructor(promise: fm.liveswitch.Promise<fm.liveswitch.Channel>, channelId: string, token: string, timestamp: number);
        getChannelId(): string;
        getPromise(): fm.liveswitch.Promise<fm.liveswitch.Channel>;
        getTimestamp(): number;
        getToken(): string;
        setChannelId(value: string): void;
        setPromise(value: fm.liveswitch.Promise<fm.liveswitch.Channel>): void;
        setTimestamp(value: number): void;
        setToken(value: string): void;
    }
}
declare namespace fm.liveswitch {
    /**
    A LiveSwitch client.
    */
    class Client extends fm.liveswitch.Dynamic {
        getTypeString(): string;
        /** @hidden */
        private __channels;
        /** @hidden */
        private __deviceAlias;
        /** @hidden */
        private __earlyChannelMessages;
        /** @hidden */
        private __gatewayClient;
        /** @hidden */
        private __joinBackoffTimers;
        /** @hidden */
        private __joining;
        /** @hidden */
        private __joinRateLimiters;
        /** @hidden */
        private __leaving;
        /** @hidden */
        private __lock;
        /** @hidden */
        private __messageBytesReceived;
        /** @hidden */
        private __messageBytesSent;
        /** @hidden */
        private __messagesReceived;
        /** @hidden */
        private __messagesSent;
        /** @hidden */
        private __onApplicationMessage;
        /** @hidden */
        private __onDeviceMessage;
        /** @hidden */
        private __onHttpRequestCreated;
        /** @hidden */
        private __onHttpResponseReceived;
        /** @hidden */
        private __onMessage;
        /** @hidden */
        private __onRemoteUpdate;
        /** @hidden */
        private __onStateChange;
        /** @hidden */
        private __onUserMessage;
        /** @hidden */
        private __region;
        /** @hidden */
        private __registrationBackoffTimer;
        /** @hidden */
        private __registrationRateLimiter;
        /** @hidden */
        private __roles;
        /** @hidden */
        private __sendQueue;
        /** @hidden */
        private __stateMachine;
        /** @hidden */
        private __tag;
        /** @hidden */
        private __userAlias;
        /** @hidden */
        private _applicationId;
        /** @hidden */
        private _deviceId;
        /** @hidden */
        private _externalId;
        /** @hidden */
        private _gatewayUrl;
        /** @hidden */
        private _id;
        /** @hidden */
        private _onApplicationMessage;
        /** @hidden */
        private _onDeviceMessage;
        /** @hidden */
        private _onHttpRequestCreated;
        /** @hidden */
        private _onHttpResponseReceived;
        /** @hidden */
        private _onMessage;
        /** @hidden */
        private _onRemoteUpdate;
        /** @hidden */
        private _onStateChange;
        /** @hidden */
        private _onUserMessage;
        /** @hidden */
        private _userId;
        /** @hidden */
        private static fm_liveswitch_Client___log;
        private fmliveswitchClientInit;
        /**
        Initializes a new instance of the [[fm.liveswitch.client]] class.
        @param gatewayUrl The gateway URL.
        @param applicationId The application identifier.
        */
        constructor(gatewayUrl: string, applicationId: string);
        /**
        Initializes a new instance of the [[fm.liveswitch.client]] class.
        @param gatewayUrl The gateway URL.
        @param applicationId The application identifier.
        @param userId The user identifier, or `null` to auto-generate.
        */
        constructor(gatewayUrl: string, applicationId: string, userId: string);
        /**
        Initializes a new instance of the [[fm.liveswitch.client]] class.
        @param gatewayUrl The gateway URL.
        @param applicationId The application identifier.
        @param userId The user identifier, or `null` to auto-generate.
        @param deviceId The device identifier, or `null` to auto-generate.
        */
        constructor(gatewayUrl: string, applicationId: string, userId: string, deviceId: string);
        /**
        Initializes a new instance of the [[fm.liveswitch.client]] class.
        @param gatewayUrl The gateway URL.
        @param applicationId The application identifier.
        @param userId The user identifier, or `null` to auto-generate.
        @param deviceId The device identifier, or `null` to auto-generate.
        @param clientId The client identifier, or `null` to auto-generate.
        */
        constructor(gatewayUrl: string, applicationId: string, userId: string, deviceId: string, clientId: string);
        /**
        Initializes a new instance of the [[fm.liveswitch.client]] class.
        @param gatewayUrl The gateway URL.
        @param applicationId The application identifier.
        @param userId The user identifier, or `null` to auto-generate.
        @param deviceId The device identifier, or `null` to auto-generate.
        @param clientId The client identifier, or `null` to auto-generate.
        @param roles The roles, if any.
        */
        constructor(gatewayUrl: string, applicationId: string, userId: string, deviceId: string, clientId: string, roles: string[]);
        /**
        Initializes a new instance of the [[fm.liveswitch.client]] class.
        @param gatewayUrl The gateway URL.
        @param applicationId The application identifier.
        @param userId The user identifier, or `null` to auto-generate.
        @param deviceId The device identifier, or `null` to auto-generate.
        @param clientId The client identifier, or `null` to auto-generate.
        @param roles The roles, if any.
        @param region The region, if any.
        */
        constructor(gatewayUrl: string, applicationId: string, userId: string, deviceId: string, clientId: string, roles: string[], region: string);
        /** @hidden */
        private _gatewayClient_OnHttpRequestCreated;
        /** @hidden */
        private _gatewayClient_OnHttpResponseReceived;
        /** @hidden */
        private _gatewayClient_OnServerSubscribe;
        /** @hidden */
        private _gatewayClient_OnStateChange;
        /** @hidden */
        private addChannel;
        /**
        Adds a handler that is raised when an application-scope message is received from the server. Parameters: - clientInfo - the sending client information - message - the message
        */
        addOnApplicationMessage(value: fm.liveswitch.IAction2<fm.liveswitch.ClientInfo, string>): void;
        /**
        Adds a handler that is raised when a device-scope message is received from the server. Parameters: - clientInfo - the sending client information - message - the message
        */
        addOnDeviceMessage(value: fm.liveswitch.IAction2<fm.liveswitch.ClientInfo, string>): void;
        /**
        Adds a handler that is raised whenever an underlying HTTP request has been created and is about to be transferred to the server. This is a good place to add headers/cookies. For WebSocket streams, this will fire only once for the initial HTTP-based handshake.
        */
        addOnHttpRequestCreated(value: fm.liveswitch.IAction1<fm.liveswitch.HttpRequestCreatedArgs>): void;
        /**
        Adds a handler that is raised whenever an underlying HTTP response has been received and is about to be processed by the client. This is a good place to read headers/cookies. For WebSocket streams, this will fire only once for the initial HTTP-based handshake.
        */
        addOnHttpResponseReceived(value: fm.liveswitch.IAction1<fm.liveswitch.HttpResponseReceivedArgs>): void;
        /**
        Adds a handler that is raised when a client-scope message is received from the server. Parameters: - clientInfo - the sending client information - message - the message
        */
        addOnMessage(value: fm.liveswitch.IAction2<fm.liveswitch.ClientInfo, string>): void;
        /**
        Adds a handler that is raised when the the client's config on the server has changed.
        */
        addOnRemoteUpdate(value: fm.liveswitch.IAction2<fm.liveswitch.ClientInfo, fm.liveswitch.ClientInfo>): void;
        /**
        Adds a handler that is raised when the state changes.
        */
        addOnStateChange(value: fm.liveswitch.IAction1<fm.liveswitch.Client>): void;
        /**
        Adds a handler that is raised when a user-scope message is received from the server. Parameters: - clientInfo - the sending client information - message - the message
        */
        addOnUserMessage(value: fm.liveswitch.IAction2<fm.liveswitch.ClientInfo, string>): void;
        /** @hidden */
        private attachChannelEvents;
        /**
        Closes all active connections in all channels.
        */
        closeAll(): fm.liveswitch.Future<Object>;
        /** @hidden */
        private createChannel;
        /** @hidden */
        private delayJoin;
        /** @hidden */
        private delayRegistration;
        /** @hidden */
        private dispatchCloseAll;
        /** @hidden */
        private doCloseAll;
        /** @hidden */
        private doDisconnect;
        /** @hidden */
        private doJoin;
        /** @hidden */
        private doLeave;
        /** @hidden */
        private doLeaveChannel;
        /** @hidden */
        private doRegister;
        /** @hidden */
        private doSendMessage;
        /** @hidden */
        private doUnregister;
        /**
        Gets the application identifier.
        */
        getApplicationId(): string;
        /**
        Gets whether to unregister automatically when the page unloads.
        */
        getAutoUnregister(): boolean;
        /**
        Gets an array of joined channels.
        */
        getChannels(): fm.liveswitch.Channel[];
        /**
        Gets the current configuration.
        */
        getConfig(): fm.liveswitch.ClientConfig;
        /**
        Gets the device alias. Cannot be set after registration, use the 'Update' method instead.
        */
        getDeviceAlias(): string;
        /**
        Gets the device identifier.
        */
        getDeviceId(): string;
        /**
        Gets a value indicating whether to disable the cross-origin resource sharing (CORS) transport.
        */
        getDisableCors(): boolean;
        /**
        Gets a value indicating whether to disable the JSON-P transport.
        */
        getDisableJsonp(): boolean;
        /**
        Gets a value indicating whether to disable the postMessage transport.
        */
        getDisablePostMessage(): boolean;
        /**
        Gets whether to disable WebSocket protocol support and use long-polling, even if the server is capable of accepting WebSocket requests.
        */
        getDisableWebSockets(): boolean;
        /**
        Gets the external client identifier.
        */
        getExternalId(): string;
        /**
        Gets a value indicating whether to force the JSON-P transport.
        */
        getForceJsonp(): boolean;
        /**
        Gets the gateway URL.
        */
        getGatewayUrl(): string;
        /**
        Gets the client identifier.
        */
        getId(): string;
        /**
        Gets the client info.
        */
        getInfo(): fm.liveswitch.ClientInfo;
        /**
        Gets the number of message bytes received.
        */
        getMessageBytesReceived(): number;
        /**
        Gets the number of message bytes sent.
        */
        getMessageBytesSent(): number;
        /**
        Gets the number of messages received.
        */
        getMessagesReceived(): number;
        /**
        Gets the number of messages sent.
        */
        getMessagesSent(): number;
        /**
        Gets the region.
        */
        getRegion(): string;
        /** @hidden */
        getReport(): fm.liveswitch.ClientReport;
        /**
        Gets the maximum number of retries allowed for a standard request.
        */
        getRequestMaxRetries(): number;
        /**
        Gets the number of milliseconds to wait for a standard request to return a response before it is aborted and another request is attempted. Defaults to 15000 (15 seconds).
        */
        getRequestTimeout(): number;
        /**
        Gets the roles.
        */
        getRoles(): string[];
        /**
        Gets the state.
        */
        getState(): fm.liveswitch.ClientState;
        /**
        Gets the tag. Cannot be set after registration, use the 'Update' method instead.
        */
        getTag(): string;
        /**
        Gets the unregister exception, which is set if registration is reset abnormally.
        */
        getUnregisterException(): fm.liveswitch.Exception;
        /**
        Gets the user alias. Cannot be set after registration, use the 'Update' method instead.
        */
        getUserAlias(): string;
        /**
        Gets the user identifier.
        */
        getUserId(): string;
        /**
        Joins a channel.
        @param channelId The channel identifier.
        @param token The auth token.
        @return
                    A future with the joined channel.
            
        */
        join(channelId: string, token: string): fm.liveswitch.Future<fm.liveswitch.Channel>;
        /**
        Joins a channel.
        @param token The auth token.
        @return
                    A future with the joined channel.
            
        */
        join(token: string): fm.liveswitch.Future<fm.liveswitch.Channel>;
        /**
        Leaves a channel.
        @param channelId The channel identifier.
        */
        leave(channelId: string): fm.liveswitch.Future<fm.liveswitch.Channel>;
        /** @hidden */
        private logInvalidStateTransition;
        /** @hidden */
        private processChannelMessage;
        /** @hidden */
        private processMessage;
        /** @hidden */
        private processMessageMessage;
        /** @hidden */
        private processUpdateMessage;
        /** @hidden */
        private receive;
        /**
        Registers with the signalling server.
        @param token The auth token.
        @return
                    A future with an array of initial channels as instructed by the auth token.
            
        */
        register(token: string): fm.liveswitch.Future<fm.liveswitch.Channel[]>;
        /** @hidden */
        private removeChannel;
        /**
        Removes a handler that is raised when an application-scope message is received from the server. Parameters: - clientInfo - the sending client information - message - the message
        */
        removeOnApplicationMessage(value: fm.liveswitch.IAction2<fm.liveswitch.ClientInfo, string>): void;
        /**
        Removes a handler that is raised when a device-scope message is received from the server. Parameters: - clientInfo - the sending client information - message - the message
        */
        removeOnDeviceMessage(value: fm.liveswitch.IAction2<fm.liveswitch.ClientInfo, string>): void;
        /**
        Removes a handler that is raised whenever an underlying HTTP request has been created and is about to be transferred to the server. This is a good place to add headers/cookies. For WebSocket streams, this will fire only once for the initial HTTP-based handshake.
        */
        removeOnHttpRequestCreated(value: fm.liveswitch.IAction1<fm.liveswitch.HttpRequestCreatedArgs>): void;
        /**
        Removes a handler that is raised whenever an underlying HTTP response has been received and is about to be processed by the client. This is a good place to read headers/cookies. For WebSocket streams, this will fire only once for the initial HTTP-based handshake.
        */
        removeOnHttpResponseReceived(value: fm.liveswitch.IAction1<fm.liveswitch.HttpResponseReceivedArgs>): void;
        /**
        Removes a handler that is raised when a client-scope message is received from the server. Parameters: - clientInfo - the sending client information - message - the message
        */
        removeOnMessage(value: fm.liveswitch.IAction2<fm.liveswitch.ClientInfo, string>): void;
        /**
        Removes a handler that is raised when the the client's config on the server has changed.
        */
        removeOnRemoteUpdate(value: fm.liveswitch.IAction2<fm.liveswitch.ClientInfo, fm.liveswitch.ClientInfo>): void;
        /**
        Removes a handler that is raised when the state changes.
        */
        removeOnStateChange(value: fm.liveswitch.IAction1<fm.liveswitch.Client>): void;
        /**
        Removes a handler that is raised when a user-scope message is received from the server. Parameters: - clientInfo - the sending client information - message - the message
        */
        removeOnUserMessage(value: fm.liveswitch.IAction2<fm.liveswitch.ClientInfo, string>): void;
        /** @hidden */
        private rolesAreEquivalent;
        /** @hidden */
        private send;
        /**
        Sends a message to the server with no delivery.
        @param message The message to be sent.
        */
        sendMessage(message: string): fm.liveswitch.Future<Object>;
        /** @hidden */
        private setApplicationId;
        /**
        Sets whether to unregister automatically when the page unloads.
        */
        setAutoUnregister(value: boolean): void;
        /**
        Sets the device alias. Cannot be set after registration, use the 'Update' method instead.
        */
        setDeviceAlias(value: string): void;
        /** @hidden */
        private setDeviceId;
        /**
        Sets a value indicating whether to disable the cross-origin resource sharing (CORS) transport.
        */
        setDisableCors(value: boolean): void;
        /**
        Sets a value indicating whether to disable the JSON-P transport.
        */
        setDisableJsonp(value: boolean): void;
        /**
        Sets a value indicating whether to disable the postMessage transport.
        */
        setDisablePostMessage(value: boolean): void;
        /**
        Sets whether to disable WebSocket protocol support and use long-polling, even if the server is capable of accepting WebSocket requests.
        */
        setDisableWebSockets(value: boolean): void;
        /**
        Sets the external client identifier.
        */
        setExternalId(value: string): void;
        /**
        Sets a value indicating whether to force the JSON-P transport.
        */
        setForceJsonp(value: boolean): void;
        /** @hidden */
        private setGatewayUrl;
        /** @hidden */
        private setId;
        /**
        Sets the maximum number of retries allowed for a standard request.
        */
        setRequestMaxRetries(value: number): void;
        /**
        Sets the number of milliseconds to wait for a standard request to return a response before it is aborted and another request is attempted. Defaults to 15000 (15 seconds).
        */
        setRequestTimeout(value: number): void;
        /** @hidden */
        private setState;
        /**
        Sets the tag. Cannot be set after registration, use the 'Update' method instead.
        */
        setTag(value: string): void;
        /**
        Sets the user alias. Cannot be set after registration, use the 'Update' method instead.
        */
        setUserAlias(value: string): void;
        /** @hidden */
        private setUserId;
        /** @hidden */
        private tryJoin;
        /** @hidden */
        private tryRegister;
        /**
        Unregisters with the signalling server.
        @return
                    A future that resolves when successfully unregistered.
            
        */
        unregister(): fm.liveswitch.Future<Object>;
        /**
        Updates your client configuration.
        @param clientConfig The new client configuration.
        */
        update(clientConfig: fm.liveswitch.ClientConfig): fm.liveswitch.Future<Object>;
        /** @hidden */
        private validateJoinToken;
        /** @hidden */
        private verifyChannelJoin;
        /** @hidden */
        private static __fmliveswitchClientInitialized;
        /** @hidden */
        private static __fmliveswitchClientInitializing;
        /** @hidden */
        static fmliveswitchClientInitialize(): void;
    }
}
declare namespace fm.liveswitch {
    /** @hidden */
    class ClientRegistrationInfo {
        getTypeString(): string;
        /** @hidden */
        private _promise;
        /** @hidden */
        private _timestamp;
        /** @hidden */
        private _token;
        private fmliveswitchClientRegistrationInfoInit;
        constructor(promise: fm.liveswitch.Promise<fm.liveswitch.Channel[]>, token: string, timestamp: number);
        getPromise(): fm.liveswitch.Promise<fm.liveswitch.Channel[]>;
        getTimestamp(): number;
        getToken(): string;
        setPromise(value: fm.liveswitch.Promise<fm.liveswitch.Channel[]>): void;
        setTimestamp(value: number): void;
        setToken(value: string): void;
    }
}
declare namespace fm.liveswitch {
    /**
    A state machine for Client states.
    */
    class ClientStateMachine extends fm.liveswitch.StateMachine<fm.liveswitch.ClientState> {
        getTypeString(): string;
        /**
        Initializes a new instance of the [[fm.liveswitch.connectionStateMachine]] class.
        */
        constructor();
        /**
        Converts a state to an integer value.
        @param state The state.
        */
        protected stateToValue(state: fm.liveswitch.ClientState): number;
        /**
        Converts an integer value to a state.
        @param value The integer value.
        */
        protected valueToState(value: number): fm.liveswitch.ClientState;
    }
}
declare namespace fm.liveswitch {
    /** @hidden */
    class ConnectionFactory {
        getTypeString(): string;
        constructor();
        createMcuConnection(sharedLock: Object, applicationId: string, channelId: string, userId: string, deviceId: string, clientId: string, send: fm.liveswitch.IFunction1<fm.liveswitch.Message, fm.liveswitch.Future<fm.liveswitch.Message>>, audioStream: fm.liveswitch.AudioStream, videoStream: fm.liveswitch.VideoStream, dataStream: fm.liveswitch.DataStream, mediaId: string): fm.liveswitch.McuConnection;
        createPeerConnection(sharedLock: Object, applicationId: string, channelId: string, userId: string, deviceId: string, clientId: string, send: fm.liveswitch.IFunction1<fm.liveswitch.Message, fm.liveswitch.Future<fm.liveswitch.Message>>, peerConnectionOffer: fm.liveswitch.PeerConnectionOffer, audioStream: fm.liveswitch.AudioStream, videoStream: fm.liveswitch.VideoStream, dataStream: fm.liveswitch.DataStream): fm.liveswitch.PeerConnection;
        createPeerConnection(sharedLock: Object, applicationId: string, channelId: string, userId: string, deviceId: string, clientId: string, send: fm.liveswitch.IFunction1<fm.liveswitch.Message, fm.liveswitch.Future<fm.liveswitch.Message>>, remoteClientInfo: fm.liveswitch.ClientInfo, audioStream: fm.liveswitch.AudioStream, videoStream: fm.liveswitch.VideoStream, dataStream: fm.liveswitch.DataStream): fm.liveswitch.PeerConnection;
        createSfuDownstreamConnection(sharedLock: Object, applicationId: string, channelId: string, userId: string, deviceId: string, clientId: string, send: fm.liveswitch.IFunction1<fm.liveswitch.Message, fm.liveswitch.Future<fm.liveswitch.Message>>, remoteConnectionInfo: fm.liveswitch.ConnectionInfo, audioStream: fm.liveswitch.AudioStream, videoStream: fm.liveswitch.VideoStream, dataStream: fm.liveswitch.DataStream): fm.liveswitch.SfuDownstreamConnection;
        createSfuDownstreamConnection(sharedLock: Object, applicationId: string, channelId: string, userId: string, deviceId: string, clientId: string, send: fm.liveswitch.IFunction1<fm.liveswitch.Message, fm.liveswitch.Future<fm.liveswitch.Message>>, remoteMediaId: string, audioStream: fm.liveswitch.AudioStream, videoStream: fm.liveswitch.VideoStream, dataStream: fm.liveswitch.DataStream): fm.liveswitch.SfuDownstreamConnection;
        createSfuUpstreamConnection(sharedLock: Object, applicationId: string, channelId: string, userId: string, deviceId: string, clientId: string, send: fm.liveswitch.IFunction1<fm.liveswitch.Message, fm.liveswitch.Future<fm.liveswitch.Message>>, audioStream: fm.liveswitch.AudioStream, videoStream: fm.liveswitch.VideoStream, dataStream: fm.liveswitch.DataStream, mediaId: string): fm.liveswitch.SfuUpstreamConnection;
    }
}
declare namespace fm.liveswitch {
    /**
    An invitation to join a channel.
    */
    class Invitation {
        getTypeString(): string;
        /** @hidden */
        private __cancelPromise;
        /** @hidden */
        private __channel;
        /** @hidden */
        private __lock;
        /** @hidden */
        private __onStateChanging;
        /** @hidden */
        private _onStateChanging;
        /** @hidden */
        private _protocol;
        /** @hidden */
        private _reason;
        /** @hidden */
        private _state;
        /** @hidden */
        private _userId;
        private fmliveswitchInvitationInit;
        /** @hidden */
        constructor(channel: fm.liveswitch.Channel, userId: string, protocol: string);
        /** @hidden */
        static getInviteKey(channelId: string, userId: string, protocol: string): string;
        /**
        Adds a handler that is raised when the state changes.
        */
        addOnStateChanging(value: fm.liveswitch.IAction1<fm.liveswitch.Invitation>): void;
        /**
        Attempts to cancel the invitation. May fail if the invitation is acted upon before being canceled.
        @return A promise that resolves if the cancel succeeds.
        */
        cancel(): fm.liveswitch.Future<Object>;
        /**
        Gets the channel id that this invitation is for.
        */
        getChannelId(): string;
        /**
        Gets the key for this invitation.
        */
        getInviteKey(): string;
        /**
        Gets the protocol that this user was invited on.
        */
        getProtocol(): string;
        /**
        Gets the reason for a state if available.
        */
        getReason(): string;
        /**
        Gets the current state of the invitation. See InviteFeedbackState for possible values.
        */
        getState(): fm.liveswitch.InvitationState;
        /**
        Gets the user id of the user being invited.
        */
        getUserId(): string;
        /** @hidden */
        private onStateChange;
        /** @hidden */
        processFeedback(feedback: fm.liveswitch.InviteFeedback): boolean;
        /**
        Removes a handler that is raised when the state changes.
        */
        removeOnStateChanging(value: fm.liveswitch.IAction1<fm.liveswitch.Invitation>): void;
        /** @hidden */
        private setProtocol;
        /** @hidden */
        private setReason;
        /** @hidden */
        private setState;
        /** @hidden */
        private setUserId;
    }
}
declare namespace fm.liveswitch {
    /** @hidden */
    class LateDiscardContext {
        getTypeString(): string;
        /** @hidden */
        private __lastMessageTimestamps;
        /** @hidden */
        private __lock;
        constructor();
        shouldDiscardMessage(key: string, timestamp: number): boolean;
    }
}
declare namespace fm.liveswitch {
    /**
    A collection of connections.
    */
    class ManagedConnectionCollection extends fm.liveswitch.Collection<fm.liveswitch.ManagedConnection, fm.liveswitch.ManagedConnectionCollection> {
        getTypeString(): string;
        /** @hidden */
        private __lookup;
        /** @hidden */
        private __lookupLock;
        /** @hidden */
        private __remoteLookup;
        constructor();
        /**
        Invoked when an element is added to the collection.
        @param value The value.
        */
        protected addSuccess(value: fm.liveswitch.ManagedConnection): void;
        /**
        Creates an array from a list.
        @param list The list.
        */
        protected arrayFromList(list: Array<fm.liveswitch.ManagedConnection>): fm.liveswitch.ManagedConnection[];
        /**
        Creates a collection.
        */
        protected createCollection(): fm.liveswitch.ManagedConnectionCollection;
        /**
        Gets a connection by ID.
        @param idValue The identifier.
        @return The connection, or `null` if the connection does not exist.
        */
        getById(idValue: string): fm.liveswitch.ManagedConnection;
        /**
        Gets a connection by remote ID.
        @param idValue The identifier.
        @return The connection, or `null` if the connection does not exist.
        */
        getByRemoteId(idValue: string): fm.liveswitch.ManagedConnection;
        /**
        Invoked when an element is removed from the collection.
        @param value The value.
        */
        protected removeSuccess(value: fm.liveswitch.ManagedConnection): void;
        /**
        Tries to get a connection by ID.
        @param idValue The identifier.
        @param connection The connection.
        @return The connection, or `null` if the connection does not exist.
        */
        tryGetById(idValue: string, connection: fm.liveswitch.Holder<fm.liveswitch.ManagedConnection>): boolean;
        /**
        Tries to get a connection by remote ID.
        @param idValue The identifier.
        @param connection The connection.
        @return The connection, or `null` if the connection does not exist.
        */
        tryGetByRemoteId(idValue: string, connection: fm.liveswitch.Holder<fm.liveswitch.ManagedConnection>): boolean;
    }
}
declare namespace fm.liveswitch {
    /**
    A managed connection.
    */
    abstract class ManagedConnection extends fm.liveswitch.Dynamic {
        getTypeString(): string;
        /** @hidden */
        private __bitrateNotificationLateDiscardContext;
        /** @hidden */
        private __bitrateRequestLateDiscardContext;
        /** @hidden */
        private __doSend;
        /** @hidden */
        private __lastStats;
        /** @hidden */
        private __lastStatsLock;
        /** @hidden */
        private __lock;
        /** @hidden */
        private __messageQueue;
        /** @hidden */
        private __onAutomaticIceServers;
        /** @hidden */
        private __onGatheringStateChange;
        /** @hidden */
        private __onIceConnectionStateChange;
        /** @hidden */
        private __onLocalCandidate;
        /** @hidden */
        private __onLocalDescription;
        /** @hidden */
        private __onNoMediaServersAvailable;
        /** @hidden */
        private __onRemoteAudioEncodingSwitch;
        /** @hidden */
        private __onRemoteCandidate;
        /** @hidden */
        private __onRemoteDescription;
        /** @hidden */
        private __onRemoteUpdate;
        /** @hidden */
        private __onRemoteVideoEncodingSwitch;
        /** @hidden */
        private __onSignallingStateChange;
        /** @hidden */
        private __onStateChange;
        /** @hidden */
        private __onStats;
        /** @hidden */
        private __sendIceServersBackoff;
        /** @hidden */
        private __sendIceServersBackoffTimer;
        /** @hidden */
        private __sendIceServersTimeout;
        /** @hidden */
        private __sendIceServersTimestamp;
        /** @hidden */
        private __sendStatsCancelled;
        /** @hidden */
        private __sendStatsLock;
        /** @hidden */
        private __sendStatsTimer;
        /** @hidden */
        private _applicationId;
        /** @hidden */
        private _audioStream;
        /** @hidden */
        private _channelId;
        /** @hidden */
        private _clientId;
        /** @hidden */
        private _dataStream;
        /** @hidden */
        private _deviceId;
        /** @hidden */
        private _disableAutomaticIceServers;
        /** @hidden */
        private _internalConnection;
        /** @hidden */
        private _localAudioFormats;
        /** @hidden */
        private _localVideoFormats;
        /** @hidden */
        private _mediaId;
        /** @hidden */
        private _noMediaServerTimeout;
        /** @hidden */
        private _onAutomaticIceServers;
        /** @hidden */
        private _onGatheringStateChange;
        /** @hidden */
        private _onIceConnectionStateChange;
        /** @hidden */
        private _onLocalCandidate;
        /** @hidden */
        private _onLocalDescription;
        /** @hidden */
        private _onNoMediaServersAvailable;
        /** @hidden */
        private _onRemoteAudioEncodingSwitch;
        /** @hidden */
        private _onRemoteCandidate;
        /** @hidden */
        private _onRemoteDescription;
        /** @hidden */
        private _onRemoteUpdate;
        /** @hidden */
        private _onRemoteVideoEncodingSwitch;
        /** @hidden */
        private _onSignallingStateChange;
        /** @hidden */
        private _onStateChange;
        /** @hidden */
        private _onStats;
        /** @hidden */
        private _openPromise;
        /** @hidden */
        private _remoteAudioFormats;
        /** @hidden */
        private _remoteClosed;
        /** @hidden */
        private _remoteConnectionId;
        /** @hidden */
        private _remoteFailed;
        /** @hidden */
        private _remoteMediaId;
        /** @hidden */
        private _remoteRejected;
        /** @hidden */
        private _remoteTag;
        /** @hidden */
        private _remoteVideoFormats;
        /** @hidden */
        private _statsInterval;
        /** @hidden */
        private _tag;
        /** @hidden */
        private _type;
        /** @hidden */
        private _userId;
        /** @hidden */
        private _videoStream;
        /** @hidden */
        private static fm_liveswitch_ManagedConnection___log;
        /** @hidden */
        private static fm_liveswitch_ManagedConnection__defaultNoMediaServerTimeout;
        /** @hidden */
        private static fm_liveswitch_ManagedConnection__defaultStatsInterval;
        private fmliveswitchManagedConnectionInit;
        /** @hidden */
        constructor(sharedLock: Object, applicationId: string, channelId: string, userId: string, deviceId: string, clientId: string, doSend: fm.liveswitch.IFunction1<fm.liveswitch.Message, fm.liveswitch.Future<fm.liveswitch.Message>>, type: string, audioStream: fm.liveswitch.AudioStream, videoStream: fm.liveswitch.VideoStream, dataStream: fm.liveswitch.DataStream, mediaId: string);
        /**
        Gets the default timeout in milliseconds on retries for cases where no Media Servers are available for either CE servers or SFU/MCU offer processing. The initial value is 120,000 (2 minutes).
        */
        static getDefaultNoMediaServerTimeout(): number;
        /**
        Gets the default stats interval in milliseconds. The initial value is 10,000 (10 seconds).
        */
        static getDefaultStatsInterval(): number;
        /**
        Sets the default timeout in milliseconds on retries for cases where no Media Servers are available for either CE servers or SFU/MCU offer processing. The initial value is 120,000 (2 minutes).
        */
        static setDefaultNoMediaServerTimeout(value: number): void;
        /**
        Sets the default stats interval in milliseconds. The initial value is 10,000 (10 seconds).
        */
        static setDefaultStatsInterval(value: number): void;
        /**
        Adds a handler that is raised when automatic ICE servers have been received. Parameters: - connection - the connection - automaticIceServers - the automatic ICE severs collection
        */
        addOnAutomaticIceServers(value: fm.liveswitch.IAction2<fm.liveswitch.ManagedConnection, fm.liveswitch.IceServerCollection>): void;
        /**
        Adds a handler that is raised when the ICE gathering state changes. Parameters: - connection - the connection
        */
        addOnGatheringStateChange(value: fm.liveswitch.IAction1<fm.liveswitch.ManagedConnection>): void;
        /**
        Adds a handler that is raised when the ICE connection state changes. Parameters: - connection - the connection
        */
        addOnIceConnectionStateChange(value: fm.liveswitch.IAction1<fm.liveswitch.ManagedConnection>): void;
        /**
        Adds a handler that is raised when a local candidate is ready. Parameters: - connection - the connection - candidate - the local candidate
        */
        addOnLocalCandidate(value: fm.liveswitch.IAction2<fm.liveswitch.ManagedConnection, fm.liveswitch.Candidate>): void;
        /**
        Adds a handler that is raised when the local description is ready. Parameters: - connection - the connection - description - the local description
        */
        addOnLocalDescription(value: fm.liveswitch.IAction2<fm.liveswitch.ManagedConnection, fm.liveswitch.SessionDescription>): void;
        /**
        Adds a handler that is raised when there are no Media Servers available.
        */
        addOnNoMediaServersAvailable(value: fm.liveswitch.IAction2<fm.liveswitch.ManagedConnection, fm.liveswitch.NoMediaServersAvailableEventArgs>): void;
        /**
        Adds a handler that is raised when the remote audio encoding is switched by the server.
        */
        addOnRemoteAudioEncodingSwitch(value: fm.liveswitch.IAction2<fm.liveswitch.EncodingInfo, fm.liveswitch.EncodingInfo>): void;
        /**
        Adds a handler that is raised when a remote candidate is ready. Parameters: - connection - the connection - candidate - the remote candidate
        */
        addOnRemoteCandidate(value: fm.liveswitch.IAction2<fm.liveswitch.ManagedConnection, fm.liveswitch.Candidate>): void;
        /**
        Adds a handler that is raised when the remote description is ready. Parameters: - connection - the connection - description - the remote description
        */
        addOnRemoteDescription(value: fm.liveswitch.IAction2<fm.liveswitch.ManagedConnection, fm.liveswitch.SessionDescription>): void;
        /**
        Adds a handler that is raised when a remote connection has been updated.
        */
        addOnRemoteUpdate(value: fm.liveswitch.IAction2<fm.liveswitch.ConnectionInfo, fm.liveswitch.ConnectionInfo>): void;
        /**
        Adds a handler that is raised when the remote video encoding is switched by the server.
        */
        addOnRemoteVideoEncodingSwitch(value: fm.liveswitch.IAction2<fm.liveswitch.EncodingInfo, fm.liveswitch.EncodingInfo>): void;
        /**
        Adds a handler that is raised when the signalling state changes. Parameters: - connection - the connection
        */
        addOnSignallingStateChange(value: fm.liveswitch.IAction1<fm.liveswitch.ManagedConnection>): void;
        /**
        Adds a handler that is raised when the connection state changes. Parameters: - connection - the connection
        */
        addOnStateChange(value: fm.liveswitch.IAction1<fm.liveswitch.ManagedConnection>): void;
        /** @hidden */
        addOnStats(value: fm.liveswitch.IAction0): void;
        /** @hidden */
        private audioStream_OnDiscardOutboundDtmfTones;
        /**
        Closes the connection.
        */
        close(): fm.liveswitch.Future<Object>;
        /** @hidden */
        private createCandidateMessage;
        /** @hidden */
        private createCloseMessage;
        /**
        Detaches internal event handlers.
        */
        protected detachInternalEventHandlers(): void;
        /** @hidden */
        private doClose;
        /**
        Creates a candidate message.
        @param candidate The candidate.
        */
        protected abstract doCreateCandidateMessage(candidate: fm.liveswitch.Candidate): fm.liveswitch.Message;
        /**
        Creates a close message.
        */
        protected abstract doCreateCloseMessage(): fm.liveswitch.Message;
        /**
        Creates an update message.
        @param config The connection config.
        */
        protected doCreateUpdateMessage(config: fm.liveswitch.ConnectionConfig): fm.liveswitch.Message;
        /**
        Opens the connection.
        */
        protected abstract doOpen(): void;
        /**
        Processes a message.
        @param message The message.
        */
        protected abstract doProcessMessage(message: fm.liveswitch.Message): void;
        /** @hidden */
        private doSelfNegotiate;
        /** @hidden */
        private doSendConnectionEvent;
        /** @hidden */
        private doUpdate;
        /** @hidden */
        private doUpdateConnection;
        /**
        Gets the application identifier.
        */
        getApplicationId(): string;
        /**
        Gets thes audio direction. Null if disabled.
        */
        getAudioDirection(): string;
        /**
        Gets the audio stream.
        */
        getAudioStream(): fm.liveswitch.AudioStream;
        /**
        Gets the Bundle Policy.
        */
        getBundlePolicy(): fm.liveswitch.BundlePolicy;
        /**
        Gets the canonical name for this Connection. Getting the value of Connection.CanonicalName is deprecated. Get the value of MediaStream.LocalCanonicalName instead.
        */
        getCanonicalName(): string;
        /**
        Gets the channel identifier.
        */
        getChannelId(): string;
        /**
        Gets the client identifier.
        */
        getClientId(): string;
        /**
        Gets the current configuration.
        */
        getConfig(): fm.liveswitch.ConnectionConfig;
        /**
        Gets the data direction. Null if disabled.
        */
        getDataDirection(): string;
        /**
        Gets the data stream.
        */
        getDataStream(): fm.liveswitch.DataStream;
        /**
        Gets the device identifier.
        */
        getDeviceId(): string;
        /**
        Gets whether to disable automatic ICE servers (embedded TURN).
        */
        getDisableAutomaticIceServers(): boolean;
        /**
        Gets the error, if an error exists.
        */
        getError(): fm.liveswitch.Error;
        /**
        Gets the external connection identifier.
        */
        getExternalId(): string;
        /**
        Gets the state of the ice gathering.
        */
        getGatheringState(): fm.liveswitch.IceGatheringState;
        /**
        Gets whether this connection has an audio stream.
        */
        getHasAudio(): boolean;
        /**
        Gets whether this connection has a data stream.
        */
        getHasData(): boolean;
        /**
        Gets whether this connection has a video stream.
        */
        getHasVideo(): boolean;
        /**
        Gets the state of the ice connection.
        */
        getIceConnectionState(): fm.liveswitch.IceConnectionState;
        /**
        Gets the ICE gather policy.
        */
        getIceGatherPolicy(): fm.liveswitch.IceGatherPolicy;
        /**
        Gets the ICE server.
        */
        getIceServer(): fm.liveswitch.IceServer;
        /**
        Gets the ICE servers.
        */
        getIceServers(): fm.liveswitch.IceServer[];
        /**
        Gets the connection identifier.
        */
        getId(): string;
        /**
        Gets the connection info.
        */
        getInfo(): fm.liveswitch.ConnectionInfo;
        /** @hidden */
        getInternalConnection(): fm.liveswitch.Connection;
        /** @hidden */
        getLastStats(): fm.liveswitch.ConnectionStats;
        /**
        Gets if local audio is disabled.
        */
        getLocalAudioDisabled(): boolean;
        /**
        Gets the local audio formats.
        */
        getLocalAudioFormats(): fm.liveswitch.FormatInfo[];
        /**
        Gets whether the local audio is muted.
        */
        getLocalAudioMuted(): boolean;
        /**
        Gets if local data is disabled.
        */
        getLocalDataDisabled(): boolean;
        /**
        Gets the local description.
        */
        getLocalDescription(): fm.liveswitch.SessionDescription;
        /**
        Gets if local video is disabled.
        */
        getLocalVideoDisabled(): boolean;
        /**
        Gets the local video formats.
        */
        getLocalVideoFormats(): fm.liveswitch.FormatInfo[];
        /**
        Gets whether the local video is muted.
        */
        getLocalVideoMuted(): boolean;
        /**
        Gets the media identifier.
        */
        getMediaId(): string;
        /**
        Gets the timeout in milliseconds on retries for cases where no Media Servers are available for either CE servers or SFU/MCU offer processing.
        */
        getNoMediaServerTimeout(): number;
        /**
        Gets if remote audio is disabled.
        */
        getRemoteAudioDisabled(): boolean;
        /**
        Gets the remote audio encoding.
        */
        getRemoteAudioEncoding(): fm.liveswitch.EncodingInfo;
        /**
        Gets the remote audio formats.
        */
        getRemoteAudioFormats(): fm.liveswitch.FormatInfo[];
        /**
        Gets whether the remote audio is muted.
        */
        getRemoteAudioMuted(): boolean;
        /**
        Gets a value indicating whether the connection was closed by the remote host.
        */
        getRemoteClosed(): boolean;
        /**
        Gets the remote connection identifier, if available.
        */
        getRemoteConnectionId(): string;
        /**
        Gets if remote data is disabled.
        */
        getRemoteDataDisabled(): boolean;
        /**
        Gets the remote description.
        */
        getRemoteDescription(): fm.liveswitch.SessionDescription;
        /** @hidden */
        getRemoteFailed(): boolean;
        /**
        Gets the remote media identifier, if available.
        */
        getRemoteMediaId(): string;
        /**
        Gets a value indicating whether the connection was rejected by the remote host.
        */
        getRemoteRejected(): boolean;
        /**
        Gets the remote tag, if applicable.
        */
        getRemoteTag(): string;
        /**
        Gets if remote video is disabled.
        */
        getRemoteVideoDisabled(): boolean;
        /**
        Gets the remote video encoding.
        */
        getRemoteVideoEncoding(): fm.liveswitch.EncodingInfo;
        /**
        Gets the remote video formats.
        */
        getRemoteVideoFormats(): fm.liveswitch.FormatInfo[];
        /**
        Gets whether the remote video is muted.
        */
        getRemoteVideoMuted(): boolean;
        /**
        Gets the state of the signalling.
        */
        getSignallingState(): fm.liveswitch.SignallingState;
        /**
        Gets the state of the connection.
        */
        getState(): fm.liveswitch.ConnectionState;
        /**
        Gets the current connection stats.
        */
        getStats(): fm.liveswitch.Future<fm.liveswitch.ConnectionStats>;
        /**
        Gets the stats interval in milliseconds. The default value is 10,000 (10 seconds).
        */
        getStatsInterval(): number;
        /**
        Gets the tag.
        */
        getTag(): string;
        /** @hidden */
        private getTransportInfos;
        /**
        Gets the trickle-ICE policy.
        */
        getTrickleIcePolicy(): fm.liveswitch.TrickleIcePolicy;
        /**
        Gets the connection type.
        */
        getType(): string;
        /**
        Gets the user identifier.
        */
        getUserId(): string;
        /**
        Gets the video direction. Null if disabled.
        */
        getVideoDirection(): string;
        /**
        Gets the video stream.
        */
        getVideoStream(): fm.liveswitch.VideoStream;
        /**
        Gets a value indicating whether the given direction is allowed for this connection.
        @param direction The direction.
        */
        protected abstract isMediaDirectionAllowed(direction: string): boolean;
        /** @hidden */
        private mediaStream_OnDiscardBitrateNotification;
        /** @hidden */
        private mediaStream_OnDiscardBitrateRequest;
        /** @hidden */
        private onInternalConnectionGatheringStateChange;
        /** @hidden */
        private onInternalConnectionIceConnectionStateChange;
        /** @hidden */
        private onInternalConnectionLocalDescription;
        /** @hidden */
        private onInternalConnectionRemoteDescription;
        /** @hidden */
        private onInternalConnectionSignallingStateChange;
        /** @hidden */
        private onInternalConnectionStateChange;
        /**
        Opens the connection.
        */
        open(): fm.liveswitch.Future<Object>;
        /**
        Processes an answer.
        @param message The message.
        */
        protected abstract processAnswer(message: fm.liveswitch.Message): void;
        /** @hidden */
        private processBitrateNotification;
        /** @hidden */
        private processBitrateRequest;
        /** @hidden */
        private processCandidate;
        /** @hidden */
        private processClose;
        /**
        Processes an error message.
        @param message The message.
        */
        protected processError(message: fm.liveswitch.Message): void;
        /** @hidden */
        private processFail;
        /**
        Processes an iceServers message.
        @param message The message.
        */
        protected processIceServers(message: fm.liveswitch.Message): void;
        /** @hidden */
        private processKeyFrameRequest;
        /**
        Processes a local failure.
        @param error The error.
        */
        protected processLocalError(error: fm.liveswitch.Error): void;
        /** @hidden */
        processMessage(message: fm.liveswitch.Message): void;
        /** @hidden */
        private processQueuedMessage;
        /** @hidden */
        private processReject;
        /** @hidden */
        private processRemoteError;
        /** @hidden */
        private processStateChangeEvent;
        /**
        Raises an audio bitrate notification.
        @param audioStream The audio stream.
        @param bitrateNotification The bitrate notification.
        */
        protected raiseAudioBitrateNotification(audioStream: fm.liveswitch.AudioStream, bitrateNotification: fm.liveswitch.BitrateNotification): void;
        /**
        Raises an audio bitrate request.
        @param audioStream The audio stream.
        @param bitrateRequest The bitrate request.
        */
        protected raiseAudioBitrateRequest(audioStream: fm.liveswitch.AudioStream, bitrateRequest: fm.liveswitch.BitrateRequest): void;
        /**
        Raises a local candidate.
        @param localCandidate The local candidate.
        */
        protected raiseLocalCandidate(localCandidate: fm.liveswitch.Candidate): void;
        /**
        Raises the OnNoMediaServersAvailable event.
        */
        protected raiseNoMediaServersAvailable(args: fm.liveswitch.NoMediaServersAvailableEventArgs): void;
        /**
        Raises a remote candidate.
        @param remoteCandidate The remote candidate.
        */
        protected raiseRemoteCandidate(remoteCandidate: fm.liveswitch.Candidate): void;
        /** @hidden */
        raiseRemoteUpdate(oldConnectionInfo: fm.liveswitch.ConnectionInfo, newConnectionInfo: fm.liveswitch.ConnectionInfo): void;
        /**
        Raises a video bitrate notification.
        @param videoStream The video stream.
        @param bitrateNotification The bitrate notification.
        */
        protected raiseVideoBitrateNotification(videoStream: fm.liveswitch.VideoStream, bitrateNotification: fm.liveswitch.BitrateNotification): void;
        /**
        Raises a video bitrate request.
        @param videoStream The video stream.
        @param bitrateRequest The bitrate request.
        */
        protected raiseVideoBitrateRequest(videoStream: fm.liveswitch.VideoStream, bitrateRequest: fm.liveswitch.BitrateRequest): void;
        /**
        Removes a handler that is raised when automatic ICE servers have been received. Parameters: - connection - the connection - automaticIceServers - the automatic ICE severs collection
        */
        removeOnAutomaticIceServers(value: fm.liveswitch.IAction2<fm.liveswitch.ManagedConnection, fm.liveswitch.IceServerCollection>): void;
        /**
        Removes a handler that is raised when the ICE gathering state changes. Parameters: - connection - the connection
        */
        removeOnGatheringStateChange(value: fm.liveswitch.IAction1<fm.liveswitch.ManagedConnection>): void;
        /**
        Removes a handler that is raised when the ICE connection state changes. Parameters: - connection - the connection
        */
        removeOnIceConnectionStateChange(value: fm.liveswitch.IAction1<fm.liveswitch.ManagedConnection>): void;
        /**
        Removes a handler that is raised when a local candidate is ready. Parameters: - connection - the connection - candidate - the local candidate
        */
        removeOnLocalCandidate(value: fm.liveswitch.IAction2<fm.liveswitch.ManagedConnection, fm.liveswitch.Candidate>): void;
        /**
        Removes a handler that is raised when the local description is ready. Parameters: - connection - the connection - description - the local description
        */
        removeOnLocalDescription(value: fm.liveswitch.IAction2<fm.liveswitch.ManagedConnection, fm.liveswitch.SessionDescription>): void;
        /**
        Removes a handler that is raised when there are no Media Servers available.
        */
        removeOnNoMediaServersAvailable(value: fm.liveswitch.IAction2<fm.liveswitch.ManagedConnection, fm.liveswitch.NoMediaServersAvailableEventArgs>): void;
        /**
        Removes a handler that is raised when the remote audio encoding is switched by the server.
        */
        removeOnRemoteAudioEncodingSwitch(value: fm.liveswitch.IAction2<fm.liveswitch.EncodingInfo, fm.liveswitch.EncodingInfo>): void;
        /**
        Removes a handler that is raised when a remote candidate is ready. Parameters: - connection - the connection - candidate - the remote candidate
        */
        removeOnRemoteCandidate(value: fm.liveswitch.IAction2<fm.liveswitch.ManagedConnection, fm.liveswitch.Candidate>): void;
        /**
        Removes a handler that is raised when the remote description is ready. Parameters: - connection - the connection - description - the remote description
        */
        removeOnRemoteDescription(value: fm.liveswitch.IAction2<fm.liveswitch.ManagedConnection, fm.liveswitch.SessionDescription>): void;
        /**
        Removes a handler that is raised when a remote connection has been updated.
        */
        removeOnRemoteUpdate(value: fm.liveswitch.IAction2<fm.liveswitch.ConnectionInfo, fm.liveswitch.ConnectionInfo>): void;
        /**
        Removes a handler that is raised when the remote video encoding is switched by the server.
        */
        removeOnRemoteVideoEncodingSwitch(value: fm.liveswitch.IAction2<fm.liveswitch.EncodingInfo, fm.liveswitch.EncodingInfo>): void;
        /**
        Removes a handler that is raised when the signalling state changes. Parameters: - connection - the connection
        */
        removeOnSignallingStateChange(value: fm.liveswitch.IAction1<fm.liveswitch.ManagedConnection>): void;
        /**
        Removes a handler that is raised when the connection state changes. Parameters: - connection - the connection
        */
        removeOnStateChange(value: fm.liveswitch.IAction1<fm.liveswitch.ManagedConnection>): void;
        /** @hidden */
        removeOnStats(value: fm.liveswitch.IAction0): void;
        /** @hidden */
        private retrySendIceServers;
        /** @hidden */
        private scheduleSendStats;
        /** @hidden */
        private selfRenegotiate;
        /**
        Sends a message.
        @param message The message.
        */
        protected send(message: fm.liveswitch.Message): fm.liveswitch.Future<fm.liveswitch.Message>;
        /** @hidden */
        private sendConnectionEvent;
        /** @hidden */
        private sendConnectionEventMessage;
        /** @hidden */
        private sendIceServers;
        /** @hidden */
        private sendStats;
        /** @hidden */
        private setApplicationId;
        /** @hidden */
        private setAudioStream;
        /**
        Sets the Bundle Policy.
        */
        setBundlePolicy(value: fm.liveswitch.BundlePolicy): void;
        /** @hidden */
        private setChannelId;
        /** @hidden */
        private setClientId;
        /** @hidden */
        private setDataStream;
        /** @hidden */
        private setDeviceId;
        /**
        Sets whether to disable automatic ICE servers (embedded TURN).
        */
        setDisableAutomaticIceServers(value: boolean): void;
        /**
        Sets the ICE gather policy.
        */
        setIceGatherPolicy(value: fm.liveswitch.IceGatherPolicy): void;
        /**
        Sets the ICE server.
        */
        setIceServer(value: fm.liveswitch.IceServer): void;
        /**
        Sets the ICE servers.
        */
        setIceServers(value: fm.liveswitch.IceServer[]): void;
        /** @hidden */
        private setInternalConnection;
        /**
        Sets the local audio formats.
        */
        protected setLocalAudioFormats(value: fm.liveswitch.FormatInfo[]): void;
        /**
        Sets the local video formats.
        */
        protected setLocalVideoFormats(value: fm.liveswitch.FormatInfo[]): void;
        /**
        Sets the media identifier.
        */
        protected setMediaId(value: string): void;
        /**
        Sets the timeout in milliseconds on retries for cases where no Media Servers are available for either CE servers or SFU/MCU offer processing.
        */
        setNoMediaServerTimeout(value: number): void;
        /**
        Sets the remote audio encoding.
        */
        protected setRemoteAudioEncoding(value: fm.liveswitch.EncodingInfo): void;
        /**
        Sets the remote audio formats.
        */
        protected setRemoteAudioFormats(value: fm.liveswitch.FormatInfo[]): void;
        /**
        Sets whether the remote audio is muted.
        */
        setRemoteAudioMuted(value: boolean): void;
        /** @hidden */
        private setRemoteClosed;
        /**
        Sets the remote connection identifier, if available.
        */
        protected setRemoteConnectionId(value: string): void;
        /** @hidden */
        private setRemoteFailed;
        /**
        Sets the remote media identifier, if available.
        */
        protected setRemoteMediaId(value: string): void;
        /** @hidden */
        private setRemoteRejected;
        /**
        Sets the remote tag, if applicable.
        */
        protected setRemoteTag(value: string): void;
        /**
        Sets the remote video encoding.
        */
        protected setRemoteVideoEncoding(value: fm.liveswitch.EncodingInfo): void;
        /**
        Sets the remote video formats.
        */
        protected setRemoteVideoFormats(value: fm.liveswitch.FormatInfo[]): void;
        /**
        Sets whether the remote video is muted.
        */
        setRemoteVideoMuted(value: boolean): void;
        /**
        Sets the stats interval in milliseconds. The default value is 10,000 (10 seconds).
        */
        setStatsInterval(value: number): void;
        /**
        Sets the tag.
        */
        setTag(value: string): void;
        /**
        Sets the trickle-ICE policy.
        */
        setTrickleIcePolicy(value: fm.liveswitch.TrickleIcePolicy): void;
        /** @hidden */
        private setType;
        /** @hidden */
        private setUserId;
        /** @hidden */
        private setVideoStream;
        /** @hidden */
        private tryCancelSendStats;
        /**
        Updates the local description with any modified properties from the config and alerts the server.
        @param config The config
        @return A future that resolves when the renegotiation is complete.
        */
        update(config: fm.liveswitch.ConnectionConfig): fm.liveswitch.Future<Object>;
        /** @hidden */
        updateConnection(oldInfo: fm.liveswitch.ConnectionInfo, newInfo: fm.liveswitch.ConnectionInfo): fm.liveswitch.Future<Object>;
        /** @hidden */
        private videoStream_OnDiscardKeyFrameRequest;
        /** @hidden */
        private static __fmliveswitchManagedConnectionInitialized;
        /** @hidden */
        private static __fmliveswitchManagedConnectionInitializing;
        /** @hidden */
        static fmliveswitchManagedConnectionInitialize(): void;
    }
}
declare namespace fm.liveswitch {
    /**
    Utility to assist with managing the layout of a combined video feed.
    */
    class LayoutUtility {
        getTypeString(): string;
        constructor();
        /**
        Floats the local preview over the combined video feed.
        @param layout The layout.
        @param videoLayout The video layout.
        @param localConnectionId The local connection identifier.
        */
        static floatLocalPreview(layout: fm.liveswitch.Layout, videoLayout: fm.liveswitch.VideoLayout, localConnectionId: string): boolean;
        /**
        Floats the local preview over the combined video feed.
        @param layout The layout.
        @param videoLayout The video layout.
        @param localConnectionId The local connection identifier.
        @param viewId The view id to compare with.
        */
        static floatLocalPreview(layout: fm.liveswitch.Layout, videoLayout: fm.liveswitch.VideoLayout, localConnectionId: string, viewId: string): boolean;
        /**
        Floats the local preview over the combined video feed.
        @param layout The layout.
        @param videoLayout The video layout.
        @param localConnectionId The local connection identifier.
        @param viewId The view id to compare with.
        @param localViewSink The local view sink.
        */
        static floatLocalPreview<T>(layout: fm.liveswitch.Layout, videoLayout: fm.liveswitch.VideoLayout, localConnectionId: string, viewId: string, localViewSink: fm.liveswitch.IViewSink<T>): boolean;
        /**
        Floats the local preview over the combined video feed.
        @param localFrame The local frame.
        @param remoteFrame The remote frame.
        @param videoLayout The video layout.
        @param localConnectionId The local connection identifier.
        */
        static floatLocalPreview(localFrame: fm.liveswitch.LayoutFrame, remoteFrame: fm.liveswitch.LayoutFrame, videoLayout: fm.liveswitch.VideoLayout, localConnectionId: string): boolean;
    }
}
declare namespace fm.liveswitch {
    /**
    A server connection.
    */
    abstract class ServerConnection extends fm.liveswitch.ManagedConnection {
        getTypeString(): string;
        /** @hidden */
        private __heldLocalCandidates;
        /** @hidden */
        private __heldLocalCandidatesLock;
        /** @hidden */
        private __holdLocalCandidates;
        /** @hidden */
        private __inboundAudioBitrate;
        /** @hidden */
        private __inboundVideoBitrate;
        /** @hidden */
        private __lastUpdateTimestamp;
        /** @hidden */
        private __onInboundAudioBitrateChange;
        /** @hidden */
        private __onInboundVideoBitrateChange;
        /** @hidden */
        private __sendOffer;
        /** @hidden */
        private __sendOfferBackoff;
        /** @hidden */
        private __sendOfferBackoffTimer;
        /** @hidden */
        private __sendOfferTimeout;
        /** @hidden */
        private __sendOfferTimestamp;
        /** @hidden */
        private _mediaServerId;
        /** @hidden */
        private _onInboundAudioBitrateChange;
        /** @hidden */
        private _onInboundVideoBitrateChange;
        /** @hidden */
        private _preferredMediaServerId;
        /** @hidden */
        private static fm_liveswitch_ServerConnection___log;
        private fmliveswitchServerConnectionInit;
        /** @hidden */
        constructor(sharedLock: Object, applicationId: string, channelId: string, userId: string, deviceId: string, clientId: string, send: fm.liveswitch.IFunction1<fm.liveswitch.Message, fm.liveswitch.Future<fm.liveswitch.Message>>, connectionType: string, audioStream: fm.liveswitch.AudioStream, videoStream: fm.liveswitch.VideoStream, dataStream: fm.liveswitch.DataStream, mediaId: string);
        /**
        Adds a handler that is raised when the inbound audio bitrate changes.
        */
        addOnInboundAudioBitrateChange(value: fm.liveswitch.IAction2<number, number>): void;
        /**
        Adds a handler that is raised when the inbound video bitrate changes.
        */
        addOnInboundVideoBitrateChange(value: fm.liveswitch.IAction2<number, number>): void;
        /**
        Detaches internal event handlers.
        */
        protected detachInternalEventHandlers(): void;
        /**
        Creates a candidate message.
        @param candidate The candidate.
        */
        protected doCreateCandidateMessage(candidate: fm.liveswitch.Candidate): fm.liveswitch.Message;
        /**
        Creates a close message.
        */
        protected doCreateCloseMessage(): fm.liveswitch.Message;
        /**
        Creates an offer message.
        @param offer The offer.
        */
        protected abstract doCreateOfferMessage(offer: fm.liveswitch.SessionDescription): fm.liveswitch.Message;
        /**
        Opens the connection.
        */
        protected doOpen(): void;
        /**
        Processes a message.
        @param message The message.
        */
        protected doProcessMessage(message: fm.liveswitch.Message): void;
        /**
        Gets the current inbound audio bitrate.
        */
        getInboundAudioBitrate(): number;
        /**
        Gets the current inbound video bitrate.
        */
        getInboundVideoBitrate(): number;
        /**
        Gets the identifier of the Media Server handling this connection.
        */
        getMediaServerId(): string;
        /**
        Gets the preferred identifier of the Media Server to handle this connection.
        */
        getPreferredMediaServerId(): string;
        /** @hidden */
        private onInternalConnectionLocalCandidate;
        /** @hidden */
        private onInternalConnectionRemoteCandidate;
        /**
        Processes an answer.
        @param message The message.
        */
        protected processAnswer(message: fm.liveswitch.Message): void;
        /**
        Processes an error message.
        @param message The message.
        */
        protected processError(message: fm.liveswitch.Message): void;
        /**
        Processes an iceServers message.
        @param message The message.
        */
        protected processIceServers(message: fm.liveswitch.Message): void;
        /** @hidden */
        private processUpdate;
        /**
        Raises an audio bitrate notification.
        @param audioStream The audio stream.
        @param bitrateNotification The bitrate notification.
        */
        protected raiseAudioBitrateNotification(audioStream: fm.liveswitch.AudioStream, bitrateNotification: fm.liveswitch.BitrateNotification): void;
        /**
        Raises a video bitrate notification.
        @param videoStream The video stream.
        @param bitrateNotification The bitrate notification.
        */
        protected raiseVideoBitrateNotification(videoStream: fm.liveswitch.VideoStream, bitrateNotification: fm.liveswitch.BitrateNotification): void;
        /** @hidden */
        private releaseLocalCandidates;
        /**
        Removes a handler that is raised when the inbound audio bitrate changes.
        */
        removeOnInboundAudioBitrateChange(value: fm.liveswitch.IAction2<number, number>): void;
        /**
        Removes a handler that is raised when the inbound video bitrate changes.
        */
        removeOnInboundVideoBitrateChange(value: fm.liveswitch.IAction2<number, number>): void;
        /** @hidden */
        private retrySendOffer;
        /**
        Sends a message.
        @param message The message.
        */
        protected send(message: fm.liveswitch.Message): fm.liveswitch.Future<fm.liveswitch.Message>;
        /** @hidden */
        private sendOffer;
        /** @hidden */
        private setInboundAudioBitrate;
        /** @hidden */
        private setInboundVideoBitrate;
        /** @hidden */
        private setMediaServerId;
        /**
        Sets the preferred identifier of the Media Server to handle this connection.
        */
        setPreferredMediaServerId(value: string): void;
        /** @hidden */
        private tryHoldLocalCandidate;
        /** @hidden */
        private static __fmliveswitchServerConnectionInitialized;
        /** @hidden */
        private static __fmliveswitchServerConnectionInitializing;
        /** @hidden */
        static fmliveswitchServerConnectionInitialize(): void;
    }
}
declare namespace fm.liveswitch {
    /**
    An MCU connection.
    */
    class McuConnection extends fm.liveswitch.ServerConnection {
        getTypeString(): string;
        /** @hidden */
        constructor(sharedLock: Object, applicationId: string, channelId: string, userId: string, deviceId: string, clientId: string, send: fm.liveswitch.IFunction1<fm.liveswitch.Message, fm.liveswitch.Future<fm.liveswitch.Message>>, audioStream: fm.liveswitch.AudioStream, videoStream: fm.liveswitch.VideoStream, dataStream: fm.liveswitch.DataStream, mediaId: string);
        /**
        Creates an offer message.
        @param offer The offer.
        */
        protected doCreateOfferMessage(offer: fm.liveswitch.SessionDescription): fm.liveswitch.Message;
        /**
        Gets a value indicating whether the given media direction is allowed for this connection.
        @param direction The direction.
        */
        protected isMediaDirectionAllowed(direction: string): boolean;
    }
}
declare namespace fm.liveswitch {
    /**
    Event arguments for OnNoMediaServersAvailable.
    */
    class NoMediaServersAvailableEventArgs {
        getTypeString(): string;
        /** @hidden */
        private _backoff;
        private fmliveswitchNoMediaServersAvailableEventArgsInit;
        /**
        Initializes a new instance of the [[fm.liveswitch.noMediaServersAvailableEventArgs]] class.
        @param backoff
        */
        constructor(backoff: number);
        /**
        Gets the backoff in milliseconds.
        */
        getBackoff(): number;
        /** @hidden */
        private setBackoff;
    }
}
declare namespace fm.liveswitch {
    /**
    A peer connection.
    */
    class PeerConnection extends fm.liveswitch.ManagedConnection {
        getTypeString(): string;
        /** @hidden */
        private __lastUpdateTimestamp;
        /** @hidden */
        private __pendingRemoteDescription;
        /** @hidden */
        private _remoteClientInfo;
        /** @hidden */
        private _role;
        /** @hidden */
        private static fm_liveswitch_PeerConnection___log;
        private fmliveswitchPeerConnectionInit;
        /** @hidden */
        constructor(sharedLock: Object, applicationId: string, channelId: string, userId: string, deviceId: string, clientId: string, send: fm.liveswitch.IFunction1<fm.liveswitch.Message, fm.liveswitch.Future<fm.liveswitch.Message>>, peerConnectionOffer: fm.liveswitch.PeerConnectionOffer, audioStream: fm.liveswitch.AudioStream, videoStream: fm.liveswitch.VideoStream, dataStream: fm.liveswitch.DataStream);
        constructor(sharedLock: Object, applicationId: string, channelId: string, userId: string, deviceId: string, clientId: string, send: fm.liveswitch.IFunction1<fm.liveswitch.Message, fm.liveswitch.Future<fm.liveswitch.Message>>, remoteClientInfo: fm.liveswitch.ClientInfo, audioStream: fm.liveswitch.AudioStream, videoStream: fm.liveswitch.VideoStream, dataStream: fm.liveswitch.DataStream);
        /**
        Detaches internal event handlers.
        */
        protected detachInternalEventHandlers(): void;
        /**
        Creates a candidate message.
        @param candidate The candidate.
        */
        protected doCreateCandidateMessage(candidate: fm.liveswitch.Candidate): fm.liveswitch.Message;
        /**
        Creates a close message.
        */
        protected doCreateCloseMessage(): fm.liveswitch.Message;
        /**
        Creates an update message.
        @param config The connection config.
        */
        protected doCreateUpdateMessage(config: fm.liveswitch.ConnectionConfig): fm.liveswitch.Message;
        /**
        Opens the connection.
        */
        protected doOpen(): void;
        /**
        Processes a message.
        @param message The message.
        */
        protected doProcessMessage(message: fm.liveswitch.Message): void;
        /**
        Gets the remote client information.
        */
        getRemoteClientInfo(): fm.liveswitch.ClientInfo;
        /**
        Gets the role.
        */
        getRole(): fm.liveswitch.PeerRole;
        /**
        Gets a value indicating whether the given media direction is allowed for this connection.
        @param direction The direction.
        */
        protected isMediaDirectionAllowed(direction: string): boolean;
        /** @hidden */
        private onInternalConnectionLocalCandidate;
        /** @hidden */
        private onInternalConnectionRemoteCandidate;
        /**
        Processes an answer.
        @param message The message.
        */
        protected processAnswer(message: fm.liveswitch.Message): void;
        /**
        Processes an error message.
        @param message The message.
        */
        protected processError(message: fm.liveswitch.Message): void;
        /** @hidden */
        private processUpdate;
        /**
        Sends a message.
        @param message The message.
        */
        protected send(message: fm.liveswitch.Message): fm.liveswitch.Future<fm.liveswitch.Message>;
        /** @hidden */
        private sendErrorToPeer;
        /** @hidden */
        private setRemoteClientInfo;
        /** @hidden */
        private setRole;
        /** @hidden */
        private static __fmliveswitchPeerConnectionInitialized;
        /** @hidden */
        private static __fmliveswitchPeerConnectionInitializing;
        /** @hidden */
        static fmliveswitchPeerConnectionInitialize(): void;
    }
}
declare namespace fm.liveswitch {
    /**
    A peer connection offer.
    */
    class PeerConnectionOffer {
        getTypeString(): string;
        /** @hidden */
        private __earlyCandidateMessages;
        /** @hidden */
        private __lock;
        /** @hidden */
        private __onCancel;
        /** @hidden */
        private _channel;
        /** @hidden */
        private _connectionTag;
        /** @hidden */
        private _hasAudio;
        /** @hidden */
        private _hasData;
        /** @hidden */
        private _hasVideo;
        /** @hidden */
        private _offer;
        /** @hidden */
        private _onCancel;
        /** @hidden */
        private _remoteClientInfo;
        /** @hidden */
        private _remoteClosed;
        /** @hidden */
        private _remoteConnectionId;
        /** @hidden */
        private _remoteFailed;
        private fmliveswitchPeerConnectionOfferInit;
        /** @hidden */
        constructor(channel: fm.liveswitch.Channel, remoteClientInfo: fm.liveswitch.ClientInfo, remoteConnectionId: string, connectionTag: string, offer: fm.liveswitch.SessionDescription);
        /**
        Accepts the offer.
        @param audioStream The audio stream.
        */
        accept(audioStream: fm.liveswitch.AudioStream): fm.liveswitch.PeerConnection;
        /**
        Accepts the offer.
        @param audioStream The audio stream.
        @param dataStream The data stream.
        */
        accept(audioStream: fm.liveswitch.AudioStream, dataStream: fm.liveswitch.DataStream): fm.liveswitch.PeerConnection;
        /**
        Accepts the offer.
        @param audioStream The audio stream.
        @param videoStream The video stream.
        */
        accept(audioStream: fm.liveswitch.AudioStream, videoStream: fm.liveswitch.VideoStream): fm.liveswitch.PeerConnection;
        /**
        Accepts the offer.
        @param audioStream The audio stream.
        @param videoStream The video stream.
        @param dataStream The data stream.
        */
        accept(audioStream: fm.liveswitch.AudioStream, videoStream: fm.liveswitch.VideoStream, dataStream: fm.liveswitch.DataStream): fm.liveswitch.PeerConnection;
        /**
        Accepts the offer.
        @param dataStream The data stream.
        */
        accept(dataStream: fm.liveswitch.DataStream): fm.liveswitch.PeerConnection;
        /**
        Accepts the offer.
        @param videoStream The video stream.
        */
        accept(videoStream: fm.liveswitch.VideoStream): fm.liveswitch.PeerConnection;
        /**
        Accepts the offer.
        @param videoStream The video stream.
        @param dataStream The data stream.
        */
        accept(videoStream: fm.liveswitch.VideoStream, dataStream: fm.liveswitch.DataStream): fm.liveswitch.PeerConnection;
        /**
        Adds a handler that is raised when the offer is withdrawn.
        */
        addOnCancel(value: fm.liveswitch.IAction0): void;
        /**
        Gets the channel.
        */
        getChannel(): fm.liveswitch.Channel;
        /**
        Gets the connection tag.
        */
        getConnectionTag(): string;
        /** @hidden */
        getEarlyCandidateMessages(): fm.liveswitch.Message[];
        /**
        Gets a value indicating whether the offer includes an audio description.
        */
        getHasAudio(): boolean;
        /**
        Gets a value indicating whether the offer includes a data description.
        */
        getHasData(): boolean;
        /**
        Gets a value indicating whether the offer includes a video description.
        */
        getHasVideo(): boolean;
        /**
        Gets the offer.
        */
        getOffer(): fm.liveswitch.SessionDescription;
        /**
        Gets the remote client information.
        */
        getRemoteClientInfo(): fm.liveswitch.ClientInfo;
        /**
        Gets a value indicating whether the connection was closed by the remote host.
        */
        getRemoteClosed(): boolean;
        /**
        Gets the remote connection identifier.
        */
        getRemoteConnectionId(): string;
        /**
        Gets a value indicating whether the connection was failed by the remote host.
        */
        getRemoteFailed(): boolean;
        /** @hidden */
        processMessage(message: fm.liveswitch.Message): void;
        /**
        Rejects this instance.
        */
        reject(): fm.liveswitch.Future<Object>;
        /**
        Removes a handler that is raised when the offer is withdrawn.
        */
        removeOnCancel(value: fm.liveswitch.IAction0): void;
        /** @hidden */
        private setChannel;
        /** @hidden */
        private setConnectionTag;
        /** @hidden */
        private setHasAudio;
        /** @hidden */
        private setHasData;
        /** @hidden */
        private setHasVideo;
        /** @hidden */
        private setOffer;
        /** @hidden */
        private setRemoteClientInfo;
        /** @hidden */
        private setRemoteClosed;
        /** @hidden */
        private setRemoteConnectionId;
        /** @hidden */
        private setRemoteFailed;
    }
}
declare namespace fm.liveswitch {
    class PeerRoleWrapper {
        getTypeString(): string;
        /** @hidden */
        private _value;
        constructor(value: fm.liveswitch.PeerRole);
        toString(): string;
    }
}
declare namespace fm.liveswitch {
    /**
    An SFU connection.
    */
    abstract class SfuConnection extends fm.liveswitch.ServerConnection {
        getTypeString(): string;
        /** @hidden */
        constructor(sharedLock: Object, applicationId: string, channelId: string, userId: string, deviceId: string, clientId: string, send: fm.liveswitch.IFunction1<fm.liveswitch.Message, fm.liveswitch.Future<fm.liveswitch.Message>>, audioStream: fm.liveswitch.AudioStream, videoStream: fm.liveswitch.VideoStream, dataStream: fm.liveswitch.DataStream, mediaId: string);
    }
}
declare namespace fm.liveswitch {
    /**
    An SFU receiving connection.
    */
    class SfuDownstreamConnection extends fm.liveswitch.SfuConnection {
        getTypeString(): string;
        /** @hidden */
        private _remoteConnectionInfo;
        /** @hidden */
        constructor(sharedLock: Object, applicationId: string, channelId: string, userId: string, deviceId: string, clientId: string, send: fm.liveswitch.IFunction1<fm.liveswitch.Message, fm.liveswitch.Future<fm.liveswitch.Message>>, remoteConnectionInfo: fm.liveswitch.ConnectionInfo, audioStream: fm.liveswitch.AudioStream, videoStream: fm.liveswitch.VideoStream, dataStream: fm.liveswitch.DataStream);
        constructor(sharedLock: Object, applicationId: string, channelId: string, userId: string, deviceId: string, clientId: string, send: fm.liveswitch.IFunction1<fm.liveswitch.Message, fm.liveswitch.Future<fm.liveswitch.Message>>, remoteMediaId: string, audioStream: fm.liveswitch.AudioStream, videoStream: fm.liveswitch.VideoStream, dataStream: fm.liveswitch.DataStream);
        /**
        Creates an offer message.
        @param offer The offer.
        */
        protected doCreateOfferMessage(offer: fm.liveswitch.SessionDescription): fm.liveswitch.Message;
        /**
        Gets the remote connection information, if available.
        */
        getRemoteConnectionInfo(): fm.liveswitch.ConnectionInfo;
        /** @hidden */
        private initialize;
        /**
        Gets a value indicating whether the given media direction is allowed for this connection.
        @param direction The direction.
        */
        protected isMediaDirectionAllowed(direction: string): boolean;
        /** @hidden */
        private setRemoteConnectionInfo;
    }
}
declare namespace fm.liveswitch {
    /**
    An SFU sending connection.
    */
    class SfuUpstreamConnection extends fm.liveswitch.SfuConnection {
        getTypeString(): string;
        /** @hidden */
        constructor(sharedLock: Object, applicationId: string, channelId: string, userId: string, deviceId: string, clientId: string, send: fm.liveswitch.IFunction1<fm.liveswitch.Message, fm.liveswitch.Future<fm.liveswitch.Message>>, audioStream: fm.liveswitch.AudioStream, videoStream: fm.liveswitch.VideoStream, dataStream: fm.liveswitch.DataStream, mediaId: string);
        /**
        Creates an offer message.
        @param offer The offer.
        */
        protected doCreateOfferMessage(offer: fm.liveswitch.SessionDescription): fm.liveswitch.Message;
        /**
        Gets a value indicating whether the given media direction is allowed for this connection.
        @param direction The direction.
        */
        protected isMediaDirectionAllowed(direction: string): boolean;
    }
}
declare namespace fm.liveswitch {
    /**
    Channel configuration.
    */
    class ChannelConfig {
        getTypeString(): string;
        /** @hidden */
        private _recording;
        private fmliveswitchChannelConfigInit;
        constructor();
        /**
        Deserializes an instance from JSON.
        @param clientConfigJson The JSON to deserialize.
        @return
                    The deserialized client config.
            
        */
        static fromJson(clientConfigJson: string): fm.liveswitch.ChannelConfig;
        /**
        Serializes an instance to JSON.
        @param clientConfig The client config to serialize.
        @return
                    The serialized JSON.
            
        */
        static toJson(clientConfig: fm.liveswitch.ChannelConfig): string;
        /**
        Gets recording to be enabled or disabled.
        */
        getRecording(): boolean;
        /**
        Sets recording to be enabled or disabled.
        */
        setRecording(value: boolean): void;
        /**
        Serializes this instance to JSON.
        */
        toJson(): string;
    }
}
declare namespace fm.liveswitch {
    /** @hidden */
    class FailureSourceWrapper {
        getTypeString(): string;
        /** @hidden */
        private _value;
        constructor(value: fm.liveswitch.FailureSource);
        toString(): string;
    }
}
declare namespace fm.liveswitch {
    /** @hidden */
    interface ISendQueueTransport {
        endBatch(): void;
        getIsConnected(): boolean;
        send(item: fm.liveswitch.SendItem): fm.liveswitch.Future<fm.liveswitch.SendItem>;
        startBatch(): void;
    }
}
declare namespace fm.liveswitch {
    /** @hidden */
    class SendItem {
        getTypeString(): string;
        /** @hidden */
        private _exception;
        /** @hidden */
        private _lastInBatch;
        /** @hidden */
        private _promise;
        /** @hidden */
        private _request;
        /** @hidden */
        private _resendIndex;
        /** @hidden */
        private _response;
        /** @hidden */
        private _retry;
        /** @hidden */
        private _sendBackoff;
        /** @hidden */
        private _sendCounter;
        private fmliveswitchSendItemInit;
        constructor();
        getException(): fm.liveswitch.Exception;
        getLastInBatch(): boolean;
        getPromise(): fm.liveswitch.Promise<fm.liveswitch.Message>;
        getRequest(): fm.liveswitch.Message;
        getResendIndex(): number;
        getResponse(): fm.liveswitch.Message;
        getRetry(): boolean;
        getSendBackoff(): number;
        getSendCounter(): number;
        setException(value: fm.liveswitch.Exception): void;
        setLastInBatch(value: boolean): void;
        setPromise(value: fm.liveswitch.Promise<fm.liveswitch.Message>): void;
        setRequest(value: fm.liveswitch.Message): void;
        setResendIndex(value: number): void;
        setResponse(value: fm.liveswitch.Message): void;
        setRetry(value: boolean): void;
        setSendBackoff(value: number): void;
        setSendCounter(value: number): void;
    }
}
declare namespace fm.liveswitch {
    /** @hidden */
    class SendQueue {
        getTypeString(): string;
        /** @hidden */
        private __lock;
        /** @hidden */
        private __pending;
        /** @hidden */
        private __sending;
        /** @hidden */
        private __sendQueueTransport;
        /** @hidden */
        private static fm_liveswitch_SendQueue___log;
        /** @hidden */
        private static fm_liveswitch_SendQueue___sendQueueBatchSizeInCharacters;
        constructor(transport: fm.liveswitch.ISendQueueTransport);
        /** @hidden */
        static getSendQueueBatchSizeInCharacters(): number;
        /** @hidden */
        static setSendQueueBatchSizeInCharacters(value: number): void;
        /** @hidden */
        static takePending(sending: Array<fm.liveswitch.SendItem>, pending: Array<fm.liveswitch.SendItem>): fm.liveswitch.SendItem[];
        clear(): void;
        /** @hidden */
        private doSend;
        /** @hidden */
        getPendingItems(): fm.liveswitch.SendItem[];
        /** @hidden */
        getSendingItems(): fm.liveswitch.SendItem[];
        /** @hidden */
        private processSendComplete;
        /** @hidden */
        private processSendPermanentFailure;
        /** @hidden */
        private processSendSuccess;
        /** @hidden */
        private processSendTemporaryFailure;
        /** @hidden */
        private removeFirstSendingItem;
        /** @hidden */
        private replaceFirstSendingItem;
        send(message: fm.liveswitch.Message): fm.liveswitch.Future<fm.liveswitch.Message>;
        /** @hidden */
        trySendPending(): boolean;
        /** @hidden */
        private static __fmliveswitchSendQueueInitialized;
        /** @hidden */
        private static __fmliveswitchSendQueueInitializing;
        /** @hidden */
        static fmliveswitchSendQueueInitialize(): void;
    }
}
declare namespace fm.liveswitch {
    /**
    Client configuration.
    */
    class ClientConfig {
        getTypeString(): string;
        /** @hidden */
        private _deviceAlias;
        /** @hidden */
        private _roles;
        /** @hidden */
        private _tag;
        /** @hidden */
        private _userAlias;
        /** @hidden */
        constructor();
        /**
        Deserializes an instance from JSON.
        @param clientConfigJson The JSON to deserialize.
        @return
                    The deserialized client config.
            
        */
        static fromJson(clientConfigJson: string): fm.liveswitch.ClientConfig;
        /**
        Serializes an instance to JSON.
        @param clientConfig The client config to serialize.
        @return
                    The serialized JSON.
            
        */
        static toJson(clientConfig: fm.liveswitch.ClientConfig): string;
        /**
        Gets the Device Alias.
        */
        getDeviceAlias(): string;
        /**
        Gets the Roles.
        */
        getRoles(): string[];
        /**
        Gets the Tag.
        */
        getTag(): string;
        /**
        Gets the User Alias.
        */
        getUserAlias(): string;
        /**
        Sets the Device Alias.
        */
        setDeviceAlias(value: string): void;
        /**
        Sets the Roles.
        */
        setRoles(value: string[]): void;
        /**
        Sets the Tag.
        */
        setTag(value: string): void;
        /**
        Sets the User Alias.
        */
        setUserAlias(value: string): void;
        /**
        Serializes this instance to JSON.
        */
        toJson(): string;
    }
}
declare namespace fm.liveswitch {
    /**
    Connection configuration.
    */
    class ConnectionConfig {
        getTypeString(): string;
        /** @hidden */
        private _audioDirection;
        /** @hidden */
        private _dataDirection;
        /** @hidden */
        private _localAudioMuted;
        /** @hidden */
        private _localVideoMuted;
        /** @hidden */
        private _remoteAudioEncoding;
        /** @hidden */
        private _remoteVideoEncoding;
        /** @hidden */
        private _tag;
        /** @hidden */
        private _videoDirection;
        private fmliveswitchConnectionConfigInit;
        /** @hidden */
        constructor();
        /**
        Deserializes an instance from JSON.
        @param connectionConfigJson The JSON to deserialize.
        @return
                    The deserialized connection config.
            
        */
        static fromJson(connectionConfigJson: string): fm.liveswitch.ConnectionConfig;
        /**
        Serializes an instance to JSON.
        @param connectionConfig The connection config to serialize.
        @return
                    The serialized JSON.
            
        */
        static toJson(connectionConfig: fm.liveswitch.ConnectionConfig): string;
        /**
        Gets the audio direction ("sendrecv", "sendonly", "recvonly", or "inactive").
        */
        getAudioDirection(): string;
        /**
        Gets the data direction ("sendrecv", "sendonly", "recvonly", or "inactive").
        */
        getDataDirection(): string;
        /**
        Gets if local audio is disabled.
        */
        getLocalAudioDisabled(): boolean;
        /**
        Gets if the local audio is muted.
        */
        getLocalAudioMuted(): boolean;
        /**
        Gets if local data is disabled.
        */
        getLocalDataDisabled(): boolean;
        /**
        Gets if local video is disabled.
        */
        getLocalVideoDisabled(): boolean;
        /**
        Gets if the local video is muted.
        */
        getLocalVideoMuted(): boolean;
        /**
        Gets if remote audio is disabled.
        */
        getRemoteAudioDisabled(): boolean;
        /**
        Gets the remote audio encoding.
        */
        getRemoteAudioEncoding(): fm.liveswitch.EncodingInfo;
        /**
        Gets if remote data is disabled.
        */
        getRemoteDataDisabled(): boolean;
        /**
        Gets if remote video is disabled.
        */
        getRemoteVideoDisabled(): boolean;
        /**
        Gets the remote video encoding.
        */
        getRemoteVideoEncoding(): fm.liveswitch.EncodingInfo;
        /**
        Gets the tag for this connection.
        */
        getTag(): string;
        /**
        Gets the video direction ("sendrecv", "sendonly", "recvonly", or "inactive").
        */
        getVideoDirection(): string;
        /**
        Sets the audio direction ("sendrecv", "sendonly", "recvonly", or "inactive").
        */
        setAudioDirection(value: string): void;
        /**
        Sets the data direction ("sendrecv", "sendonly", "recvonly", or "inactive").
        */
        setDataDirection(value: string): void;
        /**
        Sets if local audio is disabled.
        */
        setLocalAudioDisabled(value: boolean): void;
        /**
        Sets if the local audio is muted.
        */
        setLocalAudioMuted(value: boolean): void;
        /**
        Sets if local data is disabled.
        */
        setLocalDataDisabled(value: boolean): void;
        /**
        Sets if local video is disabled.
        */
        setLocalVideoDisabled(value: boolean): void;
        /**
        Sets if the local video is muted.
        */
        setLocalVideoMuted(value: boolean): void;
        /**
        Sets if remote audio is disabled.
        */
        setRemoteAudioDisabled(value: boolean): void;
        /**
        Sets the remote audio encoding.
        */
        setRemoteAudioEncoding(value: fm.liveswitch.EncodingInfo): void;
        /**
        Sets if remote data is disabled.
        */
        setRemoteDataDisabled(value: boolean): void;
        /**
        Sets if remote video is disabled.
        */
        setRemoteVideoDisabled(value: boolean): void;
        /**
        Sets the remote video encoding.
        */
        setRemoteVideoEncoding(value: fm.liveswitch.EncodingInfo): void;
        /**
        Sets the tag for this connection.
        */
        setTag(value: string): void;
        /**
        Sets the video direction ("sendrecv", "sendonly", "recvonly", or "inactive").
        */
        setVideoDirection(value: string): void;
        /**
        Serializes this instance to JSON.
        */
        toJson(): string;
    }
}
declare namespace fm.liveswitch {
    /** @hidden */
    class SignallingSendQueueTransport implements fm.liveswitch.ISendQueueTransport {
        getTypeString(): string;
        /** @hidden */
        private __client;
        constructor(client: fm.liveswitch.signalling.Client);
        /** @hidden */
        private doSend;
        endBatch(): void;
        getIsConnected(): boolean;
        send(item: fm.liveswitch.SendItem): fm.liveswitch.Future<fm.liveswitch.SendItem>;
        startBatch(): void;
    }
}
declare namespace fm.liveswitch {
    /**
    Application information.
    */
    class ApplicationInfo extends fm.liveswitch.Info {
        getTypeString(): string;
        constructor();
        /**
        Deserializes Json to a ApplicationInfo.
        @param applicationInfoJson The serialized Json.
        @return The deserialized ApplicationInfo.
        */
        static fromJson(applicationInfoJson: string): fm.liveswitch.ApplicationInfo;
        /**
        Serializes an instance to Json.
        @param application The instance to serialize.
        @return Serialized Json.
        */
        static toJson(application: fm.liveswitch.ApplicationInfo): string;
        /**
        Deserializes the properties.
        @param key The key.
        @param valueJson The value in JSON format.
        */
        protected deserializeProperties(key: string, valueJson: string): void;
        /**
        Serializes the properties.
        @param jsonObject The JSON object.
        */
        protected serializeProperties(jsonObject: fm.liveswitch.Hash<string, string>): void;
        /**
        Serializes this instance to Json.
        */
        toJson(): string;
    }
}
declare namespace fm.liveswitch {
    /**
    Report.
    */
    abstract class Report {
        getTypeString(): string;
        constructor();
        /**
        Processes an array for a report.
        @param newValues The new values.
        @param oldValues The old values.
        @return The new values, if the new values are not equivalent to the old values; otherwise null.
        */
        static processArray<T extends fm.liveswitch.IEquivalent<T>>(newValues: T[], oldValues: T[]): T[];
        /**
        Processes a boolean for a report.
        @param newValue The new value.
        @param oldValue The old value.
        @return The new value, if the new value does not equal the old value; otherwise null.
        */
        static processBoolean(newValue: boolean, oldValue: boolean): boolean;
        /**
        Processes a boolean array for a report.
        @param newValues The new values.
        @param oldValues The old values.
        @return The new values, if the new values do not equal the old values; otherwise null.
        */
        static processBooleanArray(newValues: boolean[], oldValues: boolean[]): boolean[];
        /**
        Processes a double for a report.
        @param newValue The new value.
        @param oldValue The old value.
        @return The new value, if the new value does not equal the old value; otherwise null.
        */
        static processDouble(newValue: number, oldValue: number): number;
        /**
        Processes a float for a report.
        @param newValue The new value.
        @param oldValue The old value.
        @return The new value, if the new value does not equal the old value; otherwise null.
        */
        static processFloat(newValue: number, oldValue: number): number;
        /**
        Processes a float array for a report.
        @param newValues The new values.
        @param oldValues The old values.
        @return The new values, if the new values do not equal the old values; otherwise null.
        */
        static processFloatArray(newValues: number[], oldValues: number[]): number[];
        /**
        Processes an integer for a report.
        @param newValue The new value.
        @param oldValue The old value.
        @return The new value, if the new value does not equal the old value; otherwise null.
        */
        static processInteger(newValue: number, oldValue: number): number;
        /**
        Processes a integer array for a report.
        @param newValues The new values.
        @param oldValues The old values.
        @return The new values, if the new values do not equal the old values; otherwise null.
        */
        static processIntegerArray(newValues: number[], oldValues: number[]): number[];
        /**
        Processes a long for a report.
        @param newValue The new value.
        @param oldValue The old value.
        @return The new value, if the new value does not equal the old value; otherwise null.
        */
        static processLong(newValue: number, oldValue: number): number;
        /**
        Processes a long array for a report.
        @param newValues The new values.
        @param oldValues The old values.
        @return The new values, if the new values do not equal the old values; otherwise null.
        */
        static processLongArray(newValues: number[], oldValues: number[]): number[];
        /**
        Processes an array for a report.
        @param newValue The new value.
        @param oldValue The old value.
        @return The new value, if the new value does not equal the old value; otherwise null.
        */
        static processObject<T extends Object & fm.liveswitch.IEquivalent<T>>(newValue: T, oldValue: T): T;
        /**
        Processes a short for a report.
        @param newValue The new value.
        @param oldValue The old value.
        @return The new value, if the new value does not equal the old value; otherwise null.
        */
        static processShort(newValue: number, oldValue: number): number;
        /**
        Processes a short array for a report.
        @param newValues The new values.
        @param oldValues The old values.
        @return The new values, if the new values do not equal the old values; otherwise null.
        */
        static processShortArray(newValues: number[], oldValues: number[]): number[];
        /**
        Processes a string for a report.
        @param newValue The new value.
        @param oldValue The old value.
        @return The new value, if the new value does not equal the old value; otherwise null.
        */
        static processString(newValue: string, oldValue: string): string;
        /**
        Deserializes the properties.
        @param key The key.
        @param valueJson The value in JSON format.
        */
        protected deserializeProperties(key: string, valueJson: string): void;
        /**
        Serializes the properties.
        @param jsonObject The JSON object.
        */
        protected serializeProperties(jsonObject: fm.liveswitch.Hash<string, string>): void;
    }
}
declare namespace fm.liveswitch {
    /**
    Candidate pair report.
    */
    class CandidatePairReport extends fm.liveswitch.Report {
        getTypeString(): string;
        /** @hidden */
        private _bytesReceived;
        /** @hidden */
        private _bytesSent;
        /** @hidden */
        private _consentRequestsReceived;
        /** @hidden */
        private _consentRequestsSent;
        /** @hidden */
        private _consentResponsesReceived;
        /** @hidden */
        private _consentResponsesSent;
        /** @hidden */
        private _currentRoundTripTime;
        /** @hidden */
        private _requestsReceived;
        /** @hidden */
        private _requestsSent;
        /** @hidden */
        private _responsesReceived;
        /** @hidden */
        private _responsesSent;
        /** @hidden */
        private _totalRoundTripTime;
        private fmliveswitchCandidatePairReportInit;
        /**
        Initializes a new instance of the [[fm.liveswitch.candidatePairReport]] class.
        */
        constructor();
        constructor(stats: fm.liveswitch.CandidatePairStats, lastStats: fm.liveswitch.CandidatePairStats);
        /**
        Deserializes an instance from JSON.
        @param instanceJson The instance JSON.
        @return The deserialized instance.
        */
        static fromJson(instanceJson: string): fm.liveswitch.CandidatePairReport;
        /**
        Derializes an array from JSON.
        @param arrayJson The array JSON.
        @return The deserialized array.
        */
        static fromJsonArray(arrayJson: string): fm.liveswitch.CandidatePairReport[];
        /**
        Serializes an instance to JSON.
        @param instance The instance.
        @return The serialized instance JSON.
        */
        static toJson(instance: fm.liveswitch.CandidatePairReport): string;
        /**
        Serializes an array to JSON.
        @param array The array.
        @return The serialized array JSON.
        */
        static toJsonArray(array: fm.liveswitch.CandidatePairReport[]): string;
        /**
        Deserializes the properties.
        @param key The key.
        @param valueJson The value in JSON format.
        */
        protected deserializeProperties(key: string, valueJson: string): void;
        /**
        Gets the number of candidate pair bytes received.
        */
        getBytesReceived(): number;
        /**
        Gets the number of candidate pair bytes sent.
        */
        getBytesSent(): number;
        /**
        Gets the number of candidate pair consent requests received.
        */
        getConsentRequestsReceived(): number;
        /**
        Gets the number of candidate pair consent requests sent.
        */
        getConsentRequestsSent(): number;
        /**
        Gets the number of candidate pair consent responses received.
        */
        getConsentResponsesReceived(): number;
        /**
        Gets the number of candidate pair consent responses sent.
        */
        getConsentResponsesSent(): number;
        /**
        Gets the candidate pair current round trip time in milliseconds.
        */
        getCurrentRoundTripTime(): number;
        /**
        Gets the number of candidate pair requests received.
        */
        getRequestsReceived(): number;
        /**
        Gets the number of candidate pair requests sent.
        */
        getRequestsSent(): number;
        /**
        Gets the number of candidate pair responses received.
        */
        getResponsesReceived(): number;
        /**
        Gets the number of candidate pair responses sent.
        */
        getResponsesSent(): number;
        /**
        Gets the candidate pair total round trip time in milliseconds.
        */
        getTotalRoundTripTime(): number;
        /**
        Serializes the properties.
        @param jsonObject The JSON object.
        */
        protected serializeProperties(jsonObject: fm.liveswitch.Hash<string, string>): void;
        /**
        Sets the number of candidate pair bytes received.
        */
        setBytesReceived(value: number): void;
        /**
        Sets the number of candidate pair bytes sent.
        */
        setBytesSent(value: number): void;
        /**
        Sets the number of candidate pair consent requests received.
        */
        setConsentRequestsReceived(value: number): void;
        /**
        Sets the number of candidate pair consent requests sent.
        */
        setConsentRequestsSent(value: number): void;
        /**
        Sets the number of candidate pair consent responses received.
        */
        setConsentResponsesReceived(value: number): void;
        /**
        Sets the number of candidate pair consent responses sent.
        */
        setConsentResponsesSent(value: number): void;
        /**
        Sets the candidate pair current round trip time in milliseconds.
        */
        setCurrentRoundTripTime(value: number): void;
        /**
        Sets the number of candidate pair requests received.
        */
        setRequestsReceived(value: number): void;
        /**
        Sets the number of candidate pair requests sent.
        */
        setRequestsSent(value: number): void;
        /**
        Sets the number of candidate pair responses received.
        */
        setResponsesReceived(value: number): void;
        /**
        Sets the number of candidate pair responses sent.
        */
        setResponsesSent(value: number): void;
        /**
        Sets the candidate pair total round trip time in milliseconds.
        */
        setTotalRoundTripTime(value: number): void;
        /**
        Serializes this instance to JSON.
        */
        toJson(): string;
    }
}
declare namespace fm.liveswitch {
    /**
    Channel report.
    */
    class ChannelReport extends fm.liveswitch.Report {
        getTypeString(): string;
        /** @hidden */
        private _id;
        /** @hidden */
        private _messageBytesReceived;
        /** @hidden */
        private _messageBytesSent;
        /** @hidden */
        private _messagesReceived;
        /** @hidden */
        private _messagesSent;
        private fmliveswitchChannelReportInit;
        constructor();
        /**
        Deserializes an instance from JSON.
        @param instanceJson The instance JSON.
        @return The deserialized instance.
        */
        static fromJson(instanceJson: string): fm.liveswitch.ChannelReport;
        /**
        Derializes an array from JSON.
        @param arrayJson The array JSON.
        @return The deserialized array.
        */
        static fromJsonArray(arrayJson: string): fm.liveswitch.ChannelReport[];
        /**
        Serializes an instance to JSON.
        @param instance The instance to serialize.
        @return The instance JSON.
        */
        static toJson(instance: fm.liveswitch.ChannelReport): string;
        /**
        Serializes an array to JSON.
        @param array The array.
        @return The serialized array JSON.
        */
        static toJsonArray(array: fm.liveswitch.ChannelReport[]): string;
        /**
        Deserializes the properties.
        @param key The key.
        @param valueJson The value in JSON format.
        */
        protected deserializeProperties(key: string, valueJson: string): void;
        /**
        Gets the identifier.
        */
        getId(): string;
        /**
        Gets the number of message bytes received on this channel.
        */
        getMessageBytesReceived(): number;
        /**
        Gets the number of message bytes sent on this channel.
        */
        getMessageBytesSent(): number;
        /**
        Gets the number of messages received on this channel.
        */
        getMessagesReceived(): number;
        /**
        Gets the number of messages sent on this channel.
        */
        getMessagesSent(): number;
        /** @hidden */
        isEquivalent(otherReport: fm.liveswitch.ChannelReport): boolean;
        /**
        Serializes the properties.
        @param jsonObject The JSON object.
        */
        protected serializeProperties(jsonObject: fm.liveswitch.Hash<string, string>): void;
        /**
        Sets the identifier.
        */
        setId(value: string): void;
        /**
        Sets the number of message bytes received on this channel.
        */
        setMessageBytesReceived(value: number): void;
        /**
        Sets the number of message bytes sent on this channel.
        */
        setMessageBytesSent(value: number): void;
        /**
        Sets the number of messages received on this channel.
        */
        setMessagesReceived(value: number): void;
        /**
        Sets the number of messages sent on this channel.
        */
        setMessagesSent(value: number): void;
        /**
        Serializes this instance to Json.
        */
        toJson(): string;
    }
}
declare namespace fm.liveswitch {
    /**
    Client report.
    */
    class ClientReport extends fm.liveswitch.Report {
        getTypeString(): string;
        /** @hidden */
        private _id;
        /** @hidden */
        private _messageBytesReceived;
        /** @hidden */
        private _messageBytesSent;
        /** @hidden */
        private _messagesReceived;
        /** @hidden */
        private _messagesSent;
        private fmliveswitchClientReportInit;
        constructor();
        /**
        Deserializes an instance from JSON.
        @param instanceJson The instance JSON.
        @return The deserialized instance.
        */
        static fromJson(instanceJson: string): fm.liveswitch.ClientReport;
        /**
        Derializes an array from JSON.
        @param arrayJson The array JSON.
        @return The deserialized array.
        */
        static fromJsonArray(arrayJson: string): fm.liveswitch.ClientReport[];
        /**
        Serializes an instance to JSON.
        @param instance The instance to serialize.
        @return The instance JSON.
        */
        static toJson(instance: fm.liveswitch.ClientReport): string;
        /**
        Serializes an array to JSON.
        @param array The array.
        @return The serialized array JSON.
        */
        static toJsonArray(array: fm.liveswitch.ClientReport[]): string;
        /**
        Deserializes the properties.
        @param key The key.
        @param valueJson The value in JSON format.
        */
        protected deserializeProperties(key: string, valueJson: string): void;
        /**
        Gets the identifier.
        */
        getId(): string;
        /**
        Gets the number of message bytes received by this client.
        */
        getMessageBytesReceived(): number;
        /**
        Gets the number of message bytes sent by this client.
        */
        getMessageBytesSent(): number;
        /**
        Gets the number of messages received by this client.
        */
        getMessagesReceived(): number;
        /**
        Gets the number of messages sent by this client.
        */
        getMessagesSent(): number;
        /** @hidden */
        isEquivalent(otherReport: fm.liveswitch.ClientReport): boolean;
        /**
        Serializes the properties.
        @param jsonObject The JSON object.
        */
        protected serializeProperties(jsonObject: fm.liveswitch.Hash<string, string>): void;
        /**
        Sets the identifier.
        */
        setId(value: string): void;
        /**
        Sets the number of message bytes received by this client.
        */
        setMessageBytesReceived(value: number): void;
        /**
        Sets the number of message bytes sent by this client.
        */
        setMessageBytesSent(value: number): void;
        /**
        Sets the number of messages received by this client.
        */
        setMessagesReceived(value: number): void;
        /**
        Sets the number of messages sent by this client.
        */
        setMessagesSent(value: number): void;
        /**
        Serializes this instance to Json.
        */
        toJson(): string;
    }
}
declare namespace fm.liveswitch {
    /**
    Data stream report.
    */
    class DataStreamReport extends fm.liveswitch.Report {
        getTypeString(): string;
        /** @hidden */
        private _bytesReceived;
        /** @hidden */
        private _bytesSent;
        /** @hidden */
        private _messagesReceived;
        /** @hidden */
        private _messagesSent;
        private fmliveswitchDataStreamReportInit;
        /**
        Initializes a new instance of the [[fm.liveswitch.dataStreamReport]] class.
        */
        constructor();
        constructor(stats: fm.liveswitch.DataStreamStats, lastStats: fm.liveswitch.DataStreamStats, eventType: string);
        /**
        Deserializes Json to a DataStreamReport.
        @param dataStreamReportJson The serialized Json.
        @return The deserialized DataChannelReport.
        */
        static fromJson(dataStreamReportJson: string): fm.liveswitch.DataStreamReport;
        /**
        Serializes an instance to Json.
        @param dataStreamReport The instance to serialize.
        @return Serialized Json.
        */
        static toJson(dataStreamReport: fm.liveswitch.DataStreamReport): string;
        /**
        Deserializes the properties.
        @param key The key.
        @param valueJson The value in JSON format.
        */
        protected deserializeProperties(key: string, valueJson: string): void;
        /**
        Gets the number of bytes received on this data stream.
        */
        getBytesReceived(): number;
        /**
        Gets the number of bytes sent on this data stream.
        */
        getBytesSent(): number;
        /**
        Gets the number of messages received on this data stream.
        */
        getMessagesReceived(): number;
        /**
        Gets the number of messages sent on this data stream.
        */
        getMessagesSent(): number;
        /**
        Serializes the properties.
        @param jsonObject The JSON object.
        */
        protected serializeProperties(jsonObject: fm.liveswitch.Hash<string, string>): void;
        /**
        Sets the number of bytes received on this data stream.
        */
        setBytesReceived(value: number): void;
        /**
        Sets the number of bytes sent on this data stream.
        */
        setBytesSent(value: number): void;
        /**
        Sets the number of messages received on this data stream.
        */
        setMessagesReceived(value: number): void;
        /**
        Sets the number of messages sent on this data stream.
        */
        setMessagesSent(value: number): void;
        /**
        Serializes this instance to Json.
        */
        toJson(): string;
    }
}
declare namespace fm.liveswitch {
    /**
    An event batch.
    */
    class EventBatch {
        getTypeString(): string;
        /** @hidden */
        private _events;
        constructor();
        /**
        Deserializes an instance from JSON.
        */
        static fromJson(instanceJson: string): fm.liveswitch.EventBatch;
        /**
        Serializes an instance to JSON.
        */
        static toJson(instance: fm.liveswitch.EventBatch): string;
        /**
        Deserializes the property.
        @param key The key.
        @param valueJson The value in JSON format.
        */
        protected deserializeProperty(key: string, valueJson: string): void;
        /**
        Gets the events.
        */
        getEvents(): fm.liveswitch.EventInfo[];
        /**
        Serializes the properties.
        @param jsonObject The JSON object.
        */
        protected serializeProperties(jsonObject: fm.liveswitch.Hash<string, string>): void;
        /**
        Sets the events.
        */
        setEvents(value: fm.liveswitch.EventInfo[]): void;
        /**
        Serializes this instance to JSON.
        */
        toJson(): string;
    }
}
declare namespace fm.liveswitch {
    /**
    Event types.
    */
    abstract class EventType {
        getTypeString(): string;
        /**
        Converts a connection state enum value into an event type.
        @param connectionState The connection state.
        @return An event type.
        */
        static fromConnectionState(connectionState: fm.liveswitch.ConnectionState): string;
        /**
        Gets the 'channel.activated' event type string.
        */
        static getChannelActivated(): string;
        /**
        Gets the 'channel.client.joined' event type string.
        */
        static getChannelClientJoined(): string;
        /**
        Gets the 'channel.client.left' event type string.
        */
        static getChannelClientLeft(): string;
        /**
        Gets the 'channel.client.message' event type string.
        */
        static getChannelClientMessage(): string;
        /**
        Gets the 'channel.deactivated' event type string.
        */
        static getChannelDeactivated(): string;
        /**
        Gets the 'channel.server.message' event type string.
        */
        static getChannelServerMessage(): string;
        /**
        Gets the 'client.message' event type string.
        */
        static getClientMessage(): string;
        /**
        Gets the 'client.registered' event type string.
        */
        static getClientRegistered(): string;
        /**
        Gets the 'client.stats' event type string.
        */
        static getClientStats(): string;
        /**
        Gets the 'client.unregistered' event type string.
        */
        static getClientUnregistered(): string;
        /**
        Gets the 'client.updated' event type string.
        */
        static getClientUpdated(): string;
        /**
        Gets the 'connection.closed' event type string.
        */
        static getConnectionClosed(): string;
        /**
        Gets the 'connection.closing' event type string.
        */
        static getConnectionClosing(): string;
        /**
        Gets the 'connection.connected' event type string.
        */
        static getConnectionConnected(): string;
        /**
        Gets the 'connection.connecting' event type string.
        */
        static getConnectionConnecting(): string;
        /**
        Gets the 'connection.failed' event type string.
        */
        static getConnectionFailed(): string;
        /**
        Gets the 'connection.failing' event type string.
        */
        static getConnectionFailing(): string;
        /**
        Gets the 'connection.initializing' event type string.
        */
        static getConnectionInitializing(): string;
        /**
        Gets the 'connection.stats' event type string.
        */
        static getConnectionStats(): string;
        /**
        Gets the 'connection.updated' event type string.
        */
        static getConnectionUpdated(): string;
        /**
        Gets the 'gateway.started' event type string.
        */
        static getGatewayStarted(): string;
        /**
        Gets the 'gateway.stats' event type string.
        */
        static getGatewayStats(): string;
        /**
        Gets the 'gateway.stopped' event type string.
        */
        static getGatewayStopped(): string;
        /**
        Gets the 'mediaserver.registered' event type string.
        */
        static getMediaServerRegistered(): string;
        /**
        Gets the 'mediaserver.started' event type string.
        */
        static getMediaServerStarted(): string;
        /**
        Gets the 'mediaserver.stats' event type string.
        */
        static getMediaServerStats(): string;
        /**
        Gets the 'mediaserver.stopped' event type string.
        */
        static getMediaServerStopped(): string;
        /**
        Gets the 'mediaserver.unregistered' event type string.
        */
        static getMediaServerUnregistered(): string;
        /**
        Gets the 'server.message' event type string.
        */
        static getServerMessage(): string;
        /**
        Gets the 'sipconnector.registered' event type string.
        */
        static getSipConnectorRegistered(): string;
        /**
        Gets the 'sipconnector.started' event type string.
        */
        static getSipConnectorStarted(): string;
        /**
        Gets the 'sipconnector.stats' event type string.
        */
        static getSipConnectorStats(): string;
        /**
        Gets the 'sipconnector.stopped' event type string.
        */
        static getSipConnectorStopped(): string;
        /**
        Gets the 'sipconnector.unregistered' event type string.
        */
        static getSipConnectorUnregistered(): string;
    }
}
declare namespace fm.liveswitch {
    /**
    Media component report.
    */
    abstract class MediaComponentReport extends fm.liveswitch.Report {
        getTypeString(): string;
        /** @hidden */
        private _firCount;
        /** @hidden */
        private _lrrCount;
        /** @hidden */
        private _nackCount;
        /** @hidden */
        private _pliCount;
        /** @hidden */
        private _sliCount;
        private fmliveswitchMediaComponentReportInit;
        /**
        Initializes a new instance of the [[fm.liveswitch.mediaComponentReport]] class.
        */
        constructor();
        constructor(stats: fm.liveswitch.MediaComponentStats, lastStats: fm.liveswitch.MediaComponentStats);
        /**
        Deserializes the properties.
        @param key The key.
        @param valueJson The value in JSON format.
        */
        protected deserializeProperties(key: string, valueJson: string): void;
        /**
        Gets the number of full intra refresh (FIR) messages sent.
        */
        getFirCount(): number;
        /**
        Gets the number of layer refresh request (LRR) messages sent.
        */
        getLrrCount(): number;
        /**
        Gets the number of negative-acknowledgement (NACK) messages sent.
        */
        getNackCount(): number;
        /**
        Gets the number of picture loss indication (PLI) messages sent.
        */
        getPliCount(): number;
        /**
        Gets the number of slice loss indication (SLI) messages sent.
        */
        getSliCount(): number;
        /**
        Serializes the properties.
        @param jsonObject The JSON object.
        */
        protected serializeProperties(jsonObject: fm.liveswitch.Hash<string, string>): void;
        /**
        Sets the number of full intra refresh (FIR) messages sent.
        */
        setFirCount(value: number): void;
        /**
        Sets the number of layer refresh request (LRR) messages sent.
        */
        setLrrCount(value: number): void;
        /**
        Sets the number of negative-acknowledgement (NACK) messages sent.
        */
        setNackCount(value: number): void;
        /**
        Sets the number of picture loss indication (PLI) messages sent.
        */
        setPliCount(value: number): void;
        /**
        Sets the number of slice loss indication (SLI) messages sent.
        */
        setSliCount(value: number): void;
    }
}
declare namespace fm.liveswitch {
    /**
    Media track report.
    */
    class MediaTrackReport extends fm.liveswitch.Report {
        getTypeString(): string;
        /** @hidden */
        private _bitrate;
        /** @hidden */
        private _frameHeight;
        /** @hidden */
        private _frameRate;
        /** @hidden */
        private _framesCorrupted;
        /** @hidden */
        private _framesDecoded;
        /** @hidden */
        private _framesDropped;
        /** @hidden */
        private _framesEncoded;
        /** @hidden */
        private _framesReceived;
        /** @hidden */
        private _framesSent;
        /** @hidden */
        private _frameWidth;
        /** @hidden */
        private _maxBitrate;
        /** @hidden */
        private _minBitrate;
        private fmliveswitchMediaTrackReportInit;
        /**
        Initializes a new instance of the [[fm.liveswitch.mediaTrackReport]] class.
        */
        constructor();
        constructor(stats: fm.liveswitch.MediaTrackStats, lastStats: fm.liveswitch.MediaTrackStats);
        /**
        Deserializes an instance from JSON.
        @param instanceJson The instance JSON.
        @return The deserialized instance.
        */
        static fromJson(instanceJson: string): fm.liveswitch.MediaTrackReport;
        /**
        Derializes an array from JSON.
        @param arrayJson The array JSON.
        @return The deserialized array.
        */
        static fromJsonArray(arrayJson: string): fm.liveswitch.MediaTrackReport[];
        /**
        Serializes an instance to JSON.
        @param instance The instance.
        @return The serialized instance JSON.
        */
        static toJson(instance: fm.liveswitch.MediaTrackReport): string;
        /**
        Serializes an array to JSON.
        @param array The array.
        @return The serialized array JSON.
        */
        static toJsonArray(array: fm.liveswitch.MediaTrackReport[]): string;
        /**
        Deserializes the properties.
        @param key The key.
        @param valueJson The value in JSON format.
        */
        protected deserializeProperties(key: string, valueJson: string): void;
        /**
        Gets the bitrate.
        */
        getBitrate(): number;
        /**
        Gets the frame height.
        */
        getFrameHeight(): number;
        /**
        Gets the frame rate.
        */
        getFrameRate(): number;
        /**
        Gets the number of frames corrupted.
        */
        getFramesCorrupted(): number;
        /**
        Gets the number of frames decoded.
        */
        getFramesDecoded(): number;
        /**
        Gets the number of frames dropped.
        */
        getFramesDropped(): number;
        /**
        Gets the number of frames encoded.
        */
        getFramesEncoded(): number;
        /**
        Gets the number of frames received.
        */
        getFramesReceived(): number;
        /**
        Gets the number of frames sent.
        */
        getFramesSent(): number;
        /**
        Gets the frame width.
        */
        getFrameWidth(): number;
        /**
        Gets the maximum bitrate.
        */
        getMaxBitrate(): number;
        /**
        Gets the minimum bitrate.
        */
        getMinBitrate(): number;
        /**
        Serializes the properties.
        @param jsonObject The JSON object.
        */
        protected serializeProperties(jsonObject: fm.liveswitch.Hash<string, string>): void;
        /**
        Sets the bitrate.
        */
        setBitrate(value: number): void;
        /**
        Sets the frame height.
        */
        setFrameHeight(value: number): void;
        /**
        Sets the frame rate.
        */
        setFrameRate(value: number): void;
        /**
        Sets the number of frames corrupted.
        */
        setFramesCorrupted(value: number): void;
        /**
        Sets the number of frames decoded.
        */
        setFramesDecoded(value: number): void;
        /**
        Sets the number of frames dropped.
        */
        setFramesDropped(value: number): void;
        /**
        Sets the number of frames encoded.
        */
        setFramesEncoded(value: number): void;
        /**
        Sets the number of frames received.
        */
        setFramesReceived(value: number): void;
        /**
        Sets the number of frames sent.
        */
        setFramesSent(value: number): void;
        /**
        Sets the frame width.
        */
        setFrameWidth(value: number): void;
        /**
        Sets the maximum bitrate.
        */
        setMaxBitrate(value: number): void;
        /**
        Sets the minimum bitrate.
        */
        setMinBitrate(value: number): void;
        /**
        Serializes this instance to JSON.
        */
        toJson(): string;
    }
}
declare namespace fm.liveswitch {
    /**
    A channel claim.
    */
    class ChannelClaim {
        getTypeString(): string;
        /** @hidden */
        private _action;
        /** @hidden */
        private _audioReceiveWhitelist;
        /** @hidden */
        private _broadcast;
        /** @hidden */
        private _canKick;
        /** @hidden */
        private _canUpdate;
        /** @hidden */
        private _dataReceiveWhitelist;
        /** @hidden */
        private _disableMcu;
        /** @hidden */
        private _disablePeer;
        /** @hidden */
        private _disableRemoteClientEvents;
        /** @hidden */
        private _disableRemoteUpstreamConnectionEvents;
        /** @hidden */
        private _disableSendAudio;
        /** @hidden */
        private _disableSendData;
        /** @hidden */
        private _disableSendMessage;
        /** @hidden */
        private _disableSendVideo;
        /** @hidden */
        private _disableSfu;
        /** @hidden */
        private _id;
        /** @hidden */
        private _videoReceiveWhitelist;
        private fmliveswitchChannelClaimInit;
        constructor();
        /**
        Initializes a new instance of the [[fm.liveswitch.channelClaim]] class.
        @param idValue The channel identifier.
        */
        constructor(idValue: string);
        /**
        Deserializes a channel claim from JSON.
        @param channelClaimJson The channel claim JSON.
        */
        static fromJson(channelClaimJson: string): fm.liveswitch.ChannelClaim;
        /**
        Deserializes an array of channel claims from JSON.
        @param channelClaimsJson The channel claims JSON.
        */
        static fromJsonArray(channelClaimsJson: string): fm.liveswitch.ChannelClaim[];
        /**
        Serializes a channel claim to JSON.
        @param channelClaim The channel claim to serialize.
        */
        static toJson(channelClaim: fm.liveswitch.ChannelClaim): string;
        /**
        Serializes an array of channel claims to JSON.
        @param channelClaims The channel claims.
        */
        static toJsonArray(channelClaims: fm.liveswitch.ChannelClaim[]): string;
        /**
        Gets the action of this channel claim. Possible values are in the [[fm.liveswitch.claimAction]] class.
        */
        getAction(): string;
        /**
        Gets a whitelist of roles whose member's audio can be received from. Null disables the whitelist whereas an empty list disables all receiving.
        */
        getAudioReceiveWhitelist(): string[];
        /**
        Gets if this is a broadcast channel or not.
        */
        getBroadcast(): boolean;
        /**
        Gets whether the user is authorized kick other users from this channel.
        */
        getCanKick(): boolean;
        /**
        Gets whether the user is authorized to update a media server channel.
        */
        getCanUpdate(): boolean;
        /**
        Gets a whitelist of roles whose member's data can be received from. Null disables the whitelist whereas an empty list disables all receiving.
        */
        getDataReceiveWhitelist(): string[];
        /**
        Gets whether the user is NOT authorized to create MCU connections.
        */
        getDisableMcu(): boolean;
        /**
        Gets whether the user is NOT authorized to create peer connections.
        */
        getDisablePeer(): boolean;
        /**
        Gets whether to disable remote client join/update/leave messages and events.
        */
        getDisableRemoteClientEvents(): boolean;
        /**
        Gets whether to disable remote connection open/update/close messages and events.
        */
        getDisableRemoteUpstreamConnectionEvents(): boolean;
        /**
        Gets whether the user is NOT authorized to send audio.
        */
        getDisableSendAudio(): boolean;
        /**
        Gets whether the user is NOT authorized to send data.
        */
        getDisableSendData(): boolean;
        /**
        Gets whether the user is NOT authorized to send messages.
        */
        getDisableSendMessage(): boolean;
        /**
        Gets whether the user is NOT authorized to send video.
        */
        getDisableSendVideo(): boolean;
        /**
        Gets whether the user is NOT authorized to create SFU connections.
        */
        getDisableSfu(): boolean;
        /**
        Gets the channel identifier.
        */
        getId(): string;
        /**
        Gets a whitelist of roles whose member's video can be received from. Null disables the whitelist whereas an empty list disables all receiving.
        */
        getVideoReceiveWhitelist(): string[];
        /**
        Sets the action of this channel claim. Possible values are in the [[fm.liveswitch.claimAction]] class.
        */
        setAction(value: string): void;
        /**
        Sets a whitelist of roles whose member's audio can be received from. Null disables the whitelist whereas an empty list disables all receiving.
        */
        setAudioReceiveWhitelist(value: string[]): void;
        /**
        Sets if this is a broadcast channel or not.
        */
        setBroadcast(value: boolean): void;
        /**
        Sets whether the user is authorized kick other users from this channel.
        */
        setCanKick(value: boolean): void;
        /**
        Sets whether the user is authorized to update a media server channel.
        */
        setCanUpdate(value: boolean): void;
        /**
        Sets a whitelist of roles whose member's data can be received from. Null disables the whitelist whereas an empty list disables all receiving.
        */
        setDataReceiveWhitelist(value: string[]): void;
        /**
        Sets whether the user is NOT authorized to create MCU connections.
        */
        setDisableMcu(value: boolean): void;
        /**
        Sets whether the user is NOT authorized to create peer connections.
        */
        setDisablePeer(value: boolean): void;
        /**
        Sets whether to disable remote client join/update/leave messages and events.
        */
        setDisableRemoteClientEvents(value: boolean): void;
        /**
        Sets whether to disable remote connection open/update/close messages and events.
        */
        setDisableRemoteUpstreamConnectionEvents(value: boolean): void;
        /**
        Sets whether the user is NOT authorized to send audio.
        */
        setDisableSendAudio(value: boolean): void;
        /**
        Sets whether the user is NOT authorized to send data.
        */
        setDisableSendData(value: boolean): void;
        /**
        Sets whether the user is NOT authorized to send messages.
        */
        setDisableSendMessage(value: boolean): void;
        /**
        Sets whether the user is NOT authorized to send video.
        */
        setDisableSendVideo(value: boolean): void;
        /**
        Sets whether the user is NOT authorized to create SFU connections.
        */
        setDisableSfu(value: boolean): void;
        /**
        Sets the channel identifier.
        */
        setId(value: string): void;
        /**
        Sets a whitelist of roles whose member's video can be received from. Null disables the whitelist whereas an empty list disables all receiving.
        */
        setVideoReceiveWhitelist(value: string[]): void;
        /**
        Serializes this channel claim to JSON.
        */
        toJson(): string;
    }
}
declare namespace fm.liveswitch {
    /**
    Channel information.
    */
    class ChannelInfo extends fm.liveswitch.Info {
        getTypeString(): string;
        /** @hidden */
        private _applicationId;
        /** @hidden */
        private _recording;
        /** @hidden */
        private _report;
        private fmliveswitchChannelInfoInit;
        constructor();
        /**
        Deserializes Json to a ChannelInfo.
        @param channelInfoJson The serialized Json.
        @return The deserialized ChannelInfo.
        */
        static fromJson(channelInfoJson: string): fm.liveswitch.ChannelInfo;
        /**
        Serializes an instance to Json.
        @param channel The instance to serialize.
        @return Serialized Json.
        */
        static toJson(channel: fm.liveswitch.ChannelInfo): string;
        /**
        Deserializes the properties.
        @param key The key.
        @param valueJson The value in JSON format.
        */
        protected deserializeProperties(key: string, valueJson: string): void;
        /**
        Gets the application identifier.
        */
        getApplicationId(): string;
        /**
        Gets whether the channel is recording.
        */
        getRecording(): boolean;
        /**
        Gets the channel report.
        */
        getReport(): fm.liveswitch.ChannelReport;
        /**
        Serializes the properties.
        @param jsonObject The JSON object.
        */
        protected serializeProperties(jsonObject: fm.liveswitch.Hash<string, string>): void;
        /**
        Sets the application identifier.
        */
        setApplicationId(value: string): void;
        /**
        Sets whether the channel is recording.
        */
        setRecording(value: boolean): void;
        /**
        Sets the channel report.
        */
        setReport(value: fm.liveswitch.ChannelReport): void;
        /**
        Serializes this instance to Json.
        */
        toJson(): string;
    }
}
declare namespace fm.liveswitch {
    /**
    Client information.
    */
    class ClientInfo extends fm.liveswitch.Info {
        getTypeString(): string;
        /** @hidden */
        private _applicationId;
        /** @hidden */
        private _architecture;
        /** @hidden */
        private _coreCount;
        /** @hidden */
        private _deviceAlias;
        /** @hidden */
        private _deviceId;
        /** @hidden */
        private _externalId;
        /** @hidden */
        private _machineName;
        /** @hidden */
        private _operatingSystem;
        /** @hidden */
        private _operatingSystemVersion;
        /** @hidden */
        private _physicalMemory;
        /** @hidden */
        private _region;
        /** @hidden */
        private _report;
        /** @hidden */
        private _roles;
        /** @hidden */
        private _sourceLanguage;
        /** @hidden */
        private _tag;
        /** @hidden */
        private _userAlias;
        /** @hidden */
        private _userId;
        /** @hidden */
        private _version;
        private fmliveswitchClientInfoInit;
        /**
        Initializes a new instance of the [[fm.liveswitch.clientInfo]] class.
        */
        constructor();
        /**
        Initializes a new instance of the [[fm.liveswitch.clientInfo]] class.
        @param userId The user identifier.
        @param deviceId The device identifier.
        @param idValue The client identifier.
        */
        constructor(userId: string, deviceId: string, idValue: string);
        /**
        Initializes a new instance of the [[fm.liveswitch.clientInfo]] class.
        @param userId The user identifier.
        @param userAlias The user alias.
        @param deviceId The device identifier.
        @param deviceAlias The device alias.
        @param idValue The client identifier.
        @param tag The client tag.
        @param roles The client roles.
        */
        constructor(userId: string, userAlias: string, deviceId: string, deviceAlias: string, idValue: string, tag: string, roles: string[]);
        /**
        Initializes a new instance of the [[fm.liveswitch.clientInfo]] class.
        @param userId The user identifier.
        @param userAlias The user alias.
        @param deviceId The device identifier.
        @param deviceAlias The device alias.
        @param idValue The client identifier.
        @param tag The client tag.
        @param roles The client roles.
        @param region The client's region.
        */
        constructor(userId: string, userAlias: string, deviceId: string, deviceAlias: string, idValue: string, tag: string, roles: string[], region: string);
        /**
        Deserializes an instance from JSON.
        @param clientInfoJson The JSON to deserialize.
        @return
                    The deserialized client info.
            
        */
        static fromJson(clientInfoJson: string): fm.liveswitch.ClientInfo;
        /**
        Deserializes an array of instances from JSON.
        @param clientInfosJson The JSON to deserialize.
        @return
                    The deserialized client infos.
            
        */
        static fromJsonArray(clientInfosJson: string): fm.liveswitch.ClientInfo[];
        /**
        Serializes an instance to JSON.
        @param clientInfo The client info to serialize.
        @return
                    The serialized JSON.
            
        */
        static toJson(clientInfo: fm.liveswitch.ClientInfo): string;
        /**
        Serializes an array of instances to JSON.
        @param clientInfos The client infos to serialize.
        @return
                    The serialized JSON.
            
        */
        static toJsonArray(clientInfos: fm.liveswitch.ClientInfo[]): string;
        /** @hidden */
        deflate(): fm.liveswitch.ClientInfo;
        /**
        Deserializes the properties.
        @param key The key.
        @param valueJson The value in JSON format.
        */
        protected deserializeProperties(key: string, valueJson: string): void;
        /**
        Gets the application identifier.
        */
        getApplicationId(): string;
        /**
        Gets the client architecture.
        */
        getArchitecture(): string;
        /**
        Gets the client core count.
        */
        getCoreCount(): number;
        /**
        Gets the device alias.
        */
        getDeviceAlias(): string;
        /**
        Gets the device identifier.
        */
        getDeviceId(): string;
        /**
        Gets the client external identifier.
        */
        getExternalId(): string;
        /**
        Gets the client machine name.
        */
        getMachineName(): string;
        /**
        Gets the client operating system.
        */
        getOperatingSystem(): string;
        /**
        Gets the client operating system version.
        */
        getOperatingSystemVersion(): string;
        /**
        Gets the connector physical memory.
        */
        getPhysicalMemory(): number;
        /**
        Gets the client region.
        */
        getRegion(): string;
        /**
        Gets the client report.
        */
        getReport(): fm.liveswitch.ClientReport;
        /**
        Gets the client roles.
        */
        getRoles(): string[];
        /**
        Gets the client source language.
        */
        getSourceLanguage(): string;
        /**
        Gets the client tag.
        */
        getTag(): string;
        /**
        Gets the user alias.
        */
        getUserAlias(): string;
        /**
        Gets the user identifier.
        */
        getUserId(): string;
        /**
        Gets the client version.
        */
        getVersion(): string;
        /** @hidden */
        inflate(userAlias: string, deviceAlias: string, tag: string, roles: string[]): void;
        /**
        Tests for equivalency.
        @param clientInfo The client information.
        @return `true` if equivalent; otherwise, `false`.
            
        */
        isEquivalent(clientInfo: fm.liveswitch.ClientInfo): boolean;
        /**
        Tests for equivalency.
        @param connectionInfo The connection information.
        @return `true` if equivalent; otherwise, `false`.
            
        */
        isEquivalent(connectionInfo: fm.liveswitch.ConnectionInfo): boolean;
        /**
        Tests equivalency.
        @param userId The user identifier.
        @param deviceId The device identifier.
        @param idValue The client identifier.
        @return `true` if equivalent; otherwise, `false`.
            
        */
        isEquivalent(userId: string, deviceId: string, idValue: string): boolean;
        /**
        Serializes the properties.
        @param jsonObject The JSON object.
        */
        protected serializeProperties(jsonObject: fm.liveswitch.Hash<string, string>): void;
        /**
        Sets the application identifier.
        */
        setApplicationId(value: string): void;
        /**
        Sets the client architecture.
        */
        setArchitecture(value: string): void;
        /**
        Sets the client core count.
        */
        setCoreCount(value: number): void;
        /**
        Sets the device alias.
        */
        setDeviceAlias(value: string): void;
        /**
        Sets the device identifier.
        */
        setDeviceId(value: string): void;
        /**
        Sets the client external identifier.
        */
        setExternalId(value: string): void;
        /**
        Sets the client machine name.
        */
        setMachineName(value: string): void;
        /**
        Sets the client operating system.
        */
        setOperatingSystem(value: string): void;
        /**
        Sets the client operating system version.
        */
        setOperatingSystemVersion(value: string): void;
        /**
        Sets the connector physical memory.
        */
        setPhysicalMemory(value: number): void;
        /**
        Sets the client region.
        */
        setRegion(value: string): void;
        /**
        Sets the client report.
        */
        setReport(value: fm.liveswitch.ClientReport): void;
        /**
        Sets the client roles.
        */
        setRoles(value: string[]): void;
        /**
        Sets the client source language.
        */
        setSourceLanguage(value: string): void;
        /**
        Sets the client tag.
        */
        setTag(value: string): void;
        /**
        Sets the user alias.
        */
        setUserAlias(value: string): void;
        /**
        Sets the user identifier.
        */
        setUserId(value: string): void;
        /**
        Sets the client version.
        */
        setVersion(value: string): void;
        /**
        Serializes this instance to Json.
        */
        toJson(): string;
    }
}
declare namespace fm.liveswitch {
    class ClientStateWrapper {
        getTypeString(): string;
        /** @hidden */
        private _value;
        constructor(value: fm.liveswitch.ClientState);
        toString(): string;
    }
}
declare namespace fm.liveswitch {
    /**
    Connection information.
    */
    class ConnectionInfo extends fm.liveswitch.Info {
        getTypeString(): string;
        /** @hidden */
        private __serializeLegacyProperties;
        /** @hidden */
        private _applicationId;
        /** @hidden */
        private _audioStreams;
        /** @hidden */
        private _channelId;
        /** @hidden */
        private _clientId;
        /** @hidden */
        private _clientRoles;
        /** @hidden */
        private _clientTag;
        /** @hidden */
        private _dataStream;
        /** @hidden */
        private _deviceAlias;
        /** @hidden */
        private _deviceId;
        /** @hidden */
        private _error;
        /** @hidden */
        private _externalId;
        /** @hidden */
        private _mediaId;
        /** @hidden */
        private _recording;
        /** @hidden */
        private _remoteConnectionId;
        /** @hidden */
        private _remoteMediaId;
        /** @hidden */
        private _state;
        /** @hidden */
        private _tag;
        /** @hidden */
        private _transports;
        /** @hidden */
        private _type;
        /** @hidden */
        private _userAlias;
        /** @hidden */
        private _userId;
        /** @hidden */
        private _videoStreams;
        private fmliveswitchConnectionInfoInit;
        /**
        Initializes a new instance of the [[fm.liveswitch.connectionInfo]] class.
        */
        constructor();
        constructor(idValue: string, applicationId: string, channelId: string, userId: string, deviceId: string, clientId: string);
        /**
        Initializes a new instance of the [[fm.liveswitch.connectionInfo]] class.
        @param userId The user identifier.
        @param deviceId The device identifier.
        @param clientId The client identifier.
        @param idValue The connection identifier.
        @param tag The connection tag.
        @param type The connection type.
        @param mediaId The media identifier.
        @param localAudioMuted The audio muted boolean.
        @param localVideoMuted The video muted boolean.
        @param audioDirection The audio direction.
        @param videoDirection The video direction.
        @param dataDirection The data direction.
        @param audioFormats The audio formats.
        @param videoFormats The video formats.
        */
        constructor(userId: string, deviceId: string, clientId: string, idValue: string, tag: string, type: string, mediaId: string, localAudioMuted: boolean, localVideoMuted: boolean, audioDirection: string, videoDirection: string, dataDirection: string, audioFormats: fm.liveswitch.FormatInfo[], videoFormats: fm.liveswitch.FormatInfo[]);
        /**
        Initializes a new instance of the [[fm.liveswitch.connectionInfo]] class.
        @param userId The user identifier.
        @param userAlias The user alias.
        @param deviceId The device identifier.
        @param deviceAlias The device alias.
        @param clientId The client identifier.
        @param clientTag The client tag.
        @param clientRoles The client roles.
        @param idValue The connection identifier.
        @param tag The connection tag.
        @param type The connection type.
        @param mediaId The media identifier.
        @param localAudioMuted The audio muted boolean.
        @param localVideoMuted The video muted boolean.
        @param audioDirection The audio direction.
        @param videoDirection The video direction.
        @param dataDirection The data direction.
        @param audioFormats The audio formats.
        @param videoFormats The video formats.
        */
        constructor(userId: string, userAlias: string, deviceId: string, deviceAlias: string, clientId: string, clientTag: string, clientRoles: string[], idValue: string, tag: string, type: string, mediaId: string, localAudioMuted: boolean, localVideoMuted: boolean, audioDirection: string, videoDirection: string, dataDirection: string, audioFormats: fm.liveswitch.FormatInfo[], videoFormats: fm.liveswitch.FormatInfo[]);
        /**
        Deserializes Json to a ConnectionInfo.
        @param connectionInfoJson The serialized Json.
        @return The deserialized ConnectionInfo.
        */
        static fromJson(connectionInfoJson: string): fm.liveswitch.ConnectionInfo;
        /**
        Deserializes an array of instances from JSON.
        @param connectionInfosJson The JSON to deserialize.
        @return
                    The deserialized connection infos.
            
        */
        static fromJsonArray(connectionInfosJson: string): fm.liveswitch.ConnectionInfo[];
        /**
        Serializes an instance to Json.
        @param connectionInfo The instance to serialize.
        @return Serialized Json.
        */
        static toJson(connectionInfo: fm.liveswitch.ConnectionInfo): string;
        /**
        Serializes an array of instances to JSON.
        @param connectionInfos The connection infos to serialize.
        @return
                    The serialized JSON.
            
        */
        static toJsonArray(connectionInfos: fm.liveswitch.ConnectionInfo[]): string;
        /**
        Creates a client info object with details from this connection info object.
        */
        createClientInfo(): fm.liveswitch.ClientInfo;
        /**
        Deserializes the properties.
        @param key The key.
        @param valueJson The value in JSON format.
        */
        protected deserializeProperties(key: string, valueJson: string): void;
        /**
        Gets the application identifier.
        */
        getApplicationId(): string;
        /**
        Gets the audio stream direction. Obsolete. Use AudioStream.Direction instead.
        */
        getAudioDirection(): string;
        /**
        Gets the audio formats, if applicable. Obsolete. Use AudioStream.Formats instead.
        */
        getAudioFormats(): fm.liveswitch.FormatInfo[];
        /**
        Gets the first connection audio stream.
        */
        getAudioStream(): fm.liveswitch.MediaStreamInfo;
        /**
        Gets the connection audio streams.
        */
        getAudioStreams(): fm.liveswitch.MediaStreamInfo[];
        /**
        Gets the channel identifier.
        */
        getChannelId(): string;
        /**
        Gets the client identifier.
        */
        getClientId(): string;
        /**
        Gets the client roles.
        */
        getClientRoles(): string[];
        /**
        Gets the client tag.
        */
        getClientTag(): string;
        /**
        Gets the data stream direction. Obsolete.
        */
        getDataDirection(): string;
        /**
        Gets the connection data stream.
        */
        getDataStream(): fm.liveswitch.DataStreamInfo;
        /**
        Gets the device alias.
        */
        getDeviceAlias(): string;
        /**
        Gets the device identifier.
        */
        getDeviceId(): string;
        /**
        Gets the connection error, if an error exists.
        */
        getError(): fm.liveswitch.Error;
        /**
        Gets the connection external identifier.
        */
        getExternalId(): string;
        /**
        Gets a value indicating whether the connection has an audio stream.
        */
        getHasAudio(): boolean;
        /**
        Gets a value indicating whether the connection has a data stream.
        */
        getHasData(): boolean;
        /**
        Gets a value indicating whether the connection has a video stream.
        */
        getHasVideo(): boolean;
        /**
        Gets if local audio is disabled. Obsolete. Use AudioStream.SendDisabled instead.
        */
        getLocalAudioDisabled(): boolean;
        /**
        Gets if the local audio is muted. Obsolete. Use AudioStream.Muted instead.
        */
        getLocalAudioMuted(): boolean;
        /**
        Gets if local video is disabled. Obsolete. Use VideoStream.SendDisabled instead.
        */
        getLocalVideoDisabled(): boolean;
        /**
        Gets if the local video is muted. Obsolete. Use VideoStream.Muted instead.
        */
        getLocalVideoMuted(): boolean;
        /**
        Gets the media identifier, for MCU or SFU upstream connections.
        */
        getMediaId(): string;
        /**
        Gets whether the connection is recording.
        */
        getRecording(): boolean;
        /**
        Gets if remote audio is disabled. Obsolete. Use AudioStream.ReceiveDisabled instead.
        */
        getRemoteAudioDisabled(): boolean;
        /**
        Gets the remote connection identifier, for peer or SFU downstream connections.
        */
        getRemoteConnectionId(): string;
        /**
        Gets the remote media identifier, for SFU downstream connections.
        */
        getRemoteMediaId(): string;
        /**
        Gets if remote video is disabled. Obsolete. Use VideoStream.ReceiveDisabled instead.
        */
        getRemoteVideoDisabled(): boolean;
        /** @hidden */
        getSerializeLegacyProperties(): boolean;
        /**
        Gets the connection state.
        */
        getState(): string;
        /**
        Gets the connection tag.
        */
        getTag(): string;
        /**
        Gets the connection transport information. This will be `null` if BUNDLE is inactive.
        */
        getTransports(): fm.liveswitch.TransportInfo[];
        /**
        Gets the connection type.
        */
        getType(): string;
        /**
        Gets the user alias.
        */
        getUserAlias(): string;
        /**
        Gets the user identifier.
        */
        getUserId(): string;
        /**
        Gets the video stream direction. Obsolete. Use VideoStream.Direction instead.
        */
        getVideoDirection(): string;
        /**
        Gets the video formats, if applicable. Obsolete. Use VideoStream.Formats instead.
        */
        getVideoFormats(): fm.liveswitch.FormatInfo[];
        /**
        Gets the first connection video stream.
        */
        getVideoStream(): fm.liveswitch.MediaStreamInfo;
        /**
        Gets the connection video streams.
        */
        getVideoStreams(): fm.liveswitch.MediaStreamInfo[];
        /** @hidden */
        inflate(userAlias: string, deviceAlias: string, clientTag: string, clientRoles: string[]): void;
        /**
        Tests for equivalency.
        @param connectionInfo The connection information.
        @return `true` if equivalent; otherwise, `false`.
            
        */
        isEquivalent(connectionInfo: fm.liveswitch.ConnectionInfo): boolean;
        /**
        Tests for equivalency.
        @param userId The user identifier.
        @param deviceId The device identifier.
        @param clientId The client identifier.
        @param idValue The connection identifier.
        @return `true` if equivalent; otherwise, `false`.
            
        */
        isEquivalent(userId: string, deviceId: string, clientId: string, idValue: string): boolean;
        /** @hidden */
        populateInfo(stats: fm.liveswitch.ConnectionStats, lastStats: fm.liveswitch.ConnectionStats, eventType: string): void;
        /** @hidden */
        private scrubTransport;
        /**
        Serializes the properties.
        @param jsonObject The JSON object.
        */
        protected serializeProperties(jsonObject: fm.liveswitch.Hash<string, string>): void;
        /**
        Sets the application identifier.
        */
        setApplicationId(value: string): void;
        /** @hidden */
        private setAudioDirection;
        /** @hidden */
        private setAudioFormats;
        /**
        Sets the first connection audio stream.
        */
        setAudioStream(value: fm.liveswitch.MediaStreamInfo): void;
        /**
        Sets the connection audio streams.
        */
        setAudioStreams(value: fm.liveswitch.MediaStreamInfo[]): void;
        /**
        Sets the channel identifier.
        */
        setChannelId(value: string): void;
        /**
        Sets the client identifier.
        */
        setClientId(value: string): void;
        /**
        Sets the client roles.
        */
        setClientRoles(value: string[]): void;
        /**
        Sets the client tag.
        */
        setClientTag(value: string): void;
        /** @hidden */
        private setDataDirection;
        /**
        Sets the connection data stream.
        */
        setDataStream(value: fm.liveswitch.DataStreamInfo): void;
        /**
        Sets the device alias.
        */
        setDeviceAlias(value: string): void;
        /**
        Sets the device identifier.
        */
        setDeviceId(value: string): void;
        /**
        Sets the connection error, if an error exists.
        */
        setError(value: fm.liveswitch.Error): void;
        /**
        Sets the connection external identifier.
        */
        setExternalId(value: string): void;
        /** @hidden */
        private setLocalAudioDisabled;
        /** @hidden */
        private setLocalAudioMuted;
        /** @hidden */
        private setLocalVideoDisabled;
        /** @hidden */
        private setLocalVideoMuted;
        /**
        Sets the media identifier, for MCU or SFU upstream connections.
        */
        setMediaId(value: string): void;
        /**
        Sets whether the connection is recording.
        */
        setRecording(value: boolean): void;
        /** @hidden */
        private setRemoteAudioDisabled;
        /**
        Sets the remote connection identifier, for peer or SFU downstream connections.
        */
        setRemoteConnectionId(value: string): void;
        /**
        Sets the remote media identifier, for SFU downstream connections.
        */
        setRemoteMediaId(value: string): void;
        /** @hidden */
        private setRemoteVideoDisabled;
        /** @hidden */
        setSerializeLegacyProperties(value: boolean): void;
        /**
        Sets the connection state.
        */
        setState(value: string): void;
        /**
        Sets the connection tag.
        */
        setTag(value: string): void;
        /**
        Sets the connection transport information. This will be `null` if BUNDLE is inactive.
        */
        setTransports(value: fm.liveswitch.TransportInfo[]): void;
        /**
        Sets the connection type.
        */
        setType(value: string): void;
        /**
        Sets the user alias.
        */
        setUserAlias(value: string): void;
        /**
        Sets the user identifier.
        */
        setUserId(value: string): void;
        /** @hidden */
        private setVideoDirection;
        /** @hidden */
        private setVideoFormats;
        /**
        Sets the first connection video stream.
        */
        setVideoStream(value: fm.liveswitch.MediaStreamInfo): void;
        /**
        Sets the connection video streams.
        */
        setVideoStreams(value: fm.liveswitch.MediaStreamInfo[]): void;
        /** @hidden */
        private shouldIncludeReport;
        /**
        Gets whether to serialize the legacy audio direction property.
        */
        shouldSerializeAudioDirection(): boolean;
        /**
        Gets whether to serialize the legacy audio formats property.
        */
        shouldSerializeAudioFormats(): boolean;
        /**
        Gets whether to serialize the legacy data direction property.
        */
        shouldSerializeDataDirection(): boolean;
        /**
        Gets whether to serialize the legacy local audio muted property.
        */
        shouldSerializeLocalAudioMuted(): boolean;
        /**
        Gets whether to serialize the legacy local video muted property.
        */
        shouldSerializeLocalVideoMuted(): boolean;
        /**
        Gets whether to serialize the legacy video direction property.
        */
        shouldSerializeVideoDirection(): boolean;
        /**
        Gets whether to serialize the legacy video formats property.
        */
        shouldSerializeVideoFormats(): boolean;
        /**
        Serializes this instance to Json.
        */
        toJson(): string;
    }
}
declare namespace fm.liveswitch {
    /**
    A connection type.
    */
    class ConnectionType {
        getTypeString(): string;
        constructor();
        /**
        Gets the "mcu" connection type string.
        */
        static getMcu(): string;
        /**
        Gets the "peer" connection type string.
        */
        static getPeer(): string;
        /**
        Gets the "sfu" connection type string.
        */
        static getSfu(): string;
    }
}
declare namespace fm.liveswitch {
    /**
    Data channel report.
    */
    class DataChannelReport extends fm.liveswitch.Report {
        getTypeString(): string;
        /** @hidden */
        private _bytesReceived;
        /** @hidden */
        private _bytesSent;
        /** @hidden */
        private _messagesReceived;
        /** @hidden */
        private _messagesSent;
        private fmliveswitchDataChannelReportInit;
        /**
        Initializes a new instance of the [[fm.liveswitch.dataChannelReport]] class.
        */
        constructor();
        constructor(stats: fm.liveswitch.DataChannelStats, lastStats: fm.liveswitch.DataChannelStats, eventType: string);
        /**
        Deserializes Json to a DataChannelReport.
        @param dataChannelReportJson The serialized Json.
        @return The deserialized DataChannelReport.
        */
        static fromJson(dataChannelReportJson: string): fm.liveswitch.DataChannelReport;
        /**
        Serializes an instance to Json.
        @param dataChannelReport The instance to serialize.
        @return Serialized Json.
        */
        static toJson(dataChannelReport: fm.liveswitch.DataChannelReport): string;
        /**
        Deserializes the properties.
        @param key The key.
        @param valueJson The value in JSON format.
        */
        protected deserializeProperties(key: string, valueJson: string): void;
        /**
        Gets the number of bytes received on this data channel.
        */
        getBytesReceived(): number;
        /**
        Gets the number of bytes sent on this data channel.
        */
        getBytesSent(): number;
        /**
        Gets the number of messages received on this data channel.
        */
        getMessagesReceived(): number;
        /**
        Gets the number of messages sent on this data channel.
        */
        getMessagesSent(): number;
        /**
        Serializes the properties.
        @param jsonObject The JSON object.
        */
        protected serializeProperties(jsonObject: fm.liveswitch.Hash<string, string>): void;
        /**
        Sets the number of bytes received on this data channel.
        */
        setBytesReceived(value: number): void;
        /**
        Sets the number of bytes sent on this data channel.
        */
        setBytesSent(value: number): void;
        /**
        Sets the number of messages received on this data channel.
        */
        setMessagesReceived(value: number): void;
        /**
        Sets the number of messages sent on this data channel.
        */
        setMessagesSent(value: number): void;
        /**
        Serializes this instance to Json.
        */
        toJson(): string;
    }
}
declare namespace fm.liveswitch {
    /** @hidden */
    class ErrorType {
        getTypeString(): string;
        constructor();
        static getAccessChannelClaimDenied(): string;
        static getAccessMessageBlocked(): string;
        static getClientInvalidId(): string;
        static getClientUpgradeRequired(): string;
        static getMessageParseFailure(): string;
        static getMessageRegisterExpected(): string;
        static getMessageRegisterUnexpected(): string;
        static getMessageUnregisterUnexpected(): string;
        static getSdpCodecMismatch(): string;
        static getSdpSimulcastMismatch(): string;
        static getSdpStreamMismatch(): string;
        static getServerLicenseInvalid(): string;
        static getServerLicenseMissing(): string;
        static getServerNoAudioCodecs(): string;
        static getServerNoMediaServersAvailable(): string;
        static getServerNoVideoCodecs(): string;
        static getServerUnknownError(): string;
        static getServerUpgradeRequired(): string;
        static getSfuInvalidUpstream(): string;
        static getTokenApplicationMismatch(): string;
        static getTokenAuthFailure(): string;
        static getTokenClientMismatch(): string;
        static getTokenClientRoleMismatch(): string;
        static getTokenDeviceMismatch(): string;
        static getTokenExpired(): string;
        static getTokenMissing(): string;
        static getTokenMissingChannelClaim(): string;
        static getTokenParseFailure(): string;
        static getTokenRegionMismatch(): string;
        static getTokenUserMismatch(): string;
    }
}
declare namespace fm.liveswitch {
    /**
    Event information.
    */
    class EventInfo extends fm.liveswitch.Info {
        getTypeString(): string;
        /** @hidden */
        private _channel;
        /** @hidden */
        private _client;
        /** @hidden */
        private _connection;
        /** @hidden */
        private _forced;
        /** @hidden */
        private _message;
        /** @hidden */
        private _origin;
        /** @hidden */
        private _timestamp;
        /** @hidden */
        private _type;
        private fmliveswitchEventInfoInit;
        /**
        Initializes a new event.
        */
        constructor();
        /**
        Initializes a new event.
        @param type The type.
        */
        constructor(type: string);
        /**
        Deserializes an instance from JSON.
        */
        static fromJson(eventJson: string): fm.liveswitch.EventInfo;
        /**
        Deserializes an array from JSON.
        */
        static fromJsonArray(eventJsons: string): fm.liveswitch.EventInfo[];
        /**
        Serializes an instance to JSON.
        */
        static toJson(evt: fm.liveswitch.EventInfo): string;
        /**
        Serializes an array to JSON.
        */
        static toJsonArray(events: fm.liveswitch.EventInfo[]): string;
        /**
        Deserializes the properties.
        @param key The key.
        @param valueJson The value in JSON format.
        */
        protected deserializeProperties(key: string, valueJson: string): void;
        /**
        Gets the channel information.
        */
        getChannel(): fm.liveswitch.ChannelInfo;
        /**
        Gets the client information.
        */
        getClient(): fm.liveswitch.ClientInfo;
        /**
        Gets the connection information.
        */
        getConnection(): fm.liveswitch.ConnectionInfo;
        /**
        Gets whether this event was forced.
        */
        getForced(): boolean;
        /**
        Gets the message information.
        */
        getMessage(): fm.liveswitch.MessageInfo;
        /**
        Gets the event origin.
        */
        getOrigin(): string;
        /**
        Gets the event timestamp in milliseconds since epoch.
        */
        getTimestamp(): number;
        /**
        Gets the event type.
        */
        getType(): string;
        /**
        Serializes the properties.
        @param jsonObject The JSON object.
        */
        protected serializeProperties(jsonObject: fm.liveswitch.Hash<string, string>): void;
        /**
        Sets the channel information.
        */
        setChannel(value: fm.liveswitch.ChannelInfo): void;
        /**
        Sets the client information.
        */
        setClient(value: fm.liveswitch.ClientInfo): void;
        /**
        Sets the connection information.
        */
        setConnection(value: fm.liveswitch.ConnectionInfo): void;
        /**
        Sets whether this event was forced.
        */
        setForced(value: boolean): void;
        /**
        Sets the message information.
        */
        setMessage(value: fm.liveswitch.MessageInfo): void;
        /**
        Sets the event origin.
        */
        setOrigin(value: string): void;
        /**
        Sets the event timestamp in milliseconds since epoch.
        */
        setTimestamp(value: number): void;
        /**
        Sets the event type.
        */
        setType(value: string): void;
        /**
        Serializes this instance to JSON.
        */
        toJson(): string;
    }
}
declare namespace fm.liveswitch {
    /**
    Event origins.
    */
    abstract class EventOrigin {
        getTypeString(): string;
        /**
        Gets the 'client' event origin string.
        */
        static getClient(): string;
        /**
        Gets the 'gateway' event origin string.
        */
        static getGateway(): string;
        /**
        Gets the 'mediaserver' event origin string.
        */
        static getMediaServer(): string;
        /**
        Gets the 'sipconnector' event origin string.
        */
        static getSipConnector(): string;
    }
}
declare namespace fm.liveswitch {
    /**
    Network information.
    */
    class NetworkInfo {
        getTypeString(): string;
        /** @hidden */
        private _ipAddresses;
        /** @hidden */
        private _ports;
        constructor();
        /**
        Deserializes Json to a GatewayInfo.
        @param networkInfoJson The serialized Json.
        @return The deserialized GatewayInfo.
        */
        static fromJson(networkInfoJson: string): fm.liveswitch.NetworkInfo;
        /**
        Serializes an instance to Json.
        @param networkInfo The instance to serialize.
        @return Serialized Json.
        */
        static toJson(networkInfo: fm.liveswitch.NetworkInfo): string;
        /**
        Deserializes the properties.
        @param key The key.
        @param valueJson The value in JSON format.
        */
        protected deserializeProperties(key: string, valueJson: string): void;
        /**
        Gets the IP addresses.
        */
        getIPAddresses(): string[];
        /**
        Gets the ports.
        */
        getPorts(): number[];
        /**
        Serializes the properties.
        @param jsonObject The JSON object.
        */
        protected serializeProperties(jsonObject: fm.liveswitch.Hash<string, string>): void;
        /**
        Sets the IP addresses.
        */
        setIPAddresses(value: string[]): void;
        /**
        Sets the ports.
        */
        setPorts(value: number[]): void;
        /**
        Serializes this instance to Json.
        */
        toJson(): string;
    }
}
declare namespace fm.liveswitch {
    /**
    External network information.
    */
    class ExternalNetworkInfo extends fm.liveswitch.NetworkInfo {
        getTypeString(): string;
        /** @hidden */
        private _publicHostname;
        /** @hidden */
        private _publicIPAddress;
        constructor();
        /**
        Deserializes Json to a ExternalNetworkInfo.
        @param networkInfoJson The serialized Json.
        @return The deserialized ExternalNetworkInfo.
        */
        static fromJson(networkInfoJson: string): fm.liveswitch.ExternalNetworkInfo;
        /**
        Serializes an instance to Json.
        @param networkInfo The instance to serialize.
        @return Serialized Json.
        */
        static toJson(networkInfo: fm.liveswitch.ExternalNetworkInfo): string;
        /**
        Deserializes the properties.
        @param key The key.
        @param valueJson The value in JSON format.
        */
        protected deserializeProperties(key: string, valueJson: string): void;
        /**
        Gets the public hostname.
        */
        getPublicHostname(): string;
        /**
        Gets the public IP address.
        */
        getPublicIPAddress(): string;
        /**
        Serializes the properties.
        @param jsonObject The JSON object.
        */
        protected serializeProperties(jsonObject: fm.liveswitch.Hash<string, string>): void;
        /**
        Sets the public hostname.
        */
        setPublicHostname(value: string): void;
        /**
        Sets the public IP address.
        */
        setPublicIPAddress(value: string): void;
    }
}
declare namespace fm.liveswitch {
    /**
    Internal network information.
    */
    class InternalNetworkInfo extends fm.liveswitch.NetworkInfo {
        getTypeString(): string;
        constructor();
        /**
        Deserializes Json to a InternalNetworkInfo.
        @param networkInfoJson The serialized Json.
        @return The deserialized InternalNetworkInfo.
        */
        static fromJson(networkInfoJson: string): fm.liveswitch.InternalNetworkInfo;
        /**
        Serializes an instance to Json.
        @param networkInfo The instance to serialize.
        @return Serialized Json.
        */
        static toJson(networkInfo: fm.liveswitch.InternalNetworkInfo): string;
        /**
        Deserializes the properties.
        @param key The key.
        @param valueJson The value in JSON format.
        */
        protected deserializeProperties(key: string, valueJson: string): void;
        /**
        Serializes the properties.
        @param jsonObject The JSON object.
        */
        protected serializeProperties(jsonObject: fm.liveswitch.Hash<string, string>): void;
    }
}
declare namespace fm.liveswitch {
    class InvitationStateWrapper {
        getTypeString(): string;
        /** @hidden */
        private _value;
        constructor(value: fm.liveswitch.InvitationState);
        toString(): string;
    }
}
declare namespace fm.liveswitch {
    /**
    A class containing the feedback from invite requests.
    */
    class InviteFeedback {
        getTypeString(): string;
        /** @hidden */
        private _protocol;
        /** @hidden */
        private _reason;
        /** @hidden */
        private _state;
        /** @hidden */
        private _userId;
        constructor();
        /**
        Creates an instance of a InviteFeedback class.
        @param userId The user id of the user being invited.
        @param protocol The protocol the original invite was using.
        @param state The current state of the invite.
        @param reason The detailed reason if available.
        */
        constructor(userId: string, protocol: string, state: fm.liveswitch.InvitationState, reason: string);
        /** @hidden */
        private static deserializeState;
        /**
        Deserializes an instance from JSON.
        @param feedbackJson The JSON to deserialize.
        @return
                    The deserialized invite feedback.
            
        */
        static fromJson(feedbackJson: string): fm.liveswitch.InviteFeedback;
        /** @hidden */
        private static serializeState;
        /**
        Serializes an instance to JSON.
        @param feedback The invite feedback to serialize.
        @return
                    The serialized JSON.
            
        */
        static toJson(feedback: fm.liveswitch.InviteFeedback): string;
        /**
        Gets the protocol the user was invited on.
        */
        getProtocol(): string;
        /**
        Gets the detailed reason for the state if available.
        */
        getReason(): string;
        /**
        Gets the current state of the invite.
        */
        getState(): fm.liveswitch.InvitationState;
        /**
        Gets the user id for the user being invited.
        */
        getUserId(): string;
        /** @hidden */
        private setProtocol;
        /** @hidden */
        private setReason;
        /** @hidden */
        private setState;
        /** @hidden */
        private setUserId;
        /**
        Serializes this instance to JSON.
        */
        toJson(): string;
    }
}
declare namespace fm.liveswitch {
    /**
    Log event information.
    */
    class LogEventInfo extends fm.liveswitch.Info {
        getTypeString(): string;
        /** @hidden */
        private _exception;
        /** @hidden */
        private _level;
        /** @hidden */
        private _message;
        /** @hidden */
        private _scope;
        /** @hidden */
        private _tag;
        /** @hidden */
        private _threadId;
        private fmliveswitchLogEventInfoInit;
        constructor();
        /**
        Deserializes Json to a LogEventInfo.
        @param logEventInfoJson The serialized Json.
        @return The deserialized LogEventInfo.
        */
        static fromJson(logEventInfoJson: string): fm.liveswitch.LogEventInfo;
        /**
        Serializes an instance to Json.
        @param logEventInfo The instance to serialize.
        @return Serialized Json.
        */
        static toJson(logEventInfo: fm.liveswitch.LogEventInfo): string;
        /**
        Deserializes the properties.
        @param key The key.
        @param valueJson The value in JSON format.
        */
        protected deserializeProperties(key: string, valueJson: string): void;
        /**
        Gets the log event exception message.
        */
        getException(): string;
        /**
        Gets the log event level.
        */
        getLevel(): string;
        /**
        Gets the log event message.
        */
        getMessage(): string;
        /**
        Gets the log event scope.
        */
        getScope(): string;
        /**
        Gets the log event tag.
        */
        getTag(): string;
        /**
        Gets the log event thread ID.
        */
        getThreadId(): number;
        /**
        Serializes the properties.
        @param jsonObject The JSON object.
        */
        protected serializeProperties(jsonObject: fm.liveswitch.Hash<string, string>): void;
        /**
        Sets the log event exception message.
        */
        setException(value: string): void;
        /** @hidden */
        private setLevel;
        /**
        Sets the log event message.
        */
        setMessage(value: string): void;
        /**
        Sets the log event scope.
        */
        setScope(value: string): void;
        /**
        Sets the log event tag.
        */
        setTag(value: string): void;
        /**
        Sets the log event thread ID.
        */
        setThreadId(value: number): void;
        /**
        Serializes this instance to Json.
        */
        toJson(): string;
    }
}
declare namespace fm.liveswitch {
    /**
    Media information.
    */
    abstract class MediaInfo extends fm.liveswitch.Info {
        getTypeString(): string;
        constructor();
        /**
        Deserializes the properties.
        @param key The key.
        @param valueJson The value in JSON format.
        */
        protected deserializeProperties(key: string, valueJson: string): void;
        /**
        Serializes the properties.
        @param jsonObject The JSON object.
        */
        protected serializeProperties(jsonObject: fm.liveswitch.Hash<string, string>): void;
    }
}
declare namespace fm.liveswitch {
    /**
    Media receiver report.
    */
    class MediaReceiverReport extends fm.liveswitch.MediaComponentReport {
        getTypeString(): string;
        /** @hidden */
        private _bytesReceived;
        /** @hidden */
        private _jitter;
        /** @hidden */
        private _packetsDiscarded;
        /** @hidden */
        private _packetsDuplicated;
        /** @hidden */
        private _packetsLost;
        /** @hidden */
        private _packetsReceived;
        /** @hidden */
        private _packetsRepaired;
        private fmliveswitchMediaReceiverReportInit;
        /**
        Initializes a new instance of the [[fm.liveswitch.mediaReceiverReport]] class.
        */
        constructor();
        constructor(stats: fm.liveswitch.MediaReceiverStats, lastStats: fm.liveswitch.MediaReceiverStats);
        /**
        Deserializes an instance from JSON.
        @param mediaReceiverReportJson The serialized JSON.
        @return The deserialized instance.
        */
        static fromJson(mediaReceiverReportJson: string): fm.liveswitch.MediaReceiverReport;
        /**
        Deserializes an array from JSON.
        @param mediaReceiverReportsJson The serialized JSON.
        @return The deserialized array.
        */
        static fromJsonArray(mediaReceiverReportsJson: string): fm.liveswitch.MediaReceiverReport[];
        /**
        Serializes an instance to JSON.
        @param mediaReceiverReport The instance to serialize.
        @return The serialized JSON.
        */
        static toJson(mediaReceiverReport: fm.liveswitch.MediaReceiverReport): string;
        /**
        Serializes an array to JSON.
        @param mediaReceiverReports The array to serialize.
        @return The serialized JSON.
        */
        static toJsonArray(mediaReceiverReports: fm.liveswitch.MediaReceiverReport[]): string;
        /**
        Deserializes the properties.
        @param key The key.
        @param valueJson The value in JSON format.
        */
        protected deserializeProperties(key: string, valueJson: string): void;
        /**
        Gets the number of bytes received.
        */
        getBytesReceived(): number;
        /**
        Gets the jitter in milliseconds.
        */
        getJitter(): number;
        /**
        Gets the number of packets discarded.
        */
        getPacketsDiscarded(): number;
        /**
        Gets the number of packets duplicated.
        */
        getPacketsDuplicated(): number;
        /**
        Gets the number of packets lost.
        */
        getPacketsLost(): number;
        /**
        Gets the number of packets received.
        */
        getPacketsReceived(): number;
        /**
        Gets the number of packets repaired.
        */
        getPacketsRepaired(): number;
        /**
        Serializes the properties.
        @param jsonObject The JSON object.
        */
        protected serializeProperties(jsonObject: fm.liveswitch.Hash<string, string>): void;
        /**
        Sets the number of bytes received.
        */
        setBytesReceived(value: number): void;
        /**
        Sets the jitter in milliseconds.
        */
        setJitter(value: number): void;
        /**
        Sets the number of packets discarded.
        */
        setPacketsDiscarded(value: number): void;
        /**
        Sets the number of packets duplicated.
        */
        setPacketsDuplicated(value: number): void;
        /**
        Sets the number of packets lost.
        */
        setPacketsLost(value: number): void;
        /**
        Sets the number of packets received.
        */
        setPacketsReceived(value: number): void;
        /**
        Sets the number of packets repaired.
        */
        setPacketsRepaired(value: number): void;
        /**
        Serializes this instance to JSON.
        */
        toJson(): string;
    }
}
declare namespace fm.liveswitch {
    /**
    Media sender report.
    */
    class MediaSenderReport extends fm.liveswitch.MediaComponentReport {
        getTypeString(): string;
        /** @hidden */
        private _bytesSent;
        /** @hidden */
        private _packetsSent;
        /** @hidden */
        private _roundTripTime;
        private fmliveswitchMediaSenderReportInit;
        /**
        Initializes a new instance of the [[fm.liveswitch.mediaSenderReport]] class.
        */
        constructor();
        constructor(stats: fm.liveswitch.MediaSenderStats, lastStats: fm.liveswitch.MediaSenderStats);
        /**
        Deserializes an instance from JSON.
        @param mediaSenderReportJson The serialized JSON.
        @return The deserialized instance.
        */
        static fromJson(mediaSenderReportJson: string): fm.liveswitch.MediaSenderReport;
        /**
        Deserializes an array from JSON.
        @param mediaSenderReportsJson The serialized JSON.
        @return The deserialized array.
        */
        static fromJsonArray(mediaSenderReportsJson: string): fm.liveswitch.MediaSenderReport[];
        /**
        Serializes an instance to JSON.
        @param mediaSenderReport The instance to serialize.
        @return The serialized JSON.
        */
        static toJson(mediaSenderReport: fm.liveswitch.MediaSenderReport): string;
        /**
        Serializes an array to JSON.
        @param mediaSenderReports The array to serialize.
        @return The serialized JSON.
        */
        static toJsonArray(mediaSenderReports: fm.liveswitch.MediaSenderReport[]): string;
        /**
        Deserializes the properties.
        @param key The key.
        @param valueJson The value in JSON format.
        */
        protected deserializeProperties(key: string, valueJson: string): void;
        /**
        Gets the number of bytes sent.
        */
        getBytesSent(): number;
        /**
        Gets the number of packets sent.
        */
        getPacketsSent(): number;
        /**
        Gets the round-trip-time in milliseconds.
        */
        getRoundTripTime(): number;
        /**
        Serializes the properties.
        @param jsonObject The JSON object.
        */
        protected serializeProperties(jsonObject: fm.liveswitch.Hash<string, string>): void;
        /**
        Sets the number of bytes sent.
        */
        setBytesSent(value: number): void;
        /**
        Sets the number of packets sent.
        */
        setPacketsSent(value: number): void;
        /**
        Sets the round-trip-time in milliseconds.
        */
        setRoundTripTime(value: number): void;
        /**
        Serializes this instance to JSON.
        */
        toJson(): string;
    }
}
declare namespace fm.liveswitch {
    /**
    A message.
    */
    class Message extends fm.liveswitch.Dynamic {
        getTypeString(): string;
        /** @hidden */
        private __apiServiceId;
        /** @hidden */
        private __apiVersion;
        /** @hidden */
        private __applicationId;
        /** @hidden */
        private __channelId;
        /** @hidden */
        private __channelReports;
        /** @hidden */
        private __clientId;
        /** @hidden */
        private __clientReports;
        /** @hidden */
        private __clientRoles;
        /** @hidden */
        private __clientTag;
        /** @hidden */
        private __connectionId;
        /** @hidden */
        private __connectionTag;
        /** @hidden */
        private __connectionType;
        /** @hidden */
        private __connectorId;
        /** @hidden */
        private __deviceAlias;
        /** @hidden */
        private __deviceId;
        /** @hidden */
        private __json;
        /** @hidden */
        private __mediaId;
        /** @hidden */
        private __mediaServerId;
        /** @hidden */
        private __payload;
        /** @hidden */
        private __preferredMediaServerId;
        /** @hidden */
        private __region;
        /** @hidden */
        private __remoteClientId;
        /** @hidden */
        private __remoteConnectionId;
        /** @hidden */
        private __remoteDeviceId;
        /** @hidden */
        private __remoteMediaId;
        /** @hidden */
        private __remoteUserId;
        /** @hidden */
        private __timestamp;
        /** @hidden */
        private __token;
        /** @hidden */
        private __transactionId;
        /** @hidden */
        private __type;
        /** @hidden */
        private __userAlias;
        /** @hidden */
        private __userId;
        private fmliveswitchMessageInit;
        constructor();
        constructor(type: string);
        /**
        Creates a "bitrateNotification" message.
        */
        static createBitrateNotificationMessage(bitrateNotification: fm.liveswitch.BitrateNotification): fm.liveswitch.Message;
        /**
        Creates a "bitrateNotification" message.
        */
        static createBitrateNotificationMessage(bitrateNotifications: fm.liveswitch.BitrateNotification[]): fm.liveswitch.Message;
        /**
        Creates a "bitrateRequest" message.
        */
        static createBitrateRequestMessage(bitrateRequest: fm.liveswitch.BitrateRequest): fm.liveswitch.Message;
        /**
        Creates a "bitrateRequest" message.
        */
        static createBitrateRequestMessage(bitrateRequests: fm.liveswitch.BitrateRequest[]): fm.liveswitch.Message;
        /**
        Creates a "cancelInvite" message.
        */
        static createCancelInviteMessage(userId: string, protocol: string): fm.liveswitch.Message;
        /**
        Creates a "candidate" message.
        @param candidateJson The candidate.
        */
        static createCandidateMessage(candidateJson: string): fm.liveswitch.Message;
        /**
        Creates a "close" message.
        */
        static createCloseMessage(): fm.liveswitch.Message;
        /**
        Creates a "dtmfTones" message.
        */
        static createDtmfTonesMessage(dtmfTones: fm.liveswitch.dtmf.Tone[]): fm.liveswitch.Message;
        /**
        Creates a "error" message.
        @param error The error type.
        */
        static createErrorMessage(error: string): fm.liveswitch.Message;
        /**
        Creates a "error" message.
        @param error The error type.
        @param remoteUserId The remote user identifier.
        @param remoteDeviceId The remote device identifier.
        @param remoteClientId The remote client identifier.
        */
        static createErrorMessage(error: string, remoteUserId: string, remoteDeviceId: string, remoteClientId: string): fm.liveswitch.Message;
        /**
        Creates an "event" message.
        */
        static createEventMessage(eventInfoJson: string): fm.liveswitch.Message;
        /**
        Creates an "iceServers" message.
        */
        static createIceServersMessage(): fm.liveswitch.Message;
        /**
        Creates a "invite" message.
        */
        static createInviteMessage(userId: string, protocol: string): fm.liveswitch.Message;
        /**
        Creates a "join" message.
        @param channelId The channel to join.
        @param token The auth token.
        */
        static createJoinMessage(channelId: string, token: string): fm.liveswitch.Message;
        /**
        Creates a "keyFrameRequest" message.
        */
        static createKeyFrameRequestMessage(synchronizationSources: number[]): fm.liveswitch.Message;
        /**
        Creates a "kick" message.
        @param channelId The channel identifier.
        @param clientId The ID of the client to kick.
        */
        static createKickMessage(channelId: string, clientId: string): fm.liveswitch.Message;
        /**
        Creates a "leave" message.
        @param channelId The channel to leave.
        @param channelReport The channel report.
        */
        static createLeaveMessage(channelId: string, channelReport: fm.liveswitch.ChannelReport): fm.liveswitch.Message;
        /**
        Creates an MCU "offer" message.
        @param tag The tag.
        @param offerJson The offer.
        */
        static createMcuOfferMessage(tag: string, offerJson: string): fm.liveswitch.Message;
        /**
        Creates a "message" message.
        @param message The message.
        */
        static createMessageMessage(message: string): fm.liveswitch.Message;
        /**
        Creates a "message" message.
        @param message The message.
        @param remoteUserId The remote user identifier.
        */
        static createMessageMessage(message: string, remoteUserId: string): fm.liveswitch.Message;
        /**
        Creates a "message" message.
        @param message The message.
        @param remoteUserId The remote user identifier.
        @param remoteDeviceId The remote device identifier.
        */
        static createMessageMessage(message: string, remoteUserId: string, remoteDeviceId: string): fm.liveswitch.Message;
        /**
        Creates a "message" message.
        @param message The message.
        @param remoteUserId The remote user identifier.
        @param remoteDeviceId The remote device identifier.
        @param remoteClientId The remote client identifier.
        */
        static createMessageMessage(message: string, remoteUserId: string, remoteDeviceId: string, remoteClientId: string): fm.liveswitch.Message;
        /**
        Creates a peer "answer" message.
        @param tag The tag.
        @param answerJson The answer.
        @param remoteUserId The remote user identifier.
        @param remoteDeviceId The remote device identifier.
        @param remoteClientId The remote client identifier.
        */
        static createPeerAnswerMessage(tag: string, answerJson: string, remoteUserId: string, remoteDeviceId: string, remoteClientId: string): fm.liveswitch.Message;
        /**
        Creates a "candidate" message.
        @param candidateJson The candidate.
        @param remoteUserId The remote user identifier.
        @param remoteDeviceId The remote device identifier.
        @param remoteClientId The remote client identifier.
        */
        static createPeerCandidateMessage(candidateJson: string, remoteUserId: string, remoteDeviceId: string, remoteClientId: string): fm.liveswitch.Message;
        /**
        Creates a "close" message.
        @param remoteUserId The remote user identifier.
        @param remoteDeviceId The remote device identifier.
        @param remoteClientId The remote client identifier.
        */
        static createPeerCloseMessage(remoteUserId: string, remoteDeviceId: string, remoteClientId: string): fm.liveswitch.Message;
        /**
        Creates a peer "offer" message.
        @param tag The tag.
        @param offerJson The offer.
        @param remoteUserId The remote user identifier.
        @param remoteDeviceId The remote device identifier.
        @param remoteClientId The remote client identifier.
        */
        static createPeerOfferMessage(tag: string, offerJson: string, remoteUserId: string, remoteDeviceId: string, remoteClientId: string): fm.liveswitch.Message;
        /**
        Creates a "reject" message.
        @param remoteUserId The remote user identifier.
        @param remoteDeviceId The remote device identifier.
        @param remoteClientId The remote client identifier.
        @param remoteConnectionId The remote connection identifier.
        */
        static createPeerRejectMessage(remoteUserId: string, remoteDeviceId: string, remoteClientId: string, remoteConnectionId: string): fm.liveswitch.Message;
        /**
        Creates a "register" message.
        @param applicationId The application identifier.
        @param userId The user identifier.
        @param userAlias The user alias.
        @param deviceId The device identifier.
        @param deviceAlias The device alias.
        @param clientId The client identifier.
        @param clientTag The client tag.
        @param clientRoles The client roles.
        @param region The region.
        @param token The auth token.
        */
        static createRegisterMessage(applicationId: string, userId: string, userAlias: string, deviceId: string, deviceAlias: string, clientId: string, clientTag: string, clientRoles: string[], region: string, token: string): fm.liveswitch.Message;
        /**
        Creates an SFU upstream "offer" message.
        @param tag The tag.
        @param offerJson The offer.
        */
        static createSfuOfferMessage(tag: string, offerJson: string): fm.liveswitch.Message;
        /**
        Creates an SFU downstream "offer" message.
        @param tag The tag.
        @param offerJson The offer.
        @param remoteMediaId The remote media identifier.
        */
        static createSfuOfferMessage(tag: string, offerJson: string, remoteMediaId: string): fm.liveswitch.Message;
        /**
        Creates an SFU downstream "offer" message.
        @param tag The tag.
        @param offerJson The offer.
        @param remoteUserId The remote user identifier.
        @param remoteDeviceId The remote device identifier.
        @param remoteClientId The remote client identifier.
        @param remoteConnectionId The remote connection identifier.
        */
        static createSfuOfferMessage(tag: string, offerJson: string, remoteUserId: string, remoteDeviceId: string, remoteClientId: string, remoteConnectionId: string): fm.liveswitch.Message;
        /**
        Creates an "unregister" message.
        */
        static createUnregisterMessage(): fm.liveswitch.Message;
        /**
        Creates an "unregister" message.
        @param clientReport The client report.
        @param channelReports The channel reports.
        */
        static createUnregisterMessage(clientReport: fm.liveswitch.ClientReport, channelReports: fm.liveswitch.ChannelReport[]): fm.liveswitch.Message;
        /**
        Creates a 'update' message.
        @param configJson The config to send to the server.
        */
        static createUpdateMessage(configJson: string): fm.liveswitch.Message;
        /**
        Creates a 'update' message.
        @param configJson The config to send to the server.
        @param remoteUserId The remote user identifier.
        @param remoteDeviceId The remote device identifier.
        @param remoteClientId The remote client identifier.
        */
        static createUpdateMessage(configJson: string, remoteUserId: string, remoteDeviceId: string, remoteClientId: string): fm.liveswitch.Message;
        /**
        Deserializes an instance from JSON.
        @param messageJson The JSON to deserialize.
        @return
                    The deserialized message.
            
        */
        static fromJson(messageJson: string): fm.liveswitch.Message;
        /**
        Deserializes an array of instances from JSON.
        @param messagesJson The JSON to deserialize.
        @return
                    The deserialized messages.
            
        */
        static fromJsonArray(messagesJson: string): fm.liveswitch.Message[];
        /**
        Serializes an instance to JSON.
        @param message The message to serialize.
        @return
                    The serialized JSON.
            
        */
        static toJson(message: fm.liveswitch.Message): string;
        /**
        Serializes an array of instances to JSON.
        @param messages The messages to serialize.
        @return
                    The serialized JSON.
            
        */
        static toJsonArray(messages: fm.liveswitch.Message[]): string;
        /**
        Creates a copy of the Message.
        */
        clone(): fm.liveswitch.Message;
        /**
        Gets the API Service identifier.
        */
        getApiServiceId(): string;
        /**
        Gets the API Version.
        */
        getApiVersion(): string;
        /**
        Gets the application identifier.
        */
        getApplicationId(): string;
        /**
        Gets the channel identifier.
        */
        getChannelId(): string;
        /**
        Gets the channel reports.
        */
        getChannelReports(): fm.liveswitch.ChannelReport[];
        /**
        Gets the client identifier.
        */
        getClientId(): string;
        /**
        Gets the client reports.
        */
        getClientReports(): fm.liveswitch.ClientReport[];
        /**
        Gets the client roles.
        */
        getClientRoles(): string[];
        /**
        Gets the client tag.
        */
        getClientTag(): string;
        /**
        Gets the connection identifier.
        */
        getConnectionId(): string;
        /**
        Gets the connection tag.
        */
        getConnectionTag(): string;
        /**
        Gets the connection type.
        */
        getConnectionType(): string;
        /**
        Gets the connector identifer.
        */
        getConnectorId(): string;
        /**
        Gets the device alias.
        */
        getDeviceAlias(): string;
        /**
        Gets the device identifier.
        */
        getDeviceId(): string;
        /**
        Gets the broadcast identifier.
        */
        getMediaId(): string;
        /**
        Gets the Media Server identifier.
        */
        getMediaServerId(): string;
        /**
        Gets the payload.
        */
        getPayload(): string;
        /**
        Gets the preferred Media Server identifier.
        */
        getPreferredMediaServerId(): string;
        /**
        Gets the region.
        */
        getRegion(): string;
        /**
        Gets the remote client identifier.
        */
        getRemoteClientId(): string;
        /**
        Gets the remote connection identifier.
        */
        getRemoteConnectionId(): string;
        /**
        Gets the remote device identifier.
        */
        getRemoteDeviceId(): string;
        /**
        Gets the remote broadcast identifier.
        */
        getRemoteMediaId(): string;
        /**
        Gets the remote user identifier.
        */
        getRemoteUserId(): string;
        /**
        Gets the message timestamp.
        */
        getTimestamp(): number;
        /**
        Gets the token.
        */
        getToken(): string;
        /**
        Gets the transaction identifier.
        */
        getTransactionId(): string;
        /**
        Gets the type.
        */
        getType(): string;
        /**
        Gets the user alias.
        */
        getUserAlias(): string;
        /**
        Gets the user identifier.
        */
        getUserId(): string;
        /**
        Gets whether this message is an error of a particular type.
        @param errorType The error type.
        @return `true` if this message is an error of the particular type; otherwise, `false`.
        */
        isError(errorType: string): boolean;
        /** @hidden */
        propertiesToJson(jsonObject: fm.liveswitch.Hash<string, string>): void;
        /** @hidden */
        propertyFromJson(name: string, valueJson: string): void;
        /**
        Sets the API Service identifier.
        */
        setApiServiceId(value: string): void;
        /**
        Sets the API Version.
        */
        setApiVersion(value: string): void;
        /**
        Sets the application identifier.
        */
        setApplicationId(value: string): void;
        /**
        Sets the channel identifier.
        */
        setChannelId(value: string): void;
        /**
        Sets the channel reports.
        */
        setChannelReports(value: fm.liveswitch.ChannelReport[]): void;
        /**
        Sets the client identifier.
        */
        setClientId(value: string): void;
        /**
        Sets the client reports.
        */
        setClientReports(value: fm.liveswitch.ClientReport[]): void;
        /**
        Sets the client roles.
        */
        setClientRoles(value: string[]): void;
        /**
        Sets the client tag.
        */
        setClientTag(value: string): void;
        /**
        Sets the connection identifier.
        */
        setConnectionId(value: string): void;
        /**
        Sets the connection tag.
        */
        setConnectionTag(value: string): void;
        /**
        Sets the connection type.
        */
        setConnectionType(value: string): void;
        /**
        Sets the connector identifer.
        */
        setConnectorId(value: string): void;
        /**
        Sets the device alias.
        */
        setDeviceAlias(value: string): void;
        /**
        Sets the device identifier.
        */
        setDeviceId(value: string): void;
        /**
        Sets the broadcast identifier.
        */
        setMediaId(value: string): void;
        /**
        Sets the Media Server identifier.
        */
        setMediaServerId(value: string): void;
        /**
        Sets the payload.
        */
        setPayload(value: string): void;
        /**
        Sets the preferred Media Server identifier.
        */
        setPreferredMediaServerId(value: string): void;
        /**
        Sets the region.
        */
        setRegion(value: string): void;
        /**
        Sets the remote client identifier.
        */
        setRemoteClientId(value: string): void;
        /**
        Sets the remote connection identifier.
        */
        setRemoteConnectionId(value: string): void;
        /**
        Sets the remote device identifier.
        */
        setRemoteDeviceId(value: string): void;
        /**
        Sets the remote broadcast identifier.
        */
        setRemoteMediaId(value: string): void;
        /**
        Sets the remote user identifier.
        */
        setRemoteUserId(value: string): void;
        /**
        Sets the message timestamp.
        */
        setTimestamp(value: number): void;
        /**
        Sets the token.
        */
        setToken(value: string): void;
        /**
        Sets the transaction identifier.
        */
        setTransactionId(value: string): void;
        /**
        Sets the type.
        */
        setType(value: string): void;
        /**
        Sets the user alias.
        */
        setUserAlias(value: string): void;
        /**
        Sets the user identifier.
        */
        setUserId(value: string): void;
        /**
        Serializes this instance to JSON.
        */
        toJson(): string;
        /** @hidden */
        private updateChannelReportArray;
        /** @hidden */
        private updateClientReportArray;
        /** @hidden */
        private updateLong;
        /** @hidden */
        private updateNullableDouble;
        /** @hidden */
        private updateObject;
        /** @hidden */
        private updateString;
        /** @hidden */
        private updateStringArray;
    }
}
declare namespace fm.liveswitch {
    /**
    Message information.
    */
    class MessageInfo extends fm.liveswitch.Info {
        getTypeString(): string;
        /** @hidden */
        private _channelId;
        /** @hidden */
        private _clientId;
        /** @hidden */
        private _deviceId;
        /** @hidden */
        private _payload;
        /** @hidden */
        private _userId;
        constructor();
        /**
        Deserializes an instance from JSON.
        */
        static fromJson(messageInfoJson: string): fm.liveswitch.MessageInfo;
        /**
        Serializes an instance to JSON.
        */
        static toJson(messageInfo: fm.liveswitch.MessageInfo): string;
        /**
        Deserializes the properties.
        @param key The key.
        @param valueJson The value in JSON format.
        */
        protected deserializeProperties(key: string, valueJson: string): void;
        /**
        Gets the channel identifier.
        */
        getChannelId(): string;
        /**
        Gets the client identifier.
        */
        getClientId(): string;
        /**
        Gets the device identifier.
        */
        getDeviceId(): string;
        /**
        Gets the message.
        */
        getPayload(): string;
        /**
        Gets the user identifier.
        */
        getUserId(): string;
        /**
        Serializes the properties.
        @param jsonObject The JSON object.
        */
        protected serializeProperties(jsonObject: fm.liveswitch.Hash<string, string>): void;
        /**
        Sets the channel identifier.
        */
        setChannelId(value: string): void;
        /**
        Sets the client identifier.
        */
        setClientId(value: string): void;
        /**
        Sets the device identifier.
        */
        setDeviceId(value: string): void;
        /**
        Sets the message.
        */
        setPayload(value: string): void;
        /**
        Sets the user identifier.
        */
        setUserId(value: string): void;
        /**
        Serializes this instance to JSON.
        */
        toJson(): string;
    }
}
declare namespace fm.liveswitch {
    /**
    A message type.
    */
    class MessageType {
        getTypeString(): string;
        constructor();
        /**
        Gets the "answer" message type string.
        */
        static getAnswer(): string;
        /**
        Gets the "bitrateNotification" message type string.
        */
        static getBitrateNotification(): string;
        /**
        Gets the "bitrateRequest" message type string.
        */
        static getBitrateRequest(): string;
        /**
        Gets the "cancelInvite" message type string.
        */
        static getCancelInvite(): string;
        /**
        Gets the "candidate" message type string.
        */
        static getCandidate(): string;
        /**
        Gets the "close" message type string.
        */
        static getClose(): string;
        /**
        Gets the "dtmfTones" message type string.
        */
        static getDtmfTones(): string;
        /**
        Gets the "error" message type string.
        */
        static getError(): string;
        /**
        Gets the "event" message type string.
        */
        static getEvent(): string;
        /**
        Gets the "fail" message type string.
        */
        static getFail(): string;
        /**
        Gets the "iceServers" message type string.
        */
        static getIceServers(): string;
        /**
        Gets the "invite" message type string.
        */
        static getInvite(): string;
        /**
        Gets the "inviteFeedback" message type string.
        */
        static getInviteFeedback(): string;
        /**
        Gets the "join" message type string.
        */
        static getJoin(): string;
        /**
        Gets the "keyFrameRequest" message type string.
        */
        static getKeyFrameRequest(): string;
        /**
        Gets the "kick" message type string.
        */
        static getKick(): string;
        /**
        Gets the "leave" message type string.
        */
        static getLeave(): string;
        /**
        Gets the "mcuVideoLayout" message type string.
        */
        static getMcuVideoLayout(): string;
        /**
        Gets the "message" message type string.
        */
        static getMessage(): string;
        /**
        Gets the "notifyJoin" message type string.
        */
        static getNotifyJoin(): string;
        /**
        Gets the "notifyLeave" message type string.
        */
        static getNotifyLeave(): string;
        /**
        Gets the "notifyUpstreamClose" message type string.
        */
        static getNotifyUpstreamClose(): string;
        /**
        Gets the "notifyUpstreamOpen" message type string.
        */
        static getNotifyUpstreamOpen(): string;
        /**
        Gets the "notifyUpstreamUpdate" message type string.
        */
        static getNotifyUpstreamUpdate(): string;
        /**
        Gets the "offer" message type string.
        */
        static getOffer(): string;
        /**
        Gets the "record" message type string.
        */
        static getRecord(): string;
        /**
        Gets the "register" message type string.
        */
        static getRegister(): string;
        /**
        Gets the "reject" message type string.
        */
        static getReject(): string;
        /**
        Gets the "unregister" message type string.
        */
        static getUnregister(): string;
        /**
        Gets the "update" message type string.
        */
        static getUpdate(): string;
    }
}
declare namespace fm.liveswitch {
    /**
    Mixer report.
    */
    class MixerReport extends fm.liveswitch.Info {
        getTypeString(): string;
        /** @hidden */
        private _disabled;
        /** @hidden */
        private _inputFormat;
        /** @hidden */
        private _outputFormat;
        /** @hidden */
        private _outputFrameRate;
        /** @hidden */
        private _outputHeight;
        /** @hidden */
        private _outputWidth;
        private fmliveswitchMixerReportInit;
        constructor();
        /**
        Deserializes the properties.
        @param key The key.
        @param valueJson The value in JSON format.
        */
        protected deserializeProperties(key: string, valueJson: string): void;
        /**
        Gets whether the mixer is disabled.
        */
        getDisabled(): boolean;
        /**
        Gets the mixer input format.
        */
        getInputFormat(): fm.liveswitch.FormatInfo;
        /**
        Gets the mixer output format.
        */
        getOutputFormat(): fm.liveswitch.FormatInfo;
        /**
        Gets the mixer output frame-rate.
        */
        getOutputFrameRate(): number;
        /**
        Gets the mixer output height.
        */
        getOutputHeight(): number;
        /**
        Gets the mixer output width.
        */
        getOutputWidth(): number;
        /**
        Serializes the properties.
        @param jsonObject The JSON object.
        */
        protected serializeProperties(jsonObject: fm.liveswitch.Hash<string, string>): void;
        /**
        Sets whether the mixer is disabled.
        */
        setDisabled(value: boolean): void;
        /**
        Sets the mixer input format.
        */
        setInputFormat(value: fm.liveswitch.FormatInfo): void;
        /**
        Sets the mixer output format.
        */
        setOutputFormat(value: fm.liveswitch.FormatInfo): void;
        /**
        Sets the mixer output frame-rate.
        */
        setOutputFrameRate(value: number): void;
        /**
        Sets the mixer output height.
        */
        setOutputHeight(value: number): void;
        /**
        Sets the mixer output width.
        */
        setOutputWidth(value: number): void;
    }
}
declare namespace fm.liveswitch {
    /**
    Network interface information.
    */
    class NetworkInterfaceInfo extends fm.liveswitch.Info {
        getTypeString(): string;
        /** @hidden */
        private _adapterSpeed;
        /** @hidden */
        private _ipAddress;
        /** @hidden */
        private _mask;
        /** @hidden */
        private _type;
        private fmliveswitchNetworkInterfaceInfoInit;
        constructor();
        /**
        Deserializes Json to a NetworkInterfaceInfo.
        @param networkInterfaceInfoJson The serialized Json.
        @return The deserialized NetworkInterfaceInfo.
        */
        static fromJson(networkInterfaceInfoJson: string): fm.liveswitch.NetworkInterfaceInfo;
        /**
        Deserializes JSON to an array.
        @param networkInterfaceInfosJson The serialized JSON.
        @return The deserialized array.
        */
        static fromJsonArray(networkInterfaceInfosJson: string): fm.liveswitch.NetworkInterfaceInfo[];
        /**
        Serializes an instance to Json.
        @param client The instance to serialize.
        @return Serialized Json.
        */
        static toJson(client: fm.liveswitch.NetworkInterfaceInfo): string;
        /**
        Serializes an array to JSON.
        @param networkInterfaceInfos The array to serialize.
        @return The serialized JSON.
        */
        static toJsonArray(networkInterfaceInfos: fm.liveswitch.NetworkInterfaceInfo[]): string;
        /**
        Deserializes the properties.
        @param key The key.
        @param valueJson The value in JSON format.
        */
        protected deserializeProperties(key: string, valueJson: string): void;
        /**
        Gets the network interface adapter speed.
        */
        getAdapterSpeed(): number;
        /**
        Gets the network interface address.
        */
        getIPAddress(): string;
        /**
        Gets the network interface subnet mask.
        */
        getMask(): string;
        /**
        Gets the type.
        */
        getType(): string;
        /**
        Serializes the properties.
        @param jsonObject The JSON object.
        */
        protected serializeProperties(jsonObject: fm.liveswitch.Hash<string, string>): void;
        /**
        Sets the network interface adapter speed.
        */
        setAdapterSpeed(value: number): void;
        /**
        Sets the network interface address.
        */
        setIPAddress(value: string): void;
        /**
        Sets the network interface subnet mask.
        */
        setMask(value: string): void;
        /**
        Sets the type.
        */
        setType(value: string): void;
        /**
        Serializes this instance to Json.
        */
        toJson(): string;
    }
}
declare namespace fm.liveswitch {
    /**
    A token.
    */
    class Token {
        getTypeString(): string;
        /** @hidden */
        private __headerBase64;
        /** @hidden */
        private __payloadBase64;
        /** @hidden */
        private __signatureBase64;
        /** @hidden */
        private _algorithm;
        /** @hidden */
        private _apiServiceId;
        /** @hidden */
        private _applicationId;
        /** @hidden */
        private _channelClaims;
        /** @hidden */
        private _clientId;
        /** @hidden */
        private _clientRoles;
        /** @hidden */
        private _connectorId;
        /** @hidden */
        private _deviceId;
        /** @hidden */
        private _expirationTime;
        /** @hidden */
        private _issuedAt;
        /** @hidden */
        private _mediaServerId;
        /** @hidden */
        private _region;
        /** @hidden */
        private _type;
        /** @hidden */
        private _userId;
        /** @hidden */
        private static fm_liveswitch_Token___log;
        constructor();
        /**
        Generates a signed client join token.
        @param applicationId The application identifier.
        @param userId The user identifier.
        @param deviceId The device identifier.
        @param clientId The client identifier.
        @param channelClaim The channel claim.
        @param sharedSecret The shared secret.
        */
        static generateClientJoinToken(applicationId: string, userId: string, deviceId: string, clientId: string, channelClaim: fm.liveswitch.ChannelClaim, sharedSecret: string): string;
        /**
        Generates a signed client join token.
        @param applicationId The application identifier.
        @param userId The user identifier.
        @param deviceId The device identifier.
        @param clientId The client identifier.
        @param channelClaim The channel claim.
        @param sharedSecret The shared secret.
        @param expirationTime The time the token will expire in UTC.
        */
        static generateClientJoinToken(applicationId: string, userId: string, deviceId: string, clientId: string, channelClaim: fm.liveswitch.ChannelClaim, sharedSecret: string, expirationTime: fm.liveswitch.DateTime): string;
        /**
        Generates a signed client join token.
        @param applicationId The application identifier.
        @param userId The user identifier.
        @param deviceId The device identifier.
        @param clientId The client identifier.
        @param channelId The channel identifier.
        @param sharedSecret The shared secret.
        */
        static generateClientJoinToken(applicationId: string, userId: string, deviceId: string, clientId: string, channelId: string, sharedSecret: string): string;
        /**
        Generates a signed client join token.
        @param applicationId The application identifier.
        @param userId The user identifier.
        @param deviceId The device identifier.
        @param clientId The client identifier.
        @param channelId The channel identifier.
        @param sharedSecret The shared secret.
        @param expirationTime The time the token will expire in UTC.
        */
        static generateClientJoinToken(applicationId: string, userId: string, deviceId: string, clientId: string, channelId: string, sharedSecret: string, expirationTime: fm.liveswitch.DateTime): string;
        /**
        Generates a signed client join token.
        @param client The client.
        @param channelClaim The channel claim.
        @param sharedSecret The shared secret.
        */
        static generateClientJoinToken(client: fm.liveswitch.Client, channelClaim: fm.liveswitch.ChannelClaim, sharedSecret: string): string;
        /**
        Generates a signed client join token.
        @param client The client.
        @param channelClaim The channel claim.
        @param sharedSecret The shared secret.
        @param expirationTime The time the token will expire in UTC.
        */
        static generateClientJoinToken(client: fm.liveswitch.Client, channelClaim: fm.liveswitch.ChannelClaim, sharedSecret: string, expirationTime: fm.liveswitch.DateTime): string;
        /**
        Generates a signed client join token.
        @param client The client.
        @param channelId The channel identifier.
        @param sharedSecret The shared secret.
        */
        static generateClientJoinToken(client: fm.liveswitch.Client, channelId: string, sharedSecret: string): string;
        /**
        Generates a signed client join token.
        @param client The client.
        @param channelId The channel identifier.
        @param sharedSecret The shared secret.
        @param expirationTime The time the token will expire in UTC.
        */
        static generateClientJoinToken(client: fm.liveswitch.Client, channelId: string, sharedSecret: string, expirationTime: fm.liveswitch.DateTime): string;
        /**
        Generates a signed client register token.
        @param applicationId The application identifier.
        @param userId The user identifier.
        @param deviceId The device identifier.
        @param clientId The client identifier.
        @param clientRoles The client roles.
        @param channelClaims The channel claims.
        @param sharedSecret The shared secret.
        */
        static generateClientRegisterToken(applicationId: string, userId: string, deviceId: string, clientId: string, clientRoles: string[], channelClaims: fm.liveswitch.ChannelClaim[], sharedSecret: string): string;
        /**
        Generates a signed client register token.
        @param applicationId The application identifier.
        @param userId The user identifier.
        @param deviceId The device identifier.
        @param clientId The client identifier.
        @param clientRoles The client roles.
        @param channelClaims The channel claims.
        @param sharedSecret The shared secret.
        @param expirationTime The time the token will expire in UTC.
        */
        static generateClientRegisterToken(applicationId: string, userId: string, deviceId: string, clientId: string, clientRoles: string[], channelClaims: fm.liveswitch.ChannelClaim[], sharedSecret: string, expirationTime: fm.liveswitch.DateTime): string;
        /**
        Generates a signed client register token.
        @param applicationId The application identifier.
        @param userId The user identifier.
        @param deviceId The device identifier.
        @param clientId The client identifier.
        @param clientRoles The client roles.
        @param channelClaims The channel claims.
        @param sharedSecret The shared secret.
        @param expirationTime The time the token will expire in UTC.
        @param region The region of the client.
        */
        static generateClientRegisterToken(applicationId: string, userId: string, deviceId: string, clientId: string, clientRoles: string[], channelClaims: fm.liveswitch.ChannelClaim[], sharedSecret: string, expirationTime: fm.liveswitch.DateTime, region: string): string;
        /**
        Generates a signed client register token.
        @param applicationId The application identifier.
        @param userId The user identifier.
        @param deviceId The device identifier.
        @param clientId The client identifier.
        @param clientRoles The client roles.
        @param channelClaims The channel claims.
        @param sharedSecret The shared secret.
        @param region The region of the client.
        */
        static generateClientRegisterToken(applicationId: string, userId: string, deviceId: string, clientId: string, clientRoles: string[], channelClaims: fm.liveswitch.ChannelClaim[], sharedSecret: string, region: string): string;
        /**
        Generates a signed client register token.
        @param applicationId The application identifier.
        @param userId The user identifier.
        @param deviceId The device identifier.
        @param clientId The client identifier.
        @param clientRoles The client roles.
        @param channelId The channel identifier.
        @param sharedSecret The shared secret.
        */
        static generateClientRegisterToken(applicationId: string, userId: string, deviceId: string, clientId: string, clientRoles: string[], channelId: string, sharedSecret: string): string;
        /**
        Generates a signed client register token.
        @param applicationId The application identifier.
        @param userId The user identifier.
        @param deviceId The device identifier.
        @param clientId The client identifier.
        @param clientRoles The client roles.
        @param channelId The channel identifier.
        @param sharedSecret The shared secret.
        @param expirationTime The time the token will expire in UTC.
        */
        static generateClientRegisterToken(applicationId: string, userId: string, deviceId: string, clientId: string, clientRoles: string[], channelId: string, sharedSecret: string, expirationTime: fm.liveswitch.DateTime): string;
        /**
        Generates a signed client register token.
        @param applicationId The application identifier.
        @param userId The user identifier.
        @param deviceId The device identifier.
        @param clientId The client identifier.
        @param clientRoles The client roles.
        @param channelId The channel identifier.
        @param sharedSecret The shared secret.
        @param expirationTime The time the token will expire in UTC.
        @param region The region of the client.
        */
        static generateClientRegisterToken(applicationId: string, userId: string, deviceId: string, clientId: string, clientRoles: string[], channelId: string, sharedSecret: string, expirationTime: fm.liveswitch.DateTime, region: string): string;
        /**
        Generates a signed client register token.
        @param applicationId The application identifier.
        @param userId The user identifier.
        @param deviceId The device identifier.
        @param clientId The client identifier.
        @param clientRoles The client roles.
        @param channelId The channel identifier.
        @param sharedSecret The shared secret.
        @param region The region of the client.
        */
        static generateClientRegisterToken(applicationId: string, userId: string, deviceId: string, clientId: string, clientRoles: string[], channelId: string, sharedSecret: string, region: string): string;
        /**
        Generates a signed client register token.
        @param applicationId The application identifier.
        @param userId The user identifier.
        @param deviceId The device identifier.
        @param clientId The client identifier.
        @param clientRoles The client roles.
        @param channelIds The channel identifiers.
        @param sharedSecret The shared secret.
        */
        static generateClientRegisterToken(applicationId: string, userId: string, deviceId: string, clientId: string, clientRoles: string[], channelIds: string[], sharedSecret: string): string;
        /**
        Generates a signed client register token.
        @param applicationId The application identifier.
        @param userId The user identifier.
        @param deviceId The device identifier.
        @param clientId The client identifier.
        @param clientRoles The client roles.
        @param channelIds The channel identifiers.
        @param sharedSecret The shared secret.
        @param expirationTime The time the token will expire in UTC.
        */
        static generateClientRegisterToken(applicationId: string, userId: string, deviceId: string, clientId: string, clientRoles: string[], channelIds: string[], sharedSecret: string, expirationTime: fm.liveswitch.DateTime): string;
        /**
        Generates a signed client register token.
        @param applicationId The application identifier.
        @param userId The user identifier.
        @param deviceId The device identifier.
        @param clientId The client identifier.
        @param clientRoles The client roles.
        @param channelIds The channel identifiers.
        @param sharedSecret The shared secret.
        @param expirationTime The time the token will expire in UTC.
        @param region The region of the client.
        */
        static generateClientRegisterToken(applicationId: string, userId: string, deviceId: string, clientId: string, clientRoles: string[], channelIds: string[], sharedSecret: string, expirationTime: fm.liveswitch.DateTime, region: string): string;
        /**
        Generates a signed client register token.
        @param applicationId The application identifier.
        @param userId The user identifier.
        @param deviceId The device identifier.
        @param clientId The client identifier.
        @param clientRoles The client roles.
        @param channelIds The channel identifiers.
        @param sharedSecret The shared secret.
        @param region The region of the client.
        */
        static generateClientRegisterToken(applicationId: string, userId: string, deviceId: string, clientId: string, clientRoles: string[], channelIds: string[], sharedSecret: string, region: string): string;
        /**
        Generates a signed client register token.
        @param client The client.
        @param channelClaims The channel claims.
        @param sharedSecret The shared secret.
        */
        static generateClientRegisterToken(client: fm.liveswitch.Client, channelClaims: fm.liveswitch.ChannelClaim[], sharedSecret: string): string;
        /**
        Generates a signed client register token.
        @param client The client.
        @param channelClaims The channel claims.
        @param sharedSecret The shared secret.
        @param expirationTime The time the token will expire in UTC.
        */
        static generateClientRegisterToken(client: fm.liveswitch.Client, channelClaims: fm.liveswitch.ChannelClaim[], sharedSecret: string, expirationTime: fm.liveswitch.DateTime): string;
        /**
        Generates a signed client register token.
        @param client The client.
        @param channelClaims The channel claims.
        @param sharedSecret The shared secret.
        @param expirationTime The time the token will expire in UTC.
        @param region The region of the client.
        */
        static generateClientRegisterToken(client: fm.liveswitch.Client, channelClaims: fm.liveswitch.ChannelClaim[], sharedSecret: string, expirationTime: fm.liveswitch.DateTime, region: string): string;
        /**
        Generates a signed client register token.
        @param client The client.
        @param channelClaims The channel claims.
        @param sharedSecret The shared secret.
        @param region The region of the client.
        */
        static generateClientRegisterToken(client: fm.liveswitch.Client, channelClaims: fm.liveswitch.ChannelClaim[], sharedSecret: string, region: string): string;
        /**
        Generates a signed client register token.
        @param client The client.
        @param channelId The channel identifier.
        @param sharedSecret The shared secret.
        */
        static generateClientRegisterToken(client: fm.liveswitch.Client, channelId: string, sharedSecret: string): string;
        /**
        Generates a signed client register token.
        @param client The client.
        @param channelId The channel identifier.
        @param sharedSecret The shared secret.
        @param expirationTime The time the token will expire in UTC.
        */
        static generateClientRegisterToken(client: fm.liveswitch.Client, channelId: string, sharedSecret: string, expirationTime: fm.liveswitch.DateTime): string;
        /**
        Generates a signed client register token.
        @param client The client.
        @param channelId The channel identifier.
        @param sharedSecret The shared secret.
        @param expirationTime The time the token will expire in UTC.
        @param region The region of the client.
        */
        static generateClientRegisterToken(client: fm.liveswitch.Client, channelId: string, sharedSecret: string, expirationTime: fm.liveswitch.DateTime, region: string): string;
        /**
        Generates a signed client register token.
        @param client The client.
        @param channelId The channel identifier.
        @param sharedSecret The shared secret.
        @param region The region of the client.
        */
        static generateClientRegisterToken(client: fm.liveswitch.Client, channelId: string, sharedSecret: string, region: string): string;
        /**
        Generates a signed client register token.
        @param client The client.
        @param channelIds The channel identifiers.
        @param sharedSecret The shared secret.
        */
        static generateClientRegisterToken(client: fm.liveswitch.Client, channelIds: string[], sharedSecret: string): string;
        /**
        Generates a signed client register token.
        @param client The client.
        @param channelIds The channel identifiers.
        @param sharedSecret The shared secret.
        @param expirationTime The time the token will expire in UTC.
        */
        static generateClientRegisterToken(client: fm.liveswitch.Client, channelIds: string[], sharedSecret: string, expirationTime: fm.liveswitch.DateTime): string;
        /**
        Generates a signed client register token.
        @param client The client.
        @param channelIds The channel identifiers.
        @param sharedSecret The shared secret.
        @param expirationTime The time the token will expire in UTC.
        @param region The region of the client.
        */
        static generateClientRegisterToken(client: fm.liveswitch.Client, channelIds: string[], sharedSecret: string, expirationTime: fm.liveswitch.DateTime, region: string): string;
        /**
        Generates a signed client register token.
        @param client The client.
        @param channelIds The channel identifiers.
        @param sharedSecret The shared secret.
        @param region The region of the client.
        */
        static generateClientRegisterToken(client: fm.liveswitch.Client, channelIds: string[], sharedSecret: string, region: string): string;
        /**
        Generates a signed event token.
        @param applicationId The application identifier.
        @param sharedSecret The shared secret.
        */
        static generateEventToken(applicationId: string, sharedSecret: string): string;
        /**
        Generates a signed event token.
        @param applicationId The application identifier.
        @param sharedSecret The shared secret.
        @param expirationTime The expiration time.
        */
        static generateEventToken(applicationId: string, sharedSecret: string, expirationTime: fm.liveswitch.DateTime): string;
        /** @hidden */
        private static getClientJoinToken;
        /** @hidden */
        private static getClientRegisterToken;
        /**
        Gets the default token expiry (120 seconds).
        */
        static getDefaultExpiry(): number;
        /** @hidden */
        private static getEventToken;
        /**
        Gets the HMAC SHA-256 algorithm string.
        */
        static getHmacSha256Algorithm(): string;
        /**
        Gets the RSA SHA-256 algorithm string.
        */
        static getRsaSha256Algorithm(): string;
        /** @hidden */
        private static headerFromBase64;
        /** @hidden */
        private static headerFromJson;
        /** @hidden */
        private static headerToBase64;
        /** @hidden */
        private static headerToJson;
        /**
        Parses a token string.
        @param tokenString The token string.
        @return The token.
        */
        static parse(tokenString: string): fm.liveswitch.Token;
        /** @hidden */
        private static payloadFromBase64;
        /** @hidden */
        private static payloadFromJson;
        /** @hidden */
        private static payloadToBase64;
        /** @hidden */
        private static payloadToJson;
        /**
        Parses a token and verifies its signature.
        @param tokenString The token string.
        @param sharedSecret The shared secret.
        @return `true` if the token string could be parsed and the signature is valid; otherwise, `false`
        */
        static verify(tokenString: string, sharedSecret: string): boolean;
        /** @hidden */
        private computeSignature;
        /**
        Gets the algorithm.
        */
        getAlgorithm(): string;
        /**
        Gets the API Service identifier.
        */
        getApiServiceId(): string;
        /**
        Gets the application identifier.
        */
        getApplicationId(): string;
        /**
        Gets the first channel claim.
        */
        getChannelClaim(): fm.liveswitch.ChannelClaim;
        /**
        Gets an array of channel claims.
        */
        getChannelClaims(): fm.liveswitch.ChannelClaim[];
        /**
        Gets the client identifier.
        */
        getClientId(): string;
        /**
        Gets the client roles.
        */
        getClientRoles(): string[];
        /**
        Gets the Connector identifier.
        */
        getConnectorId(): string;
        /**
        Gets the device identifier.
        */
        getDeviceId(): string;
        /**
        Gets the "expires at" date/time.
        */
        getExpirationTime(): fm.liveswitch.DateTime;
        /**
        Gets the "issued at" date/time.
        */
        getIssuedAt(): fm.liveswitch.DateTime;
        /**
        Gets the Media Server identifier.
        */
        getMediaServerId(): string;
        /**
        Gets the region.
        */
        getRegion(): string;
        /**
        Gets the type.
        */
        getType(): string;
        /**
        Gets the user identifier.
        */
        getUserId(): string;
        /** @hidden */
        private headerToBase64;
        /** @hidden */
        private headerToJson;
        /** @hidden */
        private payloadToBase64;
        /** @hidden */
        private payloadToJson;
        /** @hidden */
        private setAlgorithm;
        /** @hidden */
        private setApiServiceId;
        /** @hidden */
        private setApplicationId;
        /** @hidden */
        private setChannelClaims;
        /** @hidden */
        private setClientId;
        /** @hidden */
        private setClientRoles;
        /** @hidden */
        private setConnectorId;
        /** @hidden */
        private setDeviceId;
        /** @hidden */
        private setExpirationTime;
        /** @hidden */
        private setIssuedAt;
        /** @hidden */
        private setMediaServerId;
        /** @hidden */
        private setRegion;
        /** @hidden */
        private setType;
        /** @hidden */
        private setUserId;
        /** @hidden */
        private sign;
        /** @hidden */
        private signBase64;
        /**
        Verifies the token signature.
        @param sharedSecret The shared secret.
        @return `true` if the signature is valid; otherwise, `false`.
            
        */
        verify(sharedSecret: string): boolean;
        /** @hidden */
        private verifyBase64;
        /** @hidden */
        private static __fmliveswitchTokenInitialized;
        /** @hidden */
        private static __fmliveswitchTokenInitializing;
        /** @hidden */
        static fmliveswitchTokenInitialize(): void;
    }
}
declare namespace fm.liveswitch {
    /**
    A claim action.
    */
    class ClaimAction {
        getTypeString(): string;
        /**
        Gets the "claim" claim action string.
        */
        static readonly Claim: string;
        /**
        Gets the "drop" claim action string.
        */
        static readonly Drop: string;
        /**
        Gets the "join" claim action string.
        */
        static readonly Join: string;
        constructor();
    }
}
declare namespace fm.liveswitch {
    /**
    A token type.
    */
    class TokenType {
        getTypeString(): string;
        constructor();
        /**
        Gets the "event" token type string.
        */
        static getEvent(): string;
        /**
        Gets the "join" token type string.
        */
        static getJoin(): string;
        /**
        Gets the "register" token type string.
        */
        static getRegister(): string;
    }
}
declare namespace fm.liveswitch {
    /**
    Transport report.
    */
    class TransportReport extends fm.liveswitch.Report {
        getTypeString(): string;
        /** @hidden */
        private _bytesReceived;
        /** @hidden */
        private _bytesSent;
        private fmliveswitchTransportReportInit;
        /**
        Initializes a new instance of the [[fm.liveswitch.transportReport]] class.
        */
        constructor();
        constructor(stats: fm.liveswitch.TransportStats, lastStats: fm.liveswitch.TransportStats);
        /**
        Deserializes Json to a TransportReport.
        @param transportReportJson The serialized Json.
        @return The deserialized TransportReport.
        */
        static fromJson(transportReportJson: string): fm.liveswitch.TransportReport;
        /**
        Serializes an instance to Json.
        @param transportReport The instance to serialize.
        @return Serialized Json.
        */
        static toJson(transportReport: fm.liveswitch.TransportReport): string;
        /**
        Deserializes the properties.
        @param key The key.
        @param valueJson The value in JSON format.
        */
        protected deserializeProperties(key: string, valueJson: string): void;
        /**
        Gets the number of bytes received on this transport.
        */
        getBytesReceived(): number;
        /**
        Gets the number of bytes sent on this transport.
        */
        getBytesSent(): number;
        /**
        Serializes the properties.
        @param jsonObject The JSON object.
        */
        protected serializeProperties(jsonObject: fm.liveswitch.Hash<string, string>): void;
        /**
        Sets the number of bytes received on this transport.
        */
        setBytesReceived(value: number): void;
        /**
        Sets the number of bytes sent on this transport.
        */
        setBytesSent(value: number): void;
        /**
        Serializes this instance to Json.
        */
        toJson(): string;
    }
}
declare namespace fm.liveswitch {
    /**
    A description of the layout within a mixed video view.
    */
    class VideoLayout {
        getTypeString(): string;
        /** @hidden */
        private _bounds;
        /** @hidden */
        private _crop;
        /** @hidden */
        private _frames;
        /** @hidden */
        private _height;
        /** @hidden */
        private _regions;
        /** @hidden */
        private _width;
        private fmliveswitchVideoLayoutInit;
        constructor();
        /**
        Initializes a new instance of the [[fm.liveswitch.videoLayout]] class.
        */
        constructor(width: number, height: number);
        /**
        Initializes a new instance of the [[fm.liveswitch.videoLayout]] class.
        */
        constructor(width: number, height: number, crop: boolean);
        /**
        Initializes a new instance of the [[fm.liveswitch.videoLayout]] class.
        */
        constructor(width: number, height: number, frames: fm.liveswitch.Hash<string, fm.liveswitch.LayoutFrame>, bounds: fm.liveswitch.Hash<string, fm.liveswitch.LayoutFrame>);
        /**
        Initializes a new instance of the [[fm.liveswitch.videoLayout]] class.
        */
        constructor(width: number, height: number, frames: fm.liveswitch.Hash<string, fm.liveswitch.LayoutFrame>, bounds: fm.liveswitch.Hash<string, fm.liveswitch.LayoutFrame>, crop: boolean);
        /** @hidden */
        private static createLayoutFrameDictionary;
        /**
        Deserializes a view from JSON.
        @param videoLayoutJson The layout JSON.
        */
        static fromJson(videoLayoutJson: string): fm.liveswitch.VideoLayout;
        /**
        Serializes a view to JSON.
        @param videoLayout The layout.
        */
        static toJson(videoLayout: fm.liveswitch.VideoLayout): string;
        /**
        Gets the bounds, keyed by connection ID.
        */
        getBounds(): fm.liveswitch.Hash<string, fm.liveswitch.LayoutFrame>;
        /** @hidden */
        private getClientKey;
        /**
        Gets whether to crop.
        */
        getCrop(): boolean;
        /**
        Gets the frames, keyed by connection ID.
        */
        getFrames(): fm.liveswitch.Hash<string, fm.liveswitch.LayoutFrame>;
        /**
        Gets the video height.
        */
        getHeight(): number;
        /**
        Gets the regions within the layout where each region has a frame, bounds, and client/connection information.
        */
        getRegions(): fm.liveswitch.VideoLayoutRegion[];
        /**
        Gets the video width.
        */
        getWidth(): number;
        /** @hidden */
        inflate(channel: fm.liveswitch.Channel, localClientInfo: fm.liveswitch.ClientInfo, remoteConnectionInfos: fm.liveswitch.ConnectionInfo[]): boolean;
        /**
        Determines whether the specified video layout is equivalent.
        @param videoLayout The video layout.
        */
        isEquivalent(videoLayout: fm.liveswitch.VideoLayout): boolean;
        /** @hidden */
        private setBounds;
        /** @hidden */
        private setCrop;
        /** @hidden */
        private setFrames;
        /** @hidden */
        private setHeight;
        /** @hidden */
        private setRegions;
        /** @hidden */
        private setWidth;
        /**
        Serializes this instance to JSON.
        */
        toJson(): string;
    }
}
declare namespace fm.liveswitch {
    /**
    A video layout region.
    */
    class VideoLayoutRegion {
        getTypeString(): string;
        /** @hidden */
        private _bounds;
        /** @hidden */
        private _clientId;
        /** @hidden */
        private _clientRoles;
        /** @hidden */
        private _clientTag;
        /** @hidden */
        private _connectionId;
        /** @hidden */
        private _connectionTag;
        /** @hidden */
        private _deviceAlias;
        /** @hidden */
        private _deviceId;
        /** @hidden */
        private _frame;
        /** @hidden */
        private _userAlias;
        /** @hidden */
        private _userId;
        /**
        Initializes a new instance of the [[fm.liveswitch.videoLayoutRegion]] class.
        @param frame The frame.
        @param bounds The bounds.
        @param userId The user identifier.
        @param userAlias The user alias.
        @param deviceId The device identifier.
        @param deviceAlias The device alias.
        @param clientId The client identifier.
        @param clientTag The client tag.
        @param clientRoles The client roles.
        @param connectionId The connection identifier.
        @param connectionTag The connection tag.
        */
        constructor(frame: fm.liveswitch.LayoutFrame, bounds: fm.liveswitch.LayoutFrame, userId: string, userAlias: string, deviceId: string, deviceAlias: string, clientId: string, clientTag: string, clientRoles: string[], connectionId: string, connectionTag: string);
        /**
        Gets the bounds.
        */
        getBounds(): fm.liveswitch.LayoutFrame;
        /**
        Gets the client identifier.
        */
        getClientId(): string;
        /**
        Gets the client roles.
        */
        getClientRoles(): string[];
        /**
        Gets the client tag.
        */
        getClientTag(): string;
        /**
        Gets the connection identifier.
        */
        getConnectionId(): string;
        /**
        Gets the connection tag.
        */
        getConnectionTag(): string;
        /**
        Gets the device alias.
        */
        getDeviceAlias(): string;
        /**
        Gets the device identifier.
        */
        getDeviceId(): string;
        /**
        Gets the frame.
        */
        getFrame(): fm.liveswitch.LayoutFrame;
        /**
        Gets the user alias.
        */
        getUserAlias(): string;
        /**
        Gets the user identifier.
        */
        getUserId(): string;
        /** @hidden */
        private setBounds;
        /** @hidden */
        private setClientId;
        /** @hidden */
        private setClientRoles;
        /** @hidden */
        private setClientTag;
        /** @hidden */
        private setConnectionId;
        /** @hidden */
        private setConnectionTag;
        /** @hidden */
        private setDeviceAlias;
        /** @hidden */
        private setDeviceId;
        /** @hidden */
        private setFrame;
        /** @hidden */
        private setUserAlias;
        /** @hidden */
        private setUserId;
    }
}
declare namespace fm.liveswitch {
    /**
    Webhook information.
    */
    class WebhookInfo extends fm.liveswitch.Info {
        getTypeString(): string;
        /** @hidden */
        private _result;
        /** @hidden */
        private _url;
        private fmliveswitchWebhookInfoInit;
        constructor();
        /**
        Deserializes Json to a WebhookInfo.
        @param webhookInfoJson The serialized Json.
        @return The deserialized WebhookInfo.
        */
        static fromJson(webhookInfoJson: string): fm.liveswitch.WebhookInfo;
        /**
        Serializes an instance to Json.
        @param webhookInfo The instance to serialize.
        @return Serialized Json.
        */
        static toJson(webhookInfo: fm.liveswitch.WebhookInfo): string;
        /**
        Deserializes the properties.
        @param key The key.
        @param valueJson The value in JSON format.
        */
        protected deserializeProperties(key: string, valueJson: string): void;
        /**
        Gets the webhook result.
        */
        getResult(): number;
        /**
        Gets the webhook URL.
        */
        getUrl(): string;
        /**
        Serializes the properties.
        @param jsonObject The JSON object.
        */
        protected serializeProperties(jsonObject: fm.liveswitch.Hash<string, string>): void;
        /**
        Sets the webhook result.
        */
        setResult(value: number): void;
        /**
        Sets the webhook URL.
        */
        setUrl(value: string): void;
        /**
        Serializes this instance to Json.
        */
        toJson(): string;
    }
}
declare namespace fm.liveswitch.signalling {
    /** @hidden */
    class BaseAdvice extends fm.liveswitch.Serializable {
        getTypeString(): string;
        /** @hidden */
        private __hosts;
        /** @hidden */
        private __interval;
        /** @hidden */
        private __reconnect;
        private fmliveswitchsignallingBaseAdviceInit;
        constructor();
        protected static deserializeReconnect(reconnectJson: string): fm.liveswitch.signalling.Reconnect;
        static fromJson(baseAdviceJson: string): fm.liveswitch.signalling.BaseAdvice;
        protected static serializeReconnect(reconnect: fm.liveswitch.signalling.Reconnect): string;
        static toJson(baseAdvice: fm.liveswitch.signalling.BaseAdvice): string;
        getHosts(): string[];
        getInterval(): number;
        getReconnect(): fm.liveswitch.signalling.Reconnect;
        setHosts(value: string[]): void;
        setInterval(value: number): void;
        setReconnect(value: fm.liveswitch.signalling.Reconnect): void;
        toJson(): string;
    }
}
declare namespace fm.liveswitch.signalling {
    /** @hidden */
    class Advice extends fm.liveswitch.signalling.BaseAdvice {
        getTypeString(): string;
        /** @hidden */
        private _callbackPolling;
        /** @hidden */
        private _longPolling;
        /** @hidden */
        private _webSocket;
        constructor();
        static fromJson(adviceJson: string): fm.liveswitch.signalling.Advice;
        static toJson(advice: fm.liveswitch.signalling.Advice): string;
        getCallbackPolling(): fm.liveswitch.signalling.BaseAdvice;
        getLongPolling(): fm.liveswitch.signalling.BaseAdvice;
        getWebSocket(): fm.liveswitch.signalling.BaseAdvice;
        setCallbackPolling(value: fm.liveswitch.signalling.BaseAdvice): void;
        setLongPolling(value: fm.liveswitch.signalling.BaseAdvice): void;
        setWebSocket(value: fm.liveswitch.signalling.BaseAdvice): void;
        toJson(): string;
    }
}
declare namespace fm.liveswitch.signalling {
    /** @hidden */
    abstract class ClientBase extends fm.liveswitch.HttpWebRequestSender {
        getTypeString(): string;
        /** @hidden */
        private __domainName;
        /** @hidden */
        private __onCreateHeaders;
        /** @hidden */
        private __onHttpRequestCreated;
        /** @hidden */
        private __onHttpResponseReceived;
        /** @hidden */
        private __onRequestCreated;
        /** @hidden */
        private __onResponseReceived;
        /** @hidden */
        private __onUnhandledException;
        /** @hidden */
        private __requestUrl;
        /** @hidden */
        private _autoDisconnect;
        /** @hidden */
        private _autoDisconnectArgs;
        /** @hidden */
        private _concurrencyMode;
        /** @hidden */
        private _disableBinary;
        /** @hidden */
        private _domainKey;
        /** @hidden */
        private _onCreateHeaders;
        /** @hidden */
        private _onHttpRequestCreated;
        /** @hidden */
        private _onHttpResponseReceived;
        /** @hidden */
        private _onRequestCreated;
        /** @hidden */
        private _onResponseReceived;
        /** @hidden */
        private _onUnhandledException;
        /** @hidden */
        private _requestMaxRetries;
        /** @hidden */
        private _requestTimeout;
        /** @hidden */
        private static fm_liveswitch_signalling_ClientBase__headers;
        private fmliveswitchsignallingClientBaseInit;
        constructor();
        /** @hidden */
        private static sanitizeDomainName;
        addOnCreateHeaders(value: fm.liveswitch.IAction1<fm.liveswitch.signalling.MessageRequestArgs>): void;
        addOnHttpRequestCreated(value: fm.liveswitch.IAction1<fm.liveswitch.HttpRequestCreatedArgs>): void;
        addOnHttpResponseReceived(value: fm.liveswitch.IAction1<fm.liveswitch.HttpResponseReceivedArgs>): void;
        addOnRequestCreated(value: fm.liveswitch.IAction1<fm.liveswitch.signalling.MessageRequestCreatedArgs>): void;
        addOnResponseReceived(value: fm.liveswitch.IAction1<fm.liveswitch.signalling.MessageResponseReceivedArgs>): void;
        addOnUnhandledException(value: fm.liveswitch.IAction1<fm.liveswitch.UnhandledExceptionArgs>): void;
        protected createHeaders(): fm.liveswitch.NameValueCollection;
        /** @hidden */
        private createHeadersNoCache;
        getAutoDisconnect(): boolean;
        getAutoDisconnectArgs(): fm.liveswitch.signalling.DisconnectArgs;
        getConcurrencyMode(): fm.liveswitch.signalling.ConcurrencyMode;
        getDisableBinary(): boolean;
        getDomainKey(): string;
        getDomainName(): string;
        protected getEmptyResponseMessage(responseArgs: fm.liveswitch.signalling.MessageResponseArgs): string;
        protected getInvalidResponseMessage(responseArgs: fm.liveswitch.signalling.MessageResponseArgs): string;
        getRequestMaxRetries(): number;
        getRequestTimeout(): number;
        getRequestUrl(): string;
        /** @hidden */
        internalOnCreateHeaders(e: fm.liveswitch.signalling.MessageRequestArgs): void;
        /** @hidden */
        internalOnHttpRequestCreated(e: fm.liveswitch.HttpRequestCreatedArgs): void;
        /** @hidden */
        internalOnHttpResponseReceived(e: fm.liveswitch.HttpResponseReceivedArgs): void;
        /** @hidden */
        internalOnRequestCreated(e: fm.liveswitch.signalling.MessageRequestCreatedArgs): void;
        /** @hidden */
        internalOnResponseReceived(e: fm.liveswitch.signalling.MessageResponseReceivedArgs): void;
        /** @hidden */
        private raiseBaseEvent;
        protected raiseUnhandledException(exception: fm.liveswitch.Exception): boolean;
        removeOnCreateHeaders(value: fm.liveswitch.IAction1<fm.liveswitch.signalling.MessageRequestArgs>): void;
        removeOnHttpRequestCreated(value: fm.liveswitch.IAction1<fm.liveswitch.HttpRequestCreatedArgs>): void;
        removeOnHttpResponseReceived(value: fm.liveswitch.IAction1<fm.liveswitch.HttpResponseReceivedArgs>): void;
        removeOnRequestCreated(value: fm.liveswitch.IAction1<fm.liveswitch.signalling.MessageRequestCreatedArgs>): void;
        removeOnResponseReceived(value: fm.liveswitch.IAction1<fm.liveswitch.signalling.MessageResponseReceivedArgs>): void;
        removeOnUnhandledException(value: fm.liveswitch.IAction1<fm.liveswitch.UnhandledExceptionArgs>): void;
        setAutoDisconnect(value: boolean): void;
        setAutoDisconnectArgs(value: fm.liveswitch.signalling.DisconnectArgs): void;
        setConcurrencyMode(value: fm.liveswitch.signalling.ConcurrencyMode): void;
        setDisableBinary(value: boolean): void;
        setDomainKey(value: string): void;
        setDomainName(value: string): void;
        setRequestMaxRetries(value: number): void;
        setRequestTimeout(value: number): void;
        setRequestUrl(value: string): void;
        /** @hidden */
        private static __fmliveswitchsignallingClientBaseInitialized;
        /** @hidden */
        private static __fmliveswitchsignallingClientBaseInitializing;
        /** @hidden */
        static fmliveswitchsignallingClientBaseInitialize(): void;
    }
}
declare namespace fm.liveswitch.signalling {
    /** @hidden */
    class Client extends fm.liveswitch.signalling.ClientBase {
        getTypeString(): string;
        /** @hidden */
        private __onClientChannelReceive;
        /** @hidden */
        private __onConnectFailure;
        /** @hidden */
        private __onConnectSuccess;
        /** @hidden */
        private __onDisconnectComplete;
        /** @hidden */
        private __onServerSubscribe;
        /** @hidden */
        private __onServerUnsubscribe;
        /** @hidden */
        private __onServiceFailure;
        /** @hidden */
        private __onServiceSuccess;
        /** @hidden */
        private __onStateChange;
        /** @hidden */
        private __receivedMessages;
        /** @hidden */
        private __restreamBackoffTimer;
        /** @hidden */
        private __state;
        /** @hidden */
        private __stateLock;
        /** @hidden */
        private __streamRequestUrl;
        /** @hidden */
        private __webSocketOpened;
        /** @hidden */
        private _authToken;
        /** @hidden */
        private _batchCounter;
        /** @hidden */
        private _batchCounterLock;
        /** @hidden */
        private _clientId;
        /** @hidden */
        private _connectionType;
        /** @hidden */
        private _counter;
        /** @hidden */
        private _counterLock;
        /** @hidden */
        private _deviceId;
        /** @hidden */
        private _disableWebSockets;
        /** @hidden */
        private _disconnectException;
        /** @hidden */
        private _lastInterval;
        /** @hidden */
        private _lastReconnect;
        /** @hidden */
        private _onClientChannelReceive;
        /** @hidden */
        private _onConnectFailure;
        /** @hidden */
        private _onConnectSuccess;
        /** @hidden */
        private _onDisconnectComplete;
        /** @hidden */
        private _onServerSubscribe;
        /** @hidden */
        private _onServerUnsubscribe;
        /** @hidden */
        private _onServiceFailure;
        /** @hidden */
        private _onServiceSuccess;
        /** @hidden */
        private _onStateChange;
        /** @hidden */
        private _pendingReceives;
        /** @hidden */
        private _queueActivated;
        /** @hidden */
        private _requestQueue;
        /** @hidden */
        private _requestTransfer;
        /** @hidden */
        private _serverTimeout;
        /** @hidden */
        private _streamId;
        /** @hidden */
        private _streamRequestTransfer;
        /** @hidden */
        private _subscribedChannels;
        /** @hidden */
        private _subscribedChannelsLock;
        /** @hidden */
        private _subscribedOnReceives;
        /** @hidden */
        private _subscribedOnReceivesDynamicProperties;
        /** @hidden */
        private _subscribedOnReceivesLock;
        /** @hidden */
        private _supportedConnectionTypes;
        /** @hidden */
        private _synchronous;
        /** @hidden */
        private _token;
        /** @hidden */
        private _userId;
        /** @hidden */
        private static fm_liveswitch_signalling_Client___log;
        /** @hidden */
        private static fm_liveswitch_signalling_Client__bayeuxMinimumVersion;
        /** @hidden */
        private static fm_liveswitch_signalling_Client__bayeuxVersion;
        /** @hidden */
        private static fm_liveswitch_signalling_Client__requestUrlCache;
        /** @hidden */
        private static fm_liveswitch_signalling_Client__requestUrlCacheLock;
        private fmliveswitchsignallingClientInit;
        constructor(requestUrl: string);
        constructor(requestUrl: string, sharedLock: Object);
        constructor(requestUrl: string, streamRequestUrl: string, sharedLock: Object);
        constructor(sharedLock: Object);
        static generateToken(): string;
        /** @hidden */
        private static getChannelForService;
        /** @hidden */
        private static getDataBytesForService;
        /** @hidden */
        private static getDataJsonForService;
        /** @hidden */
        private static getExtensions;
        /** @hidden */
        private static getSubscriptionKey;
        /** @hidden */
        private static getTimestamp;
        addOnClientChannelReceive(value: fm.liveswitch.IAction1<fm.liveswitch.signalling.SubscribeReceiveArgs>): void;
        addOnConnectFailure(value: fm.liveswitch.IAction1<fm.liveswitch.signalling.ConnectFailureArgs>): void;
        addOnConnectSuccess(value: fm.liveswitch.IAction1<fm.liveswitch.signalling.ConnectSuccessArgs>): void;
        addOnDisconnectComplete(value: fm.liveswitch.IAction1<fm.liveswitch.signalling.DisconnectCompleteArgs>): void;
        addOnServerSubscribe(value: fm.liveswitch.IAction1<fm.liveswitch.signalling.ServerSubscribeArgs>): void;
        addOnServerUnsubscribe(value: fm.liveswitch.IAction1<fm.liveswitch.signalling.ServerUnsubscribeArgs>): void;
        addOnServiceFailure(value: fm.liveswitch.IAction1<fm.liveswitch.signalling.ServiceFailureArgs>): void;
        addOnServiceSuccess(value: fm.liveswitch.IAction1<fm.liveswitch.signalling.ServiceSuccessArgs>): void;
        addOnStateChange(value: fm.liveswitch.IAction1<fm.liveswitch.signalling.Client>): void;
        /** @hidden */
        private addSubscribedChannels;
        /** @hidden */
        private addSubscribedOnReceive;
        /** @hidden */
        private addToQueue;
        /** @hidden */
        checkSynchronous(synchronous: boolean): boolean;
        /** @hidden */
        private clearSubscribedChannels;
        connect(): fm.liveswitch.signalling.Client;
        connect(connectArgs: fm.liveswitch.signalling.ConnectArgs): fm.liveswitch.signalling.Client;
        /** @hidden */
        private createFailureResponse;
        disconnect(): fm.liveswitch.signalling.Client;
        disconnect(disconnectArgs: fm.liveswitch.signalling.DisconnectArgs): fm.liveswitch.signalling.Client;
        /** @hidden */
        private doConnect;
        /** @hidden */
        private doLongPolling;
        /** @hidden */
        private doSendMany;
        endBatch(): fm.liveswitch.signalling.Client;
        getAuthToken(): string;
        getClientId(): string;
        getDisableWebSockets(): boolean;
        getDisconnectException(): fm.liveswitch.Exception;
        getServerTimeout(): number;
        getState(): fm.liveswitch.signalling.ClientState;
        getStreamId(): string;
        getStreamRequestTimeout(): number;
        getStreamRequestUrl(): string;
        getSubscribedChannels(): string[];
        getSubscribedChannels(tag: string): string[];
        getSynchronous(): boolean;
        getToken(): string;
        inBatch(): boolean;
        /** @hidden */
        private processAdvice;
        /** @hidden */
        private processMaxRetries;
        /** @hidden */
        private processPendingReceives;
        /** @hidden */
        private processQueue;
        /** @hidden */
        private processRequestUrl;
        /** @hidden */
        private processServerAction;
        /** @hidden */
        private processTimeout;
        protected raiseAction<T>(callback: fm.liveswitch.IAction1<T>, args: T, source: string): void;
        /** @hidden */
        private raiseClientChannelDelivery;
        /** @hidden */
        private raiseConnectFailure;
        /** @hidden */
        private raiseConnectSuccess;
        /** @hidden */
        private raiseDeviceChannelDelivery;
        /** @hidden */
        private raiseDisconnectComplete;
        protected raiseEvent<T extends fm.liveswitch.signalling.ClientArgs>(eventMethod: fm.liveswitch.IAction2<fm.liveswitch.signalling.Client, T>, args: T, eventName: string): void;
        protected raiseFunction<T, R>(callback: fm.liveswitch.IFunction1<T, R>, args: T, source: string): R;
        /** @hidden */
        private raiseSendException;
        /** @hidden */
        private raiseServerSubscribe;
        /** @hidden */
        private raiseServerUnsubscribe;
        /** @hidden */
        private raiseServiceFailure;
        /** @hidden */
        private raiseServiceSuccess;
        /** @hidden */
        private raiseSubscribeReceive;
        /** @hidden */
        private raiseUserChannelDelivery;
        /** @hidden */
        private receiveMessage;
        removeOnClientChannelReceive(value: fm.liveswitch.IAction1<fm.liveswitch.signalling.SubscribeReceiveArgs>): void;
        removeOnConnectFailure(value: fm.liveswitch.IAction1<fm.liveswitch.signalling.ConnectFailureArgs>): void;
        removeOnConnectSuccess(value: fm.liveswitch.IAction1<fm.liveswitch.signalling.ConnectSuccessArgs>): void;
        removeOnDisconnectComplete(value: fm.liveswitch.IAction1<fm.liveswitch.signalling.DisconnectCompleteArgs>): void;
        removeOnServerSubscribe(value: fm.liveswitch.IAction1<fm.liveswitch.signalling.ServerSubscribeArgs>): void;
        removeOnServerUnsubscribe(value: fm.liveswitch.IAction1<fm.liveswitch.signalling.ServerUnsubscribeArgs>): void;
        removeOnServiceFailure(value: fm.liveswitch.IAction1<fm.liveswitch.signalling.ServiceFailureArgs>): void;
        removeOnServiceSuccess(value: fm.liveswitch.IAction1<fm.liveswitch.signalling.ServiceSuccessArgs>): void;
        removeOnStateChange(value: fm.liveswitch.IAction1<fm.liveswitch.signalling.Client>): void;
        /** @hidden */
        private removeSubscribedChannels;
        /** @hidden */
        private removeSubscribedOnReceive;
        /** @hidden */
        private restream;
        /** @hidden */
        private send;
        /** @hidden */
        private sendCallback;
        /** @hidden */
        private sendMany;
        service(serviceArgs: fm.liveswitch.signalling.ServiceArgs): fm.liveswitch.signalling.Client;
        /** @hidden */
        private setAuthToken;
        /** @hidden */
        private setClientId;
        setDisableWebSockets(value: boolean): void;
        /** @hidden */
        private setDisconnectException;
        /** @hidden */
        private setServerTimeout;
        /** @hidden */
        private setState;
        /** @hidden */
        private setStreamId;
        setStreamRequestUrl(value: string): void;
        setSynchronous(value: boolean): void;
        setToken(value: string): void;
        startBatch(): fm.liveswitch.signalling.Client;
        /** @hidden */
        private stream;
        /** @hidden */
        private streamCallback;
        /** @hidden */
        private tryWebSocket;
        /** @hidden */
        private static __fmliveswitchsignallingClientInitialized;
        /** @hidden */
        private static __fmliveswitchsignallingClientInitializing;
        /** @hidden */
        static fmliveswitchsignallingClientInitialize(): void;
    }
}
declare namespace fm.liveswitch.signalling {
    /** @hidden */
    abstract class ClientArgs {
        getTypeString(): string;
        /** @hidden */
        private _client;
        constructor();
        getClient(): fm.liveswitch.signalling.Client;
        setClient(value: fm.liveswitch.signalling.Client): void;
    }
}
declare namespace fm.liveswitch.signalling {
    /** @hidden */
    class ClientRequest extends fm.liveswitch.Dynamic {
        getTypeString(): string;
        /** @hidden */
        private _callback;
        /** @hidden */
        private _message;
        constructor();
        getCallback(): fm.liveswitch.IAction1<fm.liveswitch.signalling.ClientResponse>;
        getMessage(): fm.liveswitch.signalling.Message;
        setCallback(value: fm.liveswitch.IAction1<fm.liveswitch.signalling.ClientResponse>): void;
        setMessage(value: fm.liveswitch.signalling.Message): void;
    }
}
declare namespace fm.liveswitch.signalling {
    /** @hidden */
    class ClientResponse extends fm.liveswitch.Dynamic {
        getTypeString(): string;
        /** @hidden */
        private _exception;
        /** @hidden */
        private _failureSource;
        /** @hidden */
        private _messages;
        /** @hidden */
        private _redirectUrl;
        /** @hidden */
        private _streamRedirectUrl;
        constructor();
        getErrorCode(): number;
        getErrorMessage(): string;
        getException(): fm.liveswitch.Exception;
        getFailureSource(): fm.liveswitch.FailureSource;
        getMessage(): fm.liveswitch.signalling.Message;
        getMessages(): fm.liveswitch.signalling.Message[];
        getRedirectUrl(): string;
        getStreamRedirectUrl(): string;
        setException(value: fm.liveswitch.Exception): void;
        setFailureSource(value: fm.liveswitch.FailureSource): void;
        setMessage(value: fm.liveswitch.signalling.Message): void;
        setMessages(value: fm.liveswitch.signalling.Message[]): void;
        setRedirectUrl(value: string): void;
        setStreamRedirectUrl(value: string): void;
    }
}
declare namespace fm.liveswitch.signalling {
    /** @hidden */
    class ClientSendState {
        getTypeString(): string;
        /** @hidden */
        private _isStream;
        /** @hidden */
        private _requestMapping;
        /** @hidden */
        private _requests;
        private fmliveswitchsignallingClientSendStateInit;
        constructor();
        getIsStream(): boolean;
        getRequestMapping(): fm.liveswitch.Hash<string, fm.liveswitch.signalling.ClientRequest>;
        getRequests(): fm.liveswitch.signalling.ClientRequest[];
        setIsStream(value: boolean): void;
        setRequestMapping(value: fm.liveswitch.Hash<string, fm.liveswitch.signalling.ClientRequest>): void;
        setRequests(value: fm.liveswitch.signalling.ClientRequest[]): void;
    }
}
declare namespace fm.liveswitch.signalling {
    /** @hidden */
    class ClientStateWrapper {
        getTypeString(): string;
        /** @hidden */
        private _value;
        constructor(value: fm.liveswitch.signalling.ClientState);
        toString(): string;
    }
}
declare namespace fm.liveswitch.signalling {
    /** @hidden */
    abstract class Extensible extends fm.liveswitch.Dynamic {
        getTypeString(): string;
        /** @hidden */
        private __extensions;
        constructor();
        static getAcknowledgementExtensionName(): string;
        static getAuthTokenExtensionName(): string;
        static getDeviceIdExtensionName(): string;
        static getDisableBinaryExtensionName(): string;
        static getMetaExtensionName(): string;
        static getRemoteClientExtensionName(): string;
        static getServerActionsExtensionName(): string;
        static getServerTimeoutExtensionName(): string;
        static getStreamIdExtensionName(): string;
        static getTagExtensionName(): string;
        static getUserIdExtensionName(): string;
        protected static sharedGetChannel(channels: string[]): string;
        protected static sharedGetChannels(channels: string[]): string[];
        protected static sharedSetChannel(channel: string): string[];
        protected static sharedSetChannel(channel: string, validate: boolean): string[];
        protected static sharedSetChannels(channels: string[]): string[];
        protected static sharedSetChannels(channels: string[], validate: boolean): string[];
        static validateChannel(channel: string, error: fm.liveswitch.Holder<string>): boolean;
        copyExtensions(extensible: fm.liveswitch.signalling.Extensible): void;
        getExtensionCount(): number;
        getExtensionNames(): Array<string>;
        getExtensions(): fm.liveswitch.signalling.Extensions;
        getExtensionValueJson(name: string): string;
        getMetaJson(): string;
        setExtensions(value: fm.liveswitch.signalling.Extensions): void;
        setExtensionValueJson(name: string, valueJson: string): void;
        setExtensionValueJson(name: string, valueJson: string, validate: boolean): void;
        setMetaJson(value: string): void;
        getExtensionValue(name: string): any;
        getMeta(): any;
        setExtensionValue(name: string, extensionValue: any): void;
        setExtensionValue(name: string, valueJson: string, extensionValue: any): void;
        setMeta(meta: any): void;
    }
}
declare namespace fm.liveswitch.signalling {
    /** @hidden */
    abstract class OutputArgs extends fm.liveswitch.signalling.Extensible {
        getTypeString(): string;
        /** @hidden */
        private __timestamp;
        /** @hidden */
        private _client;
        constructor();
        getClient(): fm.liveswitch.signalling.Client;
        getTimestamp(): fm.liveswitch.DateTime;
        setClient(value: fm.liveswitch.signalling.Client): void;
        setTimestamp(value: fm.liveswitch.DateTime): void;
    }
}
declare namespace fm.liveswitch.signalling {
    /** @hidden */
    abstract class CompleteArgs extends fm.liveswitch.signalling.OutputArgs {
        getTypeString(): string;
        constructor();
    }
}
declare namespace fm.liveswitch.signalling {
    /** @hidden */
    class ConcurrencyModeWrapper {
        getTypeString(): string;
        /** @hidden */
        private _value;
        constructor(value: fm.liveswitch.signalling.ConcurrencyMode);
        toString(): string;
    }
}
declare namespace fm.liveswitch.signalling {
    /** @hidden */
    abstract class InputArgs extends fm.liveswitch.signalling.Extensible {
        getTypeString(): string;
        /** @hidden */
        private _requestMaxRetries;
        /** @hidden */
        private _requestTimeout;
        /** @hidden */
        private _requestUrl;
        /** @hidden */
        private _synchronous;
        private fmliveswitchsignallingInputArgsInit;
        constructor();
        getRequestMaxRetries(): number;
        getRequestTimeout(): number;
        getRequestUrl(): string;
        getSynchronous(): boolean;
        setRequestMaxRetries(value: number): void;
        setRequestTimeout(value: number): void;
        setRequestUrl(value: string): void;
        setSynchronous(value: boolean): void;
    }
}
declare namespace fm.liveswitch.signalling {
    /** @hidden */
    class ConnectArgs extends fm.liveswitch.signalling.InputArgs {
        getTypeString(): string;
        /** @hidden */
        private _onFailure;
        /** @hidden */
        private _onSuccess;
        constructor();
        getOnFailure(): fm.liveswitch.IAction1<fm.liveswitch.signalling.ConnectFailureArgs>;
        getOnSuccess(): fm.liveswitch.IAction1<fm.liveswitch.signalling.ConnectSuccessArgs>;
        setOnFailure(value: fm.liveswitch.IAction1<fm.liveswitch.signalling.ConnectFailureArgs>): void;
        setOnSuccess(value: fm.liveswitch.IAction1<fm.liveswitch.signalling.ConnectSuccessArgs>): void;
    }
}
declare namespace fm.liveswitch.signalling {
    /** @hidden */
    abstract class FailureArgs extends fm.liveswitch.signalling.OutputArgs {
        getTypeString(): string;
        /** @hidden */
        private _exception;
        constructor();
        /** @hidden */
        static getErrorCode(exception: fm.liveswitch.Exception): number;
        /** @hidden */
        static getErrorMessage(exception: fm.liveswitch.Exception): string;
        getErrorCode(): number;
        getErrorMessage(): string;
        getException(): fm.liveswitch.Exception;
        setException(value: fm.liveswitch.Exception): void;
    }
}
declare namespace fm.liveswitch.signalling {
    /** @hidden */
    class ConnectFailureArgs extends fm.liveswitch.signalling.FailureArgs {
        getTypeString(): string;
        constructor();
    }
}
declare namespace fm.liveswitch.signalling {
    /** @hidden */
    class ConnectionTypeWrapper {
        getTypeString(): string;
        /** @hidden */
        private _value;
        constructor(value: fm.liveswitch.signalling.ConnectionType);
        toString(): string;
    }
}
declare namespace fm.liveswitch.signalling {
    /** @hidden */
    abstract class SuccessArgs extends fm.liveswitch.signalling.OutputArgs {
        getTypeString(): string;
        constructor();
    }
}
declare namespace fm.liveswitch.signalling {
    /** @hidden */
    class ConnectSuccessArgs extends fm.liveswitch.signalling.SuccessArgs {
        getTypeString(): string;
        /** @hidden */
        private _connectionType;
        constructor();
        getConnectionType(): fm.liveswitch.signalling.ConnectionType;
        /** @hidden */
        setConnectionType(value: fm.liveswitch.signalling.ConnectionType): void;
    }
}
declare namespace fm.liveswitch.signalling {
    /** @hidden */
    class Defaults {
        getTypeString(): string;
        /** @hidden */
        private static fm_liveswitch_signalling_Defaults___domainKey;
        /** @hidden */
        private static fm_liveswitch_signalling_Defaults___domainName;
        constructor();
        static getDomainKey(): string;
        static getDomainName(): string;
        /** @hidden */
        private static __fmliveswitchsignallingDefaultsInitialized;
        /** @hidden */
        private static __fmliveswitchsignallingDefaultsInitializing;
        /** @hidden */
        static fmliveswitchsignallingDefaultsInitialize(): void;
    }
}
declare namespace fm.liveswitch.signalling {
    /** @hidden */
    class DeferredStreamState {
        getTypeString(): string;
        /** @hidden */
        private _receivedMessages;
        private fmliveswitchsignallingDeferredStreamStateInit;
        constructor();
        getReceivedMessages(): boolean;
        setReceivedMessages(value: boolean): void;
    }
}
declare namespace fm.liveswitch.signalling {
    /** @hidden */
    class DisconnectArgs extends fm.liveswitch.signalling.InputArgs {
        getTypeString(): string;
        /** @hidden */
        private _onComplete;
        constructor();
        getOnComplete(): fm.liveswitch.IAction1<fm.liveswitch.signalling.DisconnectCompleteArgs>;
        setOnComplete(value: fm.liveswitch.IAction1<fm.liveswitch.signalling.DisconnectCompleteArgs>): void;
    }
}
declare namespace fm.liveswitch.signalling {
    /** @hidden */
    class DisconnectCompleteArgs extends fm.liveswitch.signalling.CompleteArgs {
        getTypeString(): string;
        /** @hidden */
        private _exception;
        constructor();
        getException(): fm.liveswitch.Exception;
        /** @hidden */
        setException(value: fm.liveswitch.Exception): void;
    }
}
declare namespace fm.liveswitch.signalling {
    /** @hidden */
    class Extensions extends fm.liveswitch.Dynamic {
        getTypeString(): string;
        /** @hidden */
        private _extensionJsons;
        constructor();
        static fromJson(extensionsJson: string): fm.liveswitch.signalling.Extensions;
        static toJson(extensions: fm.liveswitch.signalling.Extensions): string;
        getCount(): number;
        /** @hidden */
        private getExtensionJsons;
        getNames(): Array<string>;
        getValueJson(name: string): string;
        /** @hidden */
        private setExtensionJsons;
        setValueJson(name: string, valueJson: string): void;
        setValueJson(name: string, valueJson: string, validate: boolean): void;
        toJson(): string;
        getValue(name: string): any;
        setValue(name: string, value: any): void;
        setValue(name: string, valueJson: string, value: any): void;
    }
}
declare namespace fm.liveswitch.signalling {
    /** @hidden */
    abstract class MessageTransfer {
        getTypeString(): string;
        /** @hidden */
        private _requestArgsKey;
        constructor();
        /** @hidden */
        private static raiseRequestCreated;
        /** @hidden */
        private static raiseResponseReceived;
        httpResponseArgsToMessageResponseArgs(httpResponseArgs: fm.liveswitch.HttpResponseArgs): fm.liveswitch.signalling.MessageResponseArgs;
        messageRequestArgsToHttpRequestArgs(requestArgs: fm.liveswitch.signalling.MessageRequestArgs): fm.liveswitch.HttpRequestArgs;
        send(requestArgs: fm.liveswitch.signalling.MessageRequestArgs): fm.liveswitch.signalling.MessageResponseArgs;
        sendAsync(requestArgs: fm.liveswitch.signalling.MessageRequestArgs, callback: fm.liveswitch.IAction1<fm.liveswitch.signalling.MessageResponseArgs>): void;
        abstract sendMessages(requestArgs: fm.liveswitch.signalling.MessageRequestArgs): fm.liveswitch.signalling.MessageResponseArgs;
        abstract sendMessagesAsync(requestArgs: fm.liveswitch.signalling.MessageRequestArgs, callback: fm.liveswitch.IAction1<fm.liveswitch.signalling.MessageResponseArgs>): void;
        abstract shutdown(): void;
    }
}
declare namespace fm.liveswitch.signalling {
    /** @hidden */
    class HttpMessageTransfer extends fm.liveswitch.signalling.MessageTransfer {
        getTypeString(): string;
        /** @hidden */
        private _httpTransfer;
        constructor();
        sendMessages(requestArgs: fm.liveswitch.signalling.MessageRequestArgs): fm.liveswitch.signalling.MessageResponseArgs;
        sendMessagesAsync(requestArgs: fm.liveswitch.signalling.MessageRequestArgs, callback: fm.liveswitch.IAction1<fm.liveswitch.signalling.MessageResponseArgs>): void;
        shutdown(): void;
    }
}
declare namespace fm.liveswitch.signalling {
    /** @hidden */
    abstract class MessageBase extends fm.liveswitch.signalling.Extensible {
        getTypeString(): string;
        /** @hidden */
        __dataBytes: Uint8Array;
        /** @hidden */
        __dataJson: string;
        /** @hidden */
        private __error;
        /** @hidden */
        private __redirectUrl;
        /** @hidden */
        private __streamRedirectUrl;
        /** @hidden */
        private __successful;
        /** @hidden */
        private __timestamp;
        /** @hidden */
        private _validate;
        private fmliveswitchsignallingMessageBaseInit;
        constructor();
        protected static deserializeTimestamp(timestampJson: string): fm.liveswitch.DateTime;
        protected static serializeTimestamp(timestamp: fm.liveswitch.DateTime): string;
        getDataBytes(): Uint8Array;
        getDataJson(): string;
        getError(): string;
        getIsBinary(): boolean;
        getRedirectUrl(): string;
        getStreamRedirectUrl(): string;
        getSuccessful(): boolean;
        getTimestamp(): fm.liveswitch.DateTime;
        getValidate(): boolean;
        setDataBytes(value: Uint8Array): void;
        setDataJson(value: string): void;
        setError(value: string): void;
        setRedirectUrl(value: string): void;
        setStreamRedirectUrl(value: string): void;
        setSuccessful(value: boolean): void;
        setTimestamp(value: fm.liveswitch.DateTime): void;
        setValidate(value: boolean): void;
        getData(): any;
        setData(data: any): void;
    }
}
declare namespace fm.liveswitch.signalling {
    /** @hidden */
    class Message extends fm.liveswitch.signalling.MessageBase {
        getTypeString(): string;
        /** @hidden */
        private __advice;
        /** @hidden */
        private __bayeuxChannel;
        /** @hidden */
        private __channels;
        /** @hidden */
        private __clientId;
        /** @hidden */
        private __connectionType;
        /** @hidden */
        private __id;
        /** @hidden */
        private __minimumVersion;
        /** @hidden */
        private __supportedConnectionTypes;
        /** @hidden */
        private __version;
        /** @hidden */
        private _toJsonNoDataLock;
        /** @hidden */
        constructor();
        constructor(bayeuxChannel: string);
        /** @hidden */
        private static bytesToInt;
        /** @hidden */
        private static deserializeConnectionType;
        /** @hidden */
        private static deserializeConnectionTypeArray;
        /** @hidden */
        private static deserializeRemoteClientTable;
        static fromBinary(bytes: Uint8Array): fm.liveswitch.signalling.Message;
        static fromBinary(bytes: Uint8Array, offset: number): fm.liveswitch.signalling.Message;
        static fromBinaryMultiple(bytes: Uint8Array): fm.liveswitch.signalling.Message[];
        static fromJson(messageJson: string): fm.liveswitch.signalling.Message;
        static fromJsonArray(messagesJson: string): fm.liveswitch.signalling.Message[];
        /** @hidden */
        private static intToBytes;
        /** @hidden */
        private static serializeConnectionType;
        /** @hidden */
        private static serializeConnectionTypeArray;
        /** @hidden */
        private static serializeRemoteClientTable;
        static toBinary(message: fm.liveswitch.signalling.Message): Uint8Array;
        static toBinaryMultiple(messages: fm.liveswitch.signalling.Message[]): Uint8Array;
        static toJson(message: fm.liveswitch.signalling.Message): string;
        static toJsonArray(messages: fm.liveswitch.signalling.Message[]): string;
        getAcknowledgement(): boolean;
        getAdvice(): fm.liveswitch.signalling.Advice;
        getAuthToken(): string;
        getBayeuxChannel(): string;
        getChannel(): string;
        getChannels(): string[];
        getClientId(): string;
        getConnectionType(): fm.liveswitch.signalling.ConnectionType;
        getDeviceId(): string;
        getDisableBinary(): boolean;
        getId(): string;
        getMinimumVersion(): string;
        getRemoteClient(): fm.liveswitch.signalling.RemoteClient;
        getServerActions(): fm.liveswitch.signalling.Message[];
        getServerTimeout(): number;
        getStreamId(): string;
        getSupportedConnectionTypes(): fm.liveswitch.signalling.ConnectionType[];
        getTag(): string;
        getType(): fm.liveswitch.signalling.MessageType;
        getUserId(): string;
        getVersion(): string;
        isBind(): boolean;
        isConnect(): boolean;
        isDisconnect(): boolean;
        isPublish(): boolean;
        isService(): boolean;
        isStream(): boolean;
        isSubscribe(): boolean;
        isSubscribingTo(channel: string): boolean;
        isUnbind(): boolean;
        isUnsubscribe(): boolean;
        isUnsubscribingFrom(channel: string): boolean;
        setAcknowledgement(value: boolean): void;
        setAdvice(value: fm.liveswitch.signalling.Advice): void;
        setAuthToken(value: string): void;
        setBayeuxChannel(value: string): void;
        setChannel(value: string): void;
        setChannels(value: string[]): void;
        setClientId(value: string): void;
        setConnectionType(value: fm.liveswitch.signalling.ConnectionType): void;
        setDeviceId(value: string): void;
        setDisableBinary(value: boolean): void;
        setId(value: string): void;
        setMinimumVersion(value: string): void;
        setRemoteClient(value: fm.liveswitch.signalling.RemoteClient): void;
        setServerActions(value: fm.liveswitch.signalling.Message[]): void;
        setServerTimeout(value: number): void;
        setStreamId(value: string): void;
        setSupportedConnectionTypes(value: fm.liveswitch.signalling.ConnectionType[]): void;
        setTag(value: string): void;
        setUserId(value: string): void;
        setVersion(value: string): void;
        toBinary(): Uint8Array;
        toJson(): string;
        /** @hidden */
        private toJsonNoData;
    }
}
declare namespace fm.liveswitch.signalling {
    /** @hidden */
    class MessageRequestArgs extends fm.liveswitch.Dynamic {
        getTypeString(): string;
        /** @hidden */
        private _headers;
        /** @hidden */
        private _maxRetries;
        /** @hidden */
        private _messages;
        /** @hidden */
        private _onCreateHeaders;
        /** @hidden */
        private _onHttpRequestCreated;
        /** @hidden */
        private _onHttpResponseReceived;
        /** @hidden */
        private _onRequestCreated;
        /** @hidden */
        private _onResponseReceived;
        /** @hidden */
        private _sender;
        /** @hidden */
        private _timeout;
        /** @hidden */
        private _url;
        private fmliveswitchsignallingMessageRequestArgsInit;
        constructor();
        constructor(headers: fm.liveswitch.NameValueCollection);
        getHeaders(): fm.liveswitch.NameValueCollection;
        getIsBinary(): boolean;
        getMaxRetries(): number;
        getMessages(): fm.liveswitch.signalling.Message[];
        getOnCreateHeaders(): fm.liveswitch.IAction1<fm.liveswitch.signalling.MessageRequestArgs>;
        getOnHttpRequestCreated(): fm.liveswitch.IAction1<fm.liveswitch.HttpRequestCreatedArgs>;
        getOnHttpResponseReceived(): fm.liveswitch.IAction1<fm.liveswitch.HttpResponseReceivedArgs>;
        getOnRequestCreated(): fm.liveswitch.IAction1<fm.liveswitch.signalling.MessageRequestCreatedArgs>;
        getOnResponseReceived(): fm.liveswitch.IAction1<fm.liveswitch.signalling.MessageResponseReceivedArgs>;
        getSender(): Object;
        getTimeout(): number;
        getUrl(): string;
        setHeaders(value: fm.liveswitch.NameValueCollection): void;
        setMaxRetries(value: number): void;
        setMessages(value: fm.liveswitch.signalling.Message[]): void;
        setOnCreateHeaders(value: fm.liveswitch.IAction1<fm.liveswitch.signalling.MessageRequestArgs>): void;
        setOnHttpRequestCreated(value: fm.liveswitch.IAction1<fm.liveswitch.HttpRequestCreatedArgs>): void;
        setOnHttpResponseReceived(value: fm.liveswitch.IAction1<fm.liveswitch.HttpResponseReceivedArgs>): void;
        setOnRequestCreated(value: fm.liveswitch.IAction1<fm.liveswitch.signalling.MessageRequestCreatedArgs>): void;
        setOnResponseReceived(value: fm.liveswitch.IAction1<fm.liveswitch.signalling.MessageResponseReceivedArgs>): void;
        setSender(value: Object): void;
        setTimeout(value: number): void;
        setUrl(value: string): void;
    }
}
declare namespace fm.liveswitch.signalling {
    /** @hidden */
    class MessageRequestCreatedArgs {
        getTypeString(): string;
        /** @hidden */
        private _requests;
        /** @hidden */
        private _sender;
        constructor();
        getRequests(): fm.liveswitch.signalling.Message[];
        getSender(): Object;
        /** @hidden */
        setRequests(value: fm.liveswitch.signalling.Message[]): void;
        /** @hidden */
        setSender(value: Object): void;
    }
}
declare namespace fm.liveswitch.signalling {
    /** @hidden */
    class MessageResponseArgs extends fm.liveswitch.Dynamic {
        getTypeString(): string;
        /** @hidden */
        private _binaryContent;
        /** @hidden */
        private _exception;
        /** @hidden */
        private _headers;
        /** @hidden */
        private _messages;
        /** @hidden */
        private _requestArgs;
        /** @hidden */
        private _retries;
        /** @hidden */
        private _statusCode;
        /** @hidden */
        private _textContent;
        private fmliveswitchsignallingMessageResponseArgsInit;
        constructor(requestArgs: fm.liveswitch.signalling.MessageRequestArgs);
        getBinaryContent(): Uint8Array;
        getException(): fm.liveswitch.Exception;
        getHeaders(): fm.liveswitch.NameValueCollection;
        getMessages(): fm.liveswitch.signalling.Message[];
        getRequestArgs(): fm.liveswitch.signalling.MessageRequestArgs;
        getRetries(): number;
        getStatusCode(): number;
        getTextContent(): string;
        setBinaryContent(value: Uint8Array): void;
        setException(value: fm.liveswitch.Exception): void;
        setHeaders(value: fm.liveswitch.NameValueCollection): void;
        setMessages(value: fm.liveswitch.signalling.Message[]): void;
        setRequestArgs(value: fm.liveswitch.signalling.MessageRequestArgs): void;
        setRetries(value: number): void;
        setStatusCode(value: number): void;
        setTextContent(value: string): void;
    }
}
declare namespace fm.liveswitch.signalling {
    /** @hidden */
    class MessageResponseReceivedArgs {
        getTypeString(): string;
        /** @hidden */
        private _responses;
        /** @hidden */
        private _sender;
        constructor();
        getResponses(): fm.liveswitch.signalling.Message[];
        getSender(): Object;
        /** @hidden */
        setResponses(value: fm.liveswitch.signalling.Message[]): void;
        /** @hidden */
        setSender(value: Object): void;
    }
}
declare namespace fm.liveswitch.signalling {
    /** @hidden */
    class MessageTransferFactory {
        getTypeString(): string;
        /** @hidden */
        private static fm_liveswitch_signalling_MessageTransferFactory__createHttpMessageTransfer;
        /** @hidden */
        private static fm_liveswitch_signalling_MessageTransferFactory__createWebSocketMessageTransfer;
        constructor();
        /** @hidden */
        static defaultCreateHttpMessageTransfer(): fm.liveswitch.signalling.MessageTransfer;
        /** @hidden */
        static defaultCreateWebSocketMessageTransfer(requestUrl: string): fm.liveswitch.signalling.WebSocketMessageTransfer;
        static getCreateHttpMessageTransfer(): fm.liveswitch.IFunction0<fm.liveswitch.signalling.MessageTransfer>;
        static getCreateWebSocketMessageTransfer(): fm.liveswitch.IFunction1<string, fm.liveswitch.signalling.WebSocketMessageTransfer>;
        static getHttpMessageTransfer(): fm.liveswitch.signalling.MessageTransfer;
        static getWebSocketMessageTransfer(requestUrl: string): fm.liveswitch.signalling.WebSocketMessageTransfer;
        static setCreateHttpMessageTransfer(value: fm.liveswitch.IFunction0<fm.liveswitch.signalling.MessageTransfer>): void;
        static setCreateWebSocketMessageTransfer(value: fm.liveswitch.IFunction1<string, fm.liveswitch.signalling.WebSocketMessageTransfer>): void;
    }
}
declare namespace fm.liveswitch.signalling {
    /** @hidden */
    class MessageTypeWrapper {
        getTypeString(): string;
        /** @hidden */
        private _value;
        constructor(value: fm.liveswitch.signalling.MessageType);
        toString(): string;
    }
}
declare namespace fm.liveswitch.signalling {
    /** @hidden */
    abstract class MetaChannels {
        getTypeString(): string;
        static convertChannelFromServiced(channel: string): string;
        static convertChannelToServiced(channel: string): string;
        static getBind(): string;
        static getConnect(): string;
        static getDisconnect(): string;
        static getHandshake(): string;
        /** @hidden */
        static getMessageType(bayeuxChannel: string): fm.liveswitch.signalling.MessageType;
        static getMetaPrefix(): string;
        static getServicePrefix(): string;
        static getSubscribe(): string;
        static getUnbind(): string;
        static getUnsubscribe(): string;
        static isMetaChannel(channel: string): boolean;
        static isReservedChannel(channel: string): boolean;
        static isServiceChannel(channel: string): boolean;
    }
}
declare namespace fm.liveswitch.signalling {
    /** @hidden */
    class ReconnectWrapper {
        getTypeString(): string;
        /** @hidden */
        private _value;
        constructor(value: fm.liveswitch.signalling.Reconnect);
        toString(): string;
    }
}
declare namespace fm.liveswitch.signalling {
    /** @hidden */
    class RemoteClient extends fm.liveswitch.Serializable {
        getTypeString(): string;
        /** @hidden */
        __clientId: string;
        /** @hidden */
        __streamId: string;
        constructor();
        constructor(clientId: string, streamId: string);
        /** @hidden */
        private static createRemoteClient;
        /** @hidden */
        private static deserializeRemoteClient;
        /** @hidden */
        private static deserializeRemoteClientArray;
        /** @hidden */
        private static deserializeRemoteClientCallback;
        static fromJson(remoteClientJson: string): fm.liveswitch.signalling.RemoteClient;
        static fromJsonArray(remoteClientsJson: string): fm.liveswitch.signalling.RemoteClient[];
        /** @hidden */
        private static serializeRemoteClient;
        /** @hidden */
        private static serializeRemoteClientArray;
        /** @hidden */
        private static serializeRemoteClientCallback;
        static toJson(remoteClient: fm.liveswitch.signalling.RemoteClient): string;
        static toJsonArray(remoteClients: fm.liveswitch.signalling.RemoteClient[]): string;
        getClientId(): string;
        getStreamId(): string;
        toJson(): string;
    }
}
declare namespace fm.liveswitch.signalling {
    /** @hidden */
    class Reserved {
        getTypeString(): string;
        /** @hidden */
        private static fm_liveswitch_signalling_Reserved___clientChannelPrefix;
        constructor();
        static getClientChannel(clientId: string): string;
        static getClientChannelPrefix(): string;
        /** @hidden */
        private static __fmliveswitchsignallingReservedInitialized;
        /** @hidden */
        private static __fmliveswitchsignallingReservedInitializing;
        /** @hidden */
        static fmliveswitchsignallingReservedInitialize(): void;
    }
}
declare namespace fm.liveswitch.signalling {
    /** @hidden */
    abstract class ServerArgs extends fm.liveswitch.signalling.OutputArgs {
        getTypeString(): string;
        constructor();
    }
}
declare namespace fm.liveswitch.signalling {
    /** @hidden */
    class ServerSubscribeArgs extends fm.liveswitch.signalling.SuccessArgs {
        getTypeString(): string;
        /** @hidden */
        __channels: string[];
        /** @hidden */
        private _onReceive;
        constructor();
        getChannel(): string;
        getChannels(): string[];
        getOnReceive(): fm.liveswitch.IAction1<fm.liveswitch.signalling.SubscribeReceiveArgs>;
        getTag(): string;
        setOnReceive(value: fm.liveswitch.IAction1<fm.liveswitch.signalling.SubscribeReceiveArgs>): void;
    }
}
declare namespace fm.liveswitch.signalling {
    /** @hidden */
    class ServerUnsubscribeArgs extends fm.liveswitch.signalling.SuccessArgs {
        getTypeString(): string;
        /** @hidden */
        __channels: string[];
        constructor();
        getChannel(): string;
        getChannels(): string[];
        getTag(): string;
    }
}
declare namespace fm.liveswitch.signalling {
    /** @hidden */
    class ServiceArgs extends fm.liveswitch.signalling.InputArgs {
        getTypeString(): string;
        /** @hidden */
        __channel: string;
        /** @hidden */
        __dataBytes: Uint8Array;
        /** @hidden */
        __dataJson: string;
        /** @hidden */
        private _onFailure;
        /** @hidden */
        private _onSuccess;
        constructor();
        constructor(channel: string, dataBytes: Uint8Array);
        constructor(channel: string, dataBytes: Uint8Array, tag: string);
        constructor(channel: string, dataJson: string);
        constructor(channel: string, dataJson: string, tag: string);
        getChannel(): string;
        getDataBytes(): Uint8Array;
        getDataJson(): string;
        getIsBinary(): boolean;
        getOnFailure(): fm.liveswitch.IAction1<fm.liveswitch.signalling.ServiceFailureArgs>;
        getOnSuccess(): fm.liveswitch.IAction1<fm.liveswitch.signalling.ServiceSuccessArgs>;
        getTag(): string;
        setChannel(value: string): void;
        setDataBytes(value: Uint8Array): void;
        setDataJson(value: string): void;
        setOnFailure(value: fm.liveswitch.IAction1<fm.liveswitch.signalling.ServiceFailureArgs>): void;
        setOnSuccess(value: fm.liveswitch.IAction1<fm.liveswitch.signalling.ServiceSuccessArgs>): void;
        setTag(value: string): void;
        getData(): any;
        setData(data: any): void;
    }
}
declare namespace fm.liveswitch.signalling {
    /** @hidden */
    class ServiceFailureArgs extends fm.liveswitch.signalling.FailureArgs {
        getTypeString(): string;
        /** @hidden */
        private __channel;
        /** @hidden */
        private __dataBytes;
        /** @hidden */
        private __dataJson;
        /** @hidden */
        private _source;
        constructor(channel: string, dataJson: string, dataBytes: Uint8Array);
        getChannel(): string;
        getDataBytes(): Uint8Array;
        getDataJson(): string;
        getIsBinary(): boolean;
        getSource(): fm.liveswitch.FailureSource;
        getTag(): string;
        setSource(value: fm.liveswitch.FailureSource): void;
        getData(): any;
    }
}
declare namespace fm.liveswitch.signalling {
    /** @hidden */
    class ServiceSuccessArgs extends fm.liveswitch.signalling.SuccessArgs {
        getTypeString(): string;
        /** @hidden */
        private __channel;
        /** @hidden */
        private __dataBytes;
        /** @hidden */
        private __dataJson;
        constructor(channel: string, dataJson: string, dataBytes: Uint8Array);
        getChannel(): string;
        getDataBytes(): Uint8Array;
        getDataJson(): string;
        getIsBinary(): boolean;
        getTag(): string;
        getData(): any;
    }
}
declare namespace fm.liveswitch.signalling {
    /** @hidden */
    class SubscribeReceiveArgs extends fm.liveswitch.signalling.SuccessArgs {
        getTypeString(): string;
        /** @hidden */
        __channel: string;
        /** @hidden */
        __connectionType: fm.liveswitch.signalling.ConnectionType;
        /** @hidden */
        __dataBytes: Uint8Array;
        /** @hidden */
        __dataJson: string;
        /** @hidden */
        private _reconnectAfter;
        private fmliveswitchsignallingSubscribeReceiveArgsInit;
        constructor(channel: string, dataJson: string, dataBytes: Uint8Array, connectionType: fm.liveswitch.signalling.ConnectionType, reconnectAfter: number);
        getChannel(): string;
        getConnectionType(): fm.liveswitch.signalling.ConnectionType;
        getDataBytes(): Uint8Array;
        getDataJson(): string;
        getIsBinary(): boolean;
        getReconnectAfter(): number;
        getRemoteClient(): fm.liveswitch.signalling.RemoteClient;
        getTag(): string;
        getWasSentByMe(): boolean;
        setReconnectAfter(value: number): void;
        getData(): any;
    }
}
declare namespace fm.liveswitch.signalling {
    /** @hidden */
    class Subscription extends fm.liveswitch.Dynamic {
        getTypeString(): string;
        /** @hidden */
        private __channel;
        /** @hidden */
        private __tag;
        constructor(channel: string);
        constructor(channel: string, tag: string);
        static fromJson(subscriptionJson: string): fm.liveswitch.signalling.Subscription;
        static fromJsonArray(subscriptionsJson: string): fm.liveswitch.signalling.Subscription[];
        static toJson(subscription: fm.liveswitch.signalling.Subscription): string;
        static toJsonArray(subscriptions: fm.liveswitch.signalling.Subscription[]): string;
        duplicate(): fm.liveswitch.signalling.Subscription;
        getChannel(): string;
        getTag(): string;
        setChannel(value: string): void;
        setTag(value: string): void;
        toJson(): string;
    }
}
declare namespace fm.liveswitch.signalling {
    /** @hidden */
    class WebSocketMessageTransfer extends fm.liveswitch.signalling.MessageTransfer {
        getTypeString(): string;
        /** @hidden */
        private _url;
        /** @hidden */
        private _webSocketTransfer;
        constructor();
        constructor(url: string);
        getHandshakeTimeout(): number;
        getOnOpenFailure(): fm.liveswitch.IAction1<fm.liveswitch.WebSocketOpenFailureArgs>;
        getOnOpenSuccess(): fm.liveswitch.IAction1<fm.liveswitch.WebSocketOpenSuccessArgs>;
        getOnRequestCreated(): fm.liveswitch.IAction1<fm.liveswitch.HttpRequestCreatedArgs>;
        getOnResponseReceived(): fm.liveswitch.IAction1<fm.liveswitch.HttpResponseReceivedArgs>;
        getOnStreamFailure(): fm.liveswitch.IAction1<fm.liveswitch.WebSocketStreamFailureArgs>;
        getSender(): Object;
        getStreamTimeout(): number;
        getUrl(): string;
        open(headers: fm.liveswitch.NameValueCollection): void;
        sendMessages(requestArgs: fm.liveswitch.signalling.MessageRequestArgs): fm.liveswitch.signalling.MessageResponseArgs;
        sendMessagesAsync(requestArgs: fm.liveswitch.signalling.MessageRequestArgs, callback: fm.liveswitch.IAction1<fm.liveswitch.signalling.MessageResponseArgs>): void;
        setHandshakeTimeout(value: number): void;
        setOnOpenFailure(value: fm.liveswitch.IAction1<fm.liveswitch.WebSocketOpenFailureArgs>): void;
        setOnOpenSuccess(value: fm.liveswitch.IAction1<fm.liveswitch.WebSocketOpenSuccessArgs>): void;
        setOnRequestCreated(value: fm.liveswitch.IAction1<fm.liveswitch.HttpRequestCreatedArgs>): void;
        setOnResponseReceived(value: fm.liveswitch.IAction1<fm.liveswitch.HttpResponseReceivedArgs>): void;
        setOnStreamFailure(value: fm.liveswitch.IAction1<fm.liveswitch.WebSocketStreamFailureArgs>): void;
        setSender(value: Object): void;
        setStreamTimeout(value: number): void;
        setUrl(value: string): void;
        shutdown(): void;
    }
}
declare namespace fm.liveswitch {
    class ConnectionUtility {
        getTypeString(): string;
        static createConnection(sharedLock: Object, type: string, audioStream: fm.liveswitch.AudioStream, videoStream: fm.liveswitch.VideoStream, dataStream: fm.liveswitch.DataStream): fm.liveswitch.Connection;
    }
}
declare namespace fm.liveswitch {
}
declare namespace fm.liveswitch {
}
declare namespace fm.liveswitch {
}
declare namespace fm.liveswitch {
}
declare namespace fm.liveswitch {
}
declare namespace fm.liveswitch {
}
declare namespace fm.liveswitch {
}
declare namespace fm.liveswitch {
}
declare namespace fm.liveswitch {
}
declare namespace fm.liveswitch {
}
declare namespace fm.liveswitch {
}
declare namespace fm.liveswitch.sdp {
}
declare namespace fm.liveswitch {
}
declare namespace fm.liveswitch.sdp {
}
declare namespace fm.liveswitch.sdp.rtp {
}
declare namespace fm.liveswitch {
}
declare namespace fm.liveswitch {
}
declare namespace fm.liveswitch.datamessageheader {
}
declare namespace fm.liveswitch.datamessageheader {
}
declare namespace fm.liveswitch.datamessageheader {
}
declare namespace fm.liveswitch.datamessageheader {
}
declare namespace fm.liveswitch {
}
declare namespace fm.liveswitch {
}
declare namespace fm.liveswitch {
}
declare namespace fm.liveswitch {
}
declare namespace fm.liveswitch {
}
declare namespace fm.liveswitch {
}
declare namespace fm.liveswitch {
}
declare namespace fm.liveswitch {
}
declare namespace fm.liveswitch {
}
declare namespace fm.liveswitch.signalling {
}
declare namespace fm.liveswitch.signalling {
}
declare namespace fm.liveswitch.signalling {
}
declare namespace fm.liveswitch.signalling {
}
